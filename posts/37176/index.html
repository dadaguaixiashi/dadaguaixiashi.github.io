<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>8月知识点 | 明月清风居</title><meta name="author" content="大大怪下士"><meta name="copyright" content="大大怪下士"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="kbps  比特率单位(千比特每秒),又称千比特率,指的是数字信号的传输速率，也就是每秒钟传输多少个千位的信息(k表示千，kb表示的是多少千个位),也可以表示网络的传输速度.   VBR（Variable Bitrate）动态比特率 也就是没有固定的比特率，压缩软件在压缩时根据视频数据即时确定使用什么比特率，这是以质量为前提兼顾文件大小的方式，也是推荐的编码模式； ABR（Average Bitr">
<meta property="og:type" content="article">
<meta property="og:title" content="8月知识点">
<meta property="og:url" content="http://example.com/posts/37176/index.html">
<meta property="og:site_name" content="明月清风居">
<meta property="og:description" content="kbps  比特率单位(千比特每秒),又称千比特率,指的是数字信号的传输速率，也就是每秒钟传输多少个千位的信息(k表示千，kb表示的是多少千个位),也可以表示网络的传输速度.   VBR（Variable Bitrate）动态比特率 也就是没有固定的比特率，压缩软件在压缩时根据视频数据即时确定使用什么比特率，这是以质量为前提兼顾文件大小的方式，也是推荐的编码模式； ABR（Average Bitr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/28.jpg">
<meta property="article:published_time" content="2022-09-17T11:38:50.000Z">
<meta property="article:modified_time" content="2023-08-24T12:57:49.503Z">
<meta property="article:author" content="大大怪下士">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/28.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/posts/37176/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 大大怪下士","link":"链接: ","source":"来源: 明月清风居","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '8月知识点',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-08-24 20:57:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="明月清风居" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主题</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 索引</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 无敌</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/28.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="明月清风居"><span class="site-name">明月清风居</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主题</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 索引</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 无敌</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">8月知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-17T11:38:50.000Z" title="发表于 2022-09-17 19:38:50">2022-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-24T12:57:49.503Z" title="更新于 2023-08-24 20:57:49">2023-08-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86/">琐碎知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="8月知识点"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="kbps"><a href="#kbps" class="headerlink" title="kbps"></a>kbps</h1><hr>
<blockquote>
<p>比特率单位(千比特每秒),又称千比特率,指的是数字信号的传输速率，也就是每秒钟传输多少个千位的信息(k表示千，kb表示的是多少千个位),也可以表示网络的传输速度.</p>
</blockquote>
<ol>
<li>VBR（Variable Bitrate）动态比特率 也就是没有固定的比特率，压缩软件在压缩时根据视频数据即时确定使用什么比特率，这是以质量为前提兼顾文件大小的方式，也是推荐的编码模式；</li>
<li>ABR（Average Bitrate）平均比特率 是VBR的一种插值参数。ABR在指定的文件大小内，以固定的帧数为一段，可以做为VBR和CBR的一种折衷选择。</li>
<li>CBR（Constant Bitrate），常数比特率 指文件从头到尾都是一种位速率。相对于VBR和ABR来讲，它压缩出来的文件体积很大，而且画质相对于VBR和ABR不会有明显的提高。</li>
</ol>
<h1 id="ptime"><a href="#ptime" class="headerlink" title="ptime"></a>ptime</h1><hr>
<blockquote>
<p>官方给出的ptime定义为:ptime gives the length of time in milliseconds represented by themedia in a packet .就是一个数据包中媒体的时长，通信两侧协定的ptime尽量一致。  </p>
</blockquote>
<p>这个是根据<strong>协议</strong>进行读取的。</p>
<h1 id="解析json文件"><a href="#解析json文件" class="headerlink" title="解析json文件"></a>解析json文件</h1><hr>
<h2 id="观察json格式"><a href="#观察json格式" class="headerlink" title="观察json格式"></a>观察json格式</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;paramz&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;feeds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">299076</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;oid&quot;</span><span class="punctuation">:</span> <span class="number">288340</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;article&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;subject&quot;</span><span class="punctuation">:</span> <span class="string">&quot;荔枝新闻3.0：不止是阅读&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;summary&quot;</span><span class="punctuation">:</span> <span class="string">&quot;江苏广电旗下资讯类手机应用“荔枝新闻”于近期推出全新升级换代的3.0版。&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cover&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/Attachs/Article/288340/3e8e2c397c70469f8845fad73aa38165_padmini.JPG&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;pic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;txt&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;changed&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2015-09-22 16:01:41&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;PageIndex&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;PageSize&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;TotalCount&quot;</span><span class="punctuation">:</span> <span class="number">53521</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;TotalPage&quot;</span><span class="punctuation">:</span> <span class="number">2677</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="json文件简介"><a href="#json文件简介" class="headerlink" title="json文件简介"></a>json文件简介</h2><p>若有很多参数需要频繁更改，可以将这种类型的参数文件放在一个文本里面，然后设计一个函数接口来读取这些参数并存储在结构体或者其他类型的容器内  </p>
<h3 id="json文件的语法规则"><a href="#json文件的语法规则" class="headerlink" title="json文件的语法规则"></a>json文件的语法规则</h3><ol>
<li>每一条数据通过key:value的形式储存，如”name”:”lsx”</li>
<li>数据之间通过逗号分隔，如”name”:”lsx”,”age”:16</li>
<li>花括号用于保存对象，如”info”:{“name”:”lsx”,”age”:16}</li>
<li>一个数组中可以包含多个对象，一个对象中也可以包含多个数组</li>
</ol>
<h3 id="json值的类型"><a href="#json值的类型" class="headerlink" title="json值的类型"></a>json值的类型</h3><ol>
<li>数字(整型或浮点型)</li>
<li>字符串(双引号)“”</li>
<li>逻辑值(布尔型)</li>
<li>对象(在花括号中){}</li>
<li>数组(在中括号中)</li>
</ol>
<h2 id="json文件解析流程"><a href="#json文件解析流程" class="headerlink" title="json文件解析流程"></a>json文件解析流程</h2><ol>
<li>创建对象</li>
<li>读取根节点</li>
<li>获取子节点信息</li>
<li>对于规则子节点信息进行遍历</li>
</ol>
<h1 id="String的使用"><a href="#String的使用" class="headerlink" title="String的使用"></a>String的使用</h1><hr>
<h2 id="substr-截取string"><a href="#substr-截取string" class="headerlink" title="substr:截取string"></a>substr:截取string</h2><p>substr(str,pos,len):从pos开始的位置，截取len个字符<br>SUBSTR(str,pos):从pos开始的位置，一直到最后  </p>
<h2 id="stringstream的用法"><a href="#stringstream的用法" class="headerlink" title="stringstream的用法:"></a>stringstream的用法:</h2><p>stringstream是C++提供的串流（stream）物件 ，需要处理字符串时，往往是输入的一行中包含多个字符以及空格，这个时候就可以利用 stringstream进行单个字符或者单个字符串分析处理了  </p>
<p>stringstream的作用就是从string对象读取字符或字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>(ss&gt;&gt;ch)&#123;</span><br><span class="line">    cout&lt;&lt;ch&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h1><hr>
<blockquote>
<p>thread是C++11中提供多线程编程的模块，使用的时候需要包含<thread>头文件。</p>
</blockquote>
<p>joinable()函数是一个布尔类型的函数，他会返回一个布尔值来表示当前的线程是否是可执行线程. </p>
<p>join是将指定的线程加入当前线程，指定线程结束时才会继续执行当前线程。</p>
<p>detach是将线程从当前线程分离出去，即不会受阻塞。</p>
<p>std::jthread基于已经存在的std::thread。它基本上是一个包装器，它为线程带来了两个新功能：默认情况下，它们可以协同中断并加入。   </p>
<h1 id="notify-one-与notify-all-的区别"><a href="#notify-one-与notify-all-的区别" class="headerlink" title="notify_one()与notify_all()的区别"></a>notify_one()与notify_all()的区别</h1><hr>
<p>notify_one()：因为只唤醒等待队列中的第一个线程；不存在锁争用，所以能够立即获得锁。其余的线程不会被唤醒，需要等待再次调用notify_one()或者notify_all()。</p>
<p>notify_all()：会唤醒所有等待队列中阻塞的线程，存在锁争用，只有一个线程能够获得锁。其余线程会继续尝试获得锁(类似于轮询)，而不会再次阻塞。  </p>
<h1 id="pragma-once"><a href="#pragma-once" class="headerlink" title="#pragma once"></a>#pragma once</h1><hr>
<p>在C&#x2F;C++中，在使用预编译指令#include的时候，为了防止重复引用造成二义性，通常有两种方式  </p>
<ul>
<li>#ifndef指令防止代码块重复引用  </li>
<li>#pragma once指令，在想要保护的文件开头写入</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure>

<p>#pragma once一般由编译器提供保证：<strong>同一个文件</strong>不会被包含多次。这里所说的”同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。无法对一个头文件中的一段代码作#pragma once声明，而只能针对文件.</p>
<h1 id="ICE-面对对象中间件"><a href="#ICE-面对对象中间件" class="headerlink" title="ICE (面对对象中间件)"></a>ICE (面对对象中间件)</h1><hr>
<p>Ice 对象是本地或远地的地址空间中、能响应客户请求的实体。一个Ice对象可在一个或多个服务器中实例化。每个Ice对象都有一个或多个接口。一个接口是一个对象所支持的一系列有名称的操作，客户通过调用操作来发出请求。一个操作有零个或更多参数，以及一个返回值。每个Ice 对象都有一个唯一的对象标识。对象标识是用于把一个对象与其他所有对象区别开来的标识值。 Ice 对象模型假定对象标识是全局唯一的，也就是说，在一个Ice 通信域中，不会有两个对象具有相同的对象标识。对象标识既可以通过调用GenerateUUID（）全局唯一产生，也可以根据自己的喜好随意创建一个，只要没与其他对象标识重复即可。</p>
<ul>
<li>代理<br>要想与某个Ice对象联系，客户必须持有这个对象的代理。对客户而言，代理就是Ice对象的本地代表（该对象可能在远地）。代理所封装的信息有：寻址信息：用于让客户端run time 联系正确的服务器对象标识：用于确定服务器中的哪一个对象是请求的目标可选的facet 标识符：用于确定代理所引用的是对象的哪一个facet。</li>
<li>Servants<br>Ice 对象是一种具有类型、标识，以及寻址信息，在本地或远地的地址空间中、能响应客户请求的实体的概念性实体。而Servants是服务器端用具体的编程语言实现的实体，并且在服务器的地址空间中进行实例化。 Servants 为“客户发送的操作调用”提供服务器端行为。  </li>
<li>动态映射表<br>动态映射表（ Active servant map），简称ASM。之所以称为动态映射表，是因为它可以动态维护servant的数量，可以添加，也可以删除。它是一个查找表，用于把对象标识映射到servant；要激活一个servant，就将它添加进动态映射表。这个过程可以看作是在“Ice 对象的标识”与“对应的用编程语言编写的、负责为该ICE对象处理请求的servant”之间创建链接。这个链接创建好之后，一旦客户端的请求到来时， Ice run time 就可以将该请求分派给正确的servant来执行。动态servant映射表的几种操作行为如下：  </li>
<li>add<br>add 操作把一个具有指定标识的servant 增加到ASM中。一旦add 被调用，请求就会分派给这个servant。返回值是这个servant 所体现的Ice对象的代理。你不能用同一标识多次调用add：如果你试图在ASM 中增加一个已经存在的标识，就会引发AlreadyRegisteredException  </li>
<li>addWithUUID<br>addWithUUID 操作的行为和add 操作一样，但你不需要为servant 提供标识。addWithUUID 会生成一个UUID，作为对应的Ice 对象的标识。</li>
<li>remove<br>remove 操作中断对象标识与其servant 之间的关联，从ASM 中移除对应的条目。一旦servant 解除了激活，新到来的针对已移除的对象标识的请求会引发ObjectNotExistException</li>
</ul>
<h2 id="ICE实现过程"><a href="#ICE实现过程" class="headerlink" title="ICE实现过程"></a>ICE实现过程</h2><ul>
<li>服务器端</li>
</ul>
<ol>
<li>创建 servant 类，并在服务器端 Ice run time 上注册。  </li>
<li>实例化 servant 类，创建具体的 servant。  </li>
<li>为这个 servant 所体现的 Ice 对象创建标识。  </li>
<li>激活 servant（即将 servant 添加进动态 servant 映射表）</li>
</ol>
<ul>
<li>客户端</li>
</ul>
<ol>
<li>当客户端要调用某一操作时， 客户端 run time 会将对象标识以及请求一起发给服务器。  </li>
<li>服务器端的对象适配器接收到了请求和对象标识， 对象适配器继而根据这个对象标识，在它所维护管理的active servant map中查找其相对应的正确的servant。  </li>
<li>若找到了与对象标识对应的正确的servant，就把调用分派给它。若查找不到，就会引发Object Not Exist Exception。最后客户端接收到来自服务器端的返回值或异常信息。</li>
</ol>
<h1 id="c-str-方法解析"><a href="#c-str-方法解析" class="headerlink" title="c_str()方法解析"></a>c_str()方法解析</h1><hr>
<p>指向一个字符串数组的指针</p>
<h1 id="C-实现线程池"><a href="#C-实现线程池" class="headerlink" title="C++实现线程池"></a>C++实现线程池</h1><hr>
<h2 id="线程池的介绍"><a href="#线程池的介绍" class="headerlink" title="线程池的介绍"></a>线程池的介绍</h2><blockquote>
<p>作为五大池之一(内存池，连接池，线程池，进程池，携程池)，线程池的应用十分广泛，不管是客户端程序还是后台服务端，都是提高业务处理能力的必备模块。</p>
</blockquote>
<h2 id="线程池知识背景"><a href="#线程池知识背景" class="headerlink" title="线程池知识背景"></a>线程池知识背景</h2><ul>
<li>C++面向对象的标准：组合和继承，多态，STL容器，智能指针，函数对象，绑定器，可变参数等    </li>
<li>C++11多线程编程：thread、mutex、atomic、condition_variable、unique_lock等</li>
</ul>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>当进行并行的任务作业操作时，线程的建立与销毁的开销是，阻碍性能进步的关键，因此线程池，由此产生。使用多个线程，无限制循环等待队列，进行计算和操作。帮助快速降低和减少性能损耗。</p>
<h3 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h3><ol>
<li>线程池管理器:初始化和创建线程，启动和停止线程，调配任务，管理线程池。</li>
<li>工作线程:线程池中等待并执行分配的任务</li>
<li>任务接口:添加任务的接口，以提供工作线程调度任务的执行。</li>
<li>任务队列:用于存放没有处理的任务，提供一种缓冲机制，同时具有调度功能，高优先级的任务放在队列前面。</li>
</ol>
<h2 id="线程池工作的四种情况"><a href="#线程池工作的四种情况" class="headerlink" title="线程池工作的四种情况"></a>线程池工作的四种情况</h2><p>1.<strong>没有任务要执行，缓冲队列为空</strong></p>
<p><img src="/../img/3805f625e05f8e2d1d0b69910323d7a9.png"></p>
<ol start="2">
<li><p><strong>队列中任务数量，小于等于线程池中线程任务数量</strong></p>
<p><img src="/../img/b72937b576e8e3e4a0b14ff5a9b3a1b9.png"></p>
</li>
</ol>
<p>3.<strong>任务数量大于线程池数量,缓冲队列未满</strong></p>
<p><img src="/../img/3bc05a0abf3eff2c7e25427e1c2636bb.png"></p>
<p>4.<strong>任务数量大于线程池数量，缓冲队列已满</strong></p>
<p><img src="/../img/4a50fc4f32e13a1761c2e687a58a83a4.png"></p>
<h2 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h2><ul>
<li>任务队列</li>
<li>线程池</li>
<li>完成队列</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>我们使用队列来存储工作，因为它是更合理的数据结构。 我们希望以与发送它相同的顺序启动工作。 但是，这个队列有点特殊。正如我在上一节中所说的，线程是连续的（好吧，不是真的，但我们假设它们是）查询队列要求工作。当有可用的工作时，线程从队列中获取工作并执行它。如果两个线程试图同时执行相同的工作会发生什么？ 好吧，程序会崩溃。<br>为了避免这种问题，我在标准C ++ Queue上实现了一个包装器，它使用mutex来限制并发访问。 让我们看一下SafeQueue类的一小部分示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_queue.<span class="built_in">push</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提交函数"><a href="#提交函数" class="headerlink" title="提交函数"></a>提交函数</h3><p>线程池最重要的方法是负责向队列添加工作的方法。我打电话给这个方法提交。不难理解它是如何工作的，但它的实现起初可能看起来很吓人。让我们考虑应该做什么，之后我们会担心如何做到这一点。 什么：</p>
<ul>
<li>接受任何参数的任何函数。</li>
<li>立即返回“东西”以避免阻塞主线程。 此返回的对象最终应包含操作的结果。<br>完整的提交函数如下所示：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Submit a function to be executed asynchronously by the pool template&lt;typename F, typename...Args&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Create a function with bounded parameters ready to execute</span></span><br><span class="line">    std::function&lt;<span class="keyword">decltype</span>(f(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="comment">// Encapsulate it into a shared ptr in order to be able to copy construct / assign </span></span><br><span class="line">    <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt;&gt;(func);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wrap packaged task into void function</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; wrapper_func = [task_ptr]() &#123;</span><br><span class="line">      (*task_ptr)(); </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue generic wrapper function</span></span><br><span class="line">    m_queue.<span class="built_in">enqueue</span>(wrapperfunc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake up one thread if its waiting</span></span><br><span class="line">    m_conditional_lock.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return future from promise</span></span><br><span class="line">    <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="线程池的实现实例"><a href="#线程池的实现实例" class="headerlink" title="线程池的实现实例"></a>线程池的实现实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadPool.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SafeQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ThreadWorker</span> &#123;<span class="comment">//内置线程工作类</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_id; <span class="comment">//工作id</span></span><br><span class="line"></span><br><span class="line">    ThreadPool * m_pool;<span class="comment">//所属线程池</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadWorker</span>(ThreadPool * pool, <span class="type">const</span> <span class="type">int</span> id) </span><br><span class="line">      : <span class="built_in">m_pool</span>(pool), <span class="built_in">m_id</span>(id) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载`()`操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      std::function&lt;<span class="type">void</span>()&gt; func; <span class="comment">//定义基础函数类func</span></span><br><span class="line">      </span><br><span class="line">      <span class="type">bool</span> dequeued; <span class="comment">//是否正在取出队列中元素</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//判断线程池是否关闭，没有关闭，循环提取</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (!m_pool-&gt;m_shutdown) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//为线程环境锁加锁，互访问工作线程的休眠和唤醒</span></span><br><span class="line"></span><br><span class="line">          <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_pool-&gt;m_conditional_mutex)</span></span>;</span><br><span class="line">          <span class="comment">//如果任务队列为空，阻塞当前线程</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (m_pool-&gt;m_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            m_pool-&gt;m_conditional_lock.<span class="built_in">wait</span>(lock); <span class="comment">//等待条件变量通知，开启线程</span></span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//取出任务队列中的元素</span></span><br><span class="line"></span><br><span class="line">          dequeued = m_pool-&gt;m_queue.<span class="built_in">dequeue</span>(func);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果成功取出，执行工作函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dequeued) &#123;</span><br><span class="line">          <span class="built_in">func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> m_shutdown; <span class="comment">//线程池是否关闭</span></span><br><span class="line"></span><br><span class="line">  SafeQueue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; m_queue;<span class="comment">//执行函数安全队列，即任务队列</span></span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::thread&gt; m_threads; <span class="comment">//工作线程队列</span></span><br><span class="line"></span><br><span class="line">  std::mutex m_conditional_mutex;<span class="comment">//线程休眠锁互斥变量</span></span><br><span class="line"></span><br><span class="line">  std::condition_variable m_conditional_lock; <span class="comment">//线程环境锁，让线程可以处于休眠或者唤醒状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//线程池构造函数</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">ThreadPool</span>(<span class="type">const</span> <span class="type">int</span> n_threads)</span><br><span class="line">    : <span class="built_in">m_threads</span>(std::<span class="built_in">vector</span>&lt;std::thread&gt;(n_threads)), <span class="built_in">m_shutdown</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>; <span class="comment">//拷贝构造函数，并且取消默认父类构造函数</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">ThreadPool</span>(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>; <span class="comment">// 拷贝构造函数，允许右值引用</span></span><br><span class="line"></span><br><span class="line">  ThreadPool &amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>; <span class="comment">// 赋值操作</span></span><br><span class="line"></span><br><span class="line">  ThreadPool &amp; <span class="keyword">operator</span>=(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Inits thread pool</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      m_threads[i] = std::<span class="built_in">thread</span>(<span class="built_in">ThreadWorker</span>(<span class="keyword">this</span>, i));<span class="comment">//分配工作线程</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Waits until threads finish their current task and shutdowns the pool</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_shutdown = <span class="literal">true</span>;</span><br><span class="line">    m_conditional_lock.<span class="built_in">notify_all</span>(); <span class="comment">//通知 唤醒所有工作线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span>(m_threads[i].<span class="built_in">joinable</span>()) &#123; <span class="comment">//判断线程是否正在等待</span></span><br><span class="line"></span><br><span class="line">        m_threads[i].<span class="built_in">join</span>();  <span class="comment">//将线程加入等待队列</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Submit a function to be executed asynchronously by the pool</span></span><br><span class="line">  <span class="comment">//线程的主要工作函数，使用了后置返回类型，自动判断函数返回值</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Create a function with bounded parameters ready to execute</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="keyword">decltype</span>(f(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);<span class="comment">//连接函数和参数定义，特殊函数类型,避免左、右值错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encapsulate it into a shared ptr in order to be able to copy construct // assign </span></span><br><span class="line">    <span class="comment">//封装获取任务对象，方便另外一个线程查看结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt;&gt;(func);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wrap packaged task into void function</span></span><br><span class="line">    <span class="comment">//利用正则表达式，返回一个函数对象</span></span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; wrapper_func = [task_ptr]() &#123;</span><br><span class="line">      (*task_ptr)(); </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列通用安全封包函数，并压入安全队列</span></span><br><span class="line"></span><br><span class="line">    m_queue.<span class="built_in">enqueue</span>(wrapper_func);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒一个等待中的线程</span></span><br><span class="line"></span><br><span class="line">    m_conditional_lock.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回先前注册的任务指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="软解和硬解"><a href="#软解和硬解" class="headerlink" title="软解和硬解"></a>软解和硬解</h1><hr>
<h2 id="软解"><a href="#软解" class="headerlink" title="软解"></a>软解</h2><blockquote>
<p>利用软件本身解码，但是实际上还是使用CPU进行解码</p>
</blockquote>
<p>在软件解码过程中，需要对于大量的视频信息进行运算，对于CPU的性能要求非常高。对于高清大大码率的视频来说，巨大的运算量就会造成转换效率低，发热量高等问题。</p>
<p>软解码不需要过多的硬件支持，兼容性非常高，即使出现新的视频编码格式，只要安装好相应的解码器文件，就可以顺利播放。而且软解码拥有丰富的滤镜，字幕，画面处理优化等效果，只有你CPU够强悍，就能够实现更加出色的画面效果。</p>
<h2 id="硬解"><a href="#硬解" class="headerlink" title="硬解"></a>硬解</h2><blockquote>
<p>字面上的意思就是硬件解码。通过设备上的显卡GPU的视频加速功能对高清视频进行解码。</p>
</blockquote>
<p>硬解调用GPU的专门模块编码来解码，减少CPU运算。显卡核心GPU拥有独特的计算方法，解码效率非常高，这样不但能够减轻CPU的负担，还有着低功耗，发热少等特点。</p>
<p>但是，由于硬解码起步比较晚，软件和驱动对他的支持度很低，基本上硬解码内置什么样的模块，就解码什么样的视频，面对网上各色各样的视频编码样式，往往会出现兼容性不好的问题。此外，硬解码的滤镜、字幕、画质方面都做的不够理想。</p>
<h2 id="软硬解的优劣区别"><a href="#软硬解的优劣区别" class="headerlink" title="软硬解的优劣区别"></a>软硬解的优劣区别</h2><hr>
<ul>
<li>GPU硬解码高清视频的优势<ol>
<li>不需要太好的CPU，单核足矣，CPU方面节约不少资金；</li>
<li>硬解码基本相当于免费附送，不到500元的整合主板都能完美支持；</li>
<li>硬解码让CPU占用率超低，系统有能力在看HDTV的同时进行多任务操作；</li>
<li>CPU需要倾尽全力才能解码HDTV，而GPU只需动用0.1亿晶体管的解码模块就能完成任务，功耗控制更好；</li>
</ol>
</li>
<li>GPU硬解码高清视频的劣势<ol>
<li>起步较晚，软件支持度无法与软解相提并论；</li>
<li>面对杂乱无章的视频编码、封装格式，硬解码无法做到全面兼容；</li>
<li>软解拥有大量画面输出补偿及画质增强技术，而硬解这方面做得还远远不够；</li>
<li>硬解码软件设置较为复杂，很多朋友根本不知道该如何正确使用GPU硬件解码。</li>
</ol>
</li>
</ul>
<h2 id="C-chrono-库中的-steady-clock-和-system-clock"><a href="#C-chrono-库中的-steady-clock-和-system-clock" class="headerlink" title="C++ chrono 库中的 steady_clock 和 system_clock"></a>C++ chrono 库中的 steady_clock 和 system_clock</h2><p>C++11中的标准库<chrono>中有三种时钟:steady_clock,system_clock,high_resolution_clock</p>
<ol>
<li>steady_clock是**单调的时钟,**只会增长，适用于程序耗时</li>
<li>system_clock 是<strong>系统的时钟</strong>；因为系统的时钟可以修改；甚至可以网络对时； 所以用系统时间计算时间差可能不准。</li>
<li>high_resolution_clock 是<strong>当前系统能够提供的最高精度的时钟</strong>；它也是<strong>不可以修改的</strong>。相当于 steady_clock 的高精度版本。</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copied from http://www.informit.com/articles/article.aspx?p=1881386&amp;seqNum=2;</span></span><br><span class="line"><span class="comment">// Author: Nicolai M. Josuttis</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printClockData</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;- precision: &quot;</span>;</span><br><span class="line">    <span class="comment">// if time unit is less or equal one millisecond</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> C::period P;<span class="comment">// type of time unit</span></span><br><span class="line">    <span class="keyword">if</span> (ratio_less_equal&lt;P,milli&gt;::value) &#123;</span><br><span class="line">       <span class="comment">// convert to and print as milliseconds</span></span><br><span class="line">       <span class="keyword">typedef</span> <span class="keyword">typename</span> ratio_multiply&lt;P,kilo&gt;::type TT;</span><br><span class="line">       cout &lt;&lt; fixed &lt;&lt; <span class="built_in">double</span>(TT::num)/TT::den</span><br><span class="line">            &lt;&lt; <span class="string">&quot; milliseconds&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// print as seconds</span></span><br><span class="line">        cout &lt;&lt; fixed &lt;&lt; <span class="built_in">double</span>(P::num)/P::den &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;- is_steady: &quot;</span> &lt;&lt; boolalpha &lt;&lt; C::is_steady &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;system_clock: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printClockData</span>&lt;std::chrono::system_clock&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nhigh_resolution_clock: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printClockData</span>&lt;std::chrono::high_resolution_clock&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nsteady_clock: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printClockData</span>&lt;std::chrono::steady_clock&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;。</span><br></pre></td></tr></table></figure>

<h3 id="示例结果"><a href="#示例结果" class="headerlink" title="示例结果"></a>示例结果</h3><p><img src="/../img/111.png"></p>
<h1 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h1><hr>
<h2 id="什么是对象池"><a href="#什么是对象池" class="headerlink" title="什么是对象池"></a>什么是对象池</h2><p>对象池，就是一定数量的已经创建好的对象的集合。当需要创建对象时，先在池子中获取，如果池子里没有符合条件的对象，在创建新的对象。同样，当对象需要销毁时，不做真正的销毁，而是将其setActive(False)，并存入池子中。避免了大量对象的创建。</p>
<h2 id="对象池解决什么问题"><a href="#对象池解决什么问题" class="headerlink" title="对象池解决什么问题"></a>对象池解决什么问题</h2><p>少频繁创建和销毁对象带来的成本，实现对象的缓存和复用，创建对象的成本比较大，并且创建比较频繁。比如线程的创建代价比较大，于是就有了常用的线程 池。对象池（模式）是一种创建型设计模式，它持有一个初始化好的对象的集合，将对象提供给调用者。</p>
<h2 id="对象池的优点"><a href="#对象池的优点" class="headerlink" title="对象池的优点"></a>对象池的优点</h2><ol>
<li>提升了t获取对象的响应速度，比如单个线程和资源连接的创建成本都比较大。</li>
<li>运用对象池化技术可以显著地提升性能，尤其是当对象的初始化过程代价较大或者频率较高时。</li>
<li>一定程度上减少了GC的压力。对于实时性要求较高的程序有很大的帮助，比如说 http 链接的对象池，Redis对象池等等都使用了对象池</li>
</ol>
<h2 id="对象池的弊端"><a href="#对象池的弊端" class="headerlink" title="对象池的弊端"></a>对象池的弊端</h2><ol>
<li><p>脏对象的问题</p>
<p>所谓的脏对象就是指的是当对象被放回对象池后，还保留着刚刚被客户端调用时生成的数据。</p>
</li>
<li><p>生命周期的问题</p>
</li>
</ol>
<h2 id="对象池的特征"><a href="#对象池的特征" class="headerlink" title="对象池的特征"></a>对象池的特征</h2><p>一般来说，对象池有以下特征</p>
<ol>
<li>有一定数量已经建立好的对象</li>
<li>对象池向用户提供对象的接口，当用户需要新的对象时，便可通过调用此接口获取新的对象。如果对象池中有事先创建好的对象时，就直接返回给用 户；如果没有了，对象池还可以创建新的对象加入其中，然后返回给用户</li>
<li>对象池向用户提供归还对象的接口，用户不再使用某对象时，便可通过此接口把该对象归还给对象池</li>
</ol>
<h1 id="HANDLE的用法"><a href="#HANDLE的用法" class="headerlink" title="HANDLE的用法"></a>HANDLE的用法</h1><hr>
<p>Handle:是一个消息分发对象，进行发送和处理消息，并且其Runnable对象与一个线程的MessageQueue关联。</p>
<p><strong>作用</strong>：调度消息，将一个任务切换到某个指定的线程中执行。</p>
<h3 id="handle使用场景"><a href="#handle使用场景" class="headerlink" title="handle使用场景"></a>handle使用场景</h3><h4 id="子程序不许访问UI"><a href="#子程序不许访问UI" class="headerlink" title="子程序不许访问UI"></a>子程序不许访问UI</h4><p>假若子线程允许访问UI，则在多线程并发访问情况下，会使得UI控件处于不可预期的状态</p>
<p>传统解决方法：加锁，但是会使得UI访问逻辑变得复杂，其次降低UI访问效率</p>
<h4 id="引入Handler"><a href="#引入Handler" class="headerlink" title="引入Handler"></a>引入Handler</h4><p>采用单线程模型处理UI操作，通过Handler切换到UI线程，解决子线程中无法访问UI的问题。</p>
<h2 id="Handler的使用"><a href="#Handler的使用" class="headerlink" title="Handler的使用"></a>Handler的使用</h2><h4 id="post-Runnable"><a href="#post-Runnable" class="headerlink" title="post(Runnable)"></a>post(Runnable)</h4><p>创建一个工作线程，实现Runnable接口，实现run方法，处理耗时操作</p>
<p>创建一个Handler，通过Handler.post&#x2F;postDelay，投递创建的Runnable，在run方法中进行更新UI操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">          耗时操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      handler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">                更新UI</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;).start();</span><br></pre></td></tr></table></figure>

<h4 id="sendMessage-Message"><a href="#sendMessage-Message" class="headerlink" title="sendMessage(Message)"></a>sendMessage(Message)</h4><p>创建一个工作线程，继承Thread，重新run方法，处理耗时操作</p>
<p>创建一个Message对象，设置what标志及数据</p>
<p>通过sendMessage进行投递消息</p>
<p>创建一个handler，重写handMessage方法，根据msg.what信息判断，接收对应的信息，再在这里重新更新UI</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;      <span class="comment">//判断标志位</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 获取数据，更新UI</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">         耗时操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="comment">//从全局池中返回一个message实例，避免多次创建message（如new Message）</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span>Message.obtain();  </span><br><span class="line">        msg.obj = data;</span><br><span class="line">        msg.what=<span class="number">1</span>;   <span class="comment">//标志消息的标志</span></span><br><span class="line">        handler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">WorkThread</span>().start();</span><br></pre></td></tr></table></figure>

<h1 id="显式化模板实参"><a href="#显式化模板实参" class="headerlink" title="显式化模板实参"></a>显式化模板实参</h1><hr>
<blockquote>
<p>在使用一个模板时，额外提供信息，这些信息就是显式化模板实参列表，他们被绑定到模板参数。编译器使用这些实参来实例化</p>
</blockquote>
<p>例如一个Poco::SingletonHolder</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Poco::SingletonHolder&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="comment">//就是进行一个int型单例的初始化</span></span><br></pre></td></tr></table></figure>

<h1 id="std-recursive-mutex"><a href="#std-recursive-mutex" class="headerlink" title="std::recursive_mutex"></a>std::recursive_mutex</h1><hr>
<p>recursive_mutex锁与mutex锁的区别是，recursive_mutex锁允许已经获得了一个递归互斥体所有权的线程允许在同一个互斥体上再次调用lock()和try_lock()。线程调用unlock()方法的次数应该等于这个递归体获得递归互斥体锁的次数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    std::recursive_mutex m;</span><br><span class="line">    std::string shared;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">      shared = <span class="string">&quot;fun1&quot;</span>;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;in fun1, shared variable is now &quot;</span> &lt;&lt; shared &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">      shared = <span class="string">&quot;fun2&quot;</span>;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;in fun2, shared variable is now &quot;</span> &lt;&lt; shared &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="built_in">fun1</span>(); <span class="comment">// ① 递归锁在此处变得有用</span></span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;back in fun2, shared variable is &quot;</span> &lt;&lt; shared &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(&amp;X::fun1, &amp;x)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(&amp;X::fun2, &amp;x)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Poco-NumberParser"><a href="#Poco-NumberParser" class="headerlink" title="Poco::NumberParser"></a>Poco::NumberParser</h1><hr>
<blockquote>
<p>NumberParser类提供静态方法，用于从字符串中解析数字，不允许使用前导或尾随空格</p>
</blockquote>
<p>static bool tryParse(const std::string&amp; s,int &amp; value, char thousandSeparator &#x3D;’,’);</p>
<p>在s字符串内能否找到value的整数，找到返回true，找不到返回false</p>
<h1 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h1><hr>
<blockquote>
<p>C++11提供了一个原子类型std::atomic<T>,通过这个原子类型管理的内部变量就可以称为原子变量，可以提供任何变量作为模板参数。</p>
</blockquote>
<p>多线程访问时不用再使用互斥量来保护变量了。</p>
<p>atomic::store的使用方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//将会用value替换包含的值，操作是原子的，并遵循sync指定的内存顺序</span></span><br></pre></td></tr></table></figure>

<p>atomic::load的使用方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">load</span> <span class="params">(memory_order sync = memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//返回包含的值</span></span><br></pre></td></tr></table></figure>

<h1 id="string-npos"><a href="#string-npos" class="headerlink" title="string::npos"></a>string::npos</h1><hr>
<blockquote>
<p>npos是一个常数，表示size_t的最大值，许多容器提供这个位置表示不存在的最大值</p>
</blockquote>
<h3 id="npos的用法"><a href="#npos的用法" class="headerlink" title="npos的用法"></a>npos的用法</h3><ol>
<li><p>npos表示string的结束位置，是string::type_size类型的，也就是find()返回的类型。find函数在找不到指定值的情况下会返回string::npos。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string b;</span><br><span class="line">    <span class="built_in">getline</span>(cin,b);</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">127</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(b.<span class="built_in">find</span>(i)!=string::npos)</span><br><span class="line">        count++;</span><br><span class="line">    cout&lt;&lt;count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>string::npos作为string成员函数的一个长度参数时，表示直到字符串结束</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    string filename = <span class="string">&quot;test.cpp&quot;</span>;    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;filename : &quot;</span> &lt;&lt; filename &lt;&lt; endl;    </span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> idx = filename.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>);   <span class="comment">//as a return value    </span></span><br><span class="line">    <span class="keyword">if</span>(idx == string::npos)        </span><br><span class="line">    &#123;    </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;filename does not contain any period!&quot;</span> &lt;&lt; endl;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">    &#123;    </span><br><span class="line">        string tmpname = filename;    </span><br><span class="line">        tmpname.<span class="built_in">replace</span>(idx + <span class="number">1</span>, string::npos, <span class="string">&quot;xxx&quot;</span>); <span class="comment">//string::npos作为长度参数，表示直到字符串结束    </span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;repalce: &quot;</span> &lt;&lt; tmpname &lt;&lt; endl;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><hr>
<blockquote>
<p>数据库查询时的通配符</p>
</blockquote>
<p>谓词<strong>LIKE</strong>可以用来进行字符串的匹配，其一般的语法格式如下</p>
<p>[NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE’&lt;换码字符&gt;’]</p>
<p>其含义是查找指定的属性列值与&lt;匹配串&gt;相匹配的元组，可含有通配符%和_</p>
<ul>
<li>%表示任意长度(可为零)的字符串</li>
<li>_表示任意单个字符</li>
</ul>
<h3 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h3><hr>
<p>每秒传输帧数</p>
<h1 id="initializer-list详解"><a href="#initializer-list详解" class="headerlink" title="initializer_list详解"></a>initializer_list详解</h1><hr>
<p>C++11提供的新类型，定义在<initializer_list>头文件中</p>
<p>首先有了initializer_list之后，对于STL的容器初始化就方便多了，可以使STL容器拥有数组的初始化能力</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooVector</span></span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; content_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooVector</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            content_.<span class="built_in">push_back</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooMap</span></span><br><span class="line">&#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; content_;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">pair_t</span> = std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::value_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooMap</span>(std::initializer_list&lt;<span class="type">pair_t</span>&gt; list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            content_.<span class="built_in">insert</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FooVector foo_1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">FooMap foo_2 = &#123; &#123; <span class="number">1</span>, <span class="number">2</span> &#125;, &#123; <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span> &#125; &#125;;</span><br></pre></td></tr></table></figure>

<h1 id="C-的INL文件"><a href="#C-的INL文件" class="headerlink" title="C++的INL文件"></a>C++的INL文件</h1><hr>
<p>,INL文件是内连函数的源文件，内联函数一般在头文件中实现，但有时为了别的考虑，也会将文件添加到INL文件中，在头文件的末尾用#include引入。</p>
<h1 id="SIP协议的总结"><a href="#SIP协议的总结" class="headerlink" title="SIP协议的总结"></a>SIP协议的总结</h1><hr>
<h2 id="SIP概念"><a href="#SIP概念" class="headerlink" title="SIP概念"></a>SIP概念</h2><p>SIP(会话发起协议)是一个用于建立，更改和终止多媒体会话的应用层控制协议，其中的会话可以是IP电话、多媒体分发及多媒体会议。SIP协议采用Client&#x2F;Server模型，主要通过与Proxy Server之间的通信来完成用户呼叫的建立过程。</p>
<p> SIP终端通过发送“邀请”消息给会话目的终端，消息中携带了自己的描述信息。目的终端可以根据“邀请”信息和自身的能力接受或拒绝请求。SIP可以通过称为“代理服务器”的实体来转发“邀请”消息。代理服务器可以完成确定目的终端的位置、查找路由的工作，根据会话终端的要求进行认证和授权，还能提供会话终端的呼叫路由策略。SIP通过“注册服务器”记录各终端的描述信息，包括地址信息，路由信息，号码信息等，各SIP终端可以通过发送“注册”消息给注册服务器，以登记或更新其描述信息。</p>
<p> 另外，SIP作为应用层协议，在传输层上可以使用TCP，也可以使用UDP。SIP可以支持IPv4和IPv6。</p>
<h2 id="SIP的功能特点"><a href="#SIP的功能特点" class="headerlink" title="SIP的功能特点"></a>SIP的功能特点</h2><ol>
<li>确定用户位置：确定被叫SIP终端所在的位置。SIP的最强大之处就是用户定位功能。SIP本身含有向注册服务器注册的功能，也可以利用其他定位服务器如DNS、LDAP等提供的定位服务器来增强其定位功能。</li>
<li>确定用户可用性：确定被叫会话终端是否可以参加此会话。SIP支持多种地址描述和寻址，包括：用户名@主机地址、被叫号码@PSTN网关地址和普通电话号码（如Tel：01012345678）的描述等。这样，SIP主叫按照被叫地址，就可以识别出被叫是否在传统电话网上，然后通过一个与传统电话网相连的网关向被叫发起并建立呼叫。</li>
<li>确定用户能力：确定被叫终端可用于参加会话的媒体类型及媒体参数。SIP终端在消息交互过程中携带自身的媒体类型和媒体参数，这使得会话都可以明确对方的会话能力。</li>
<li>建立会话：建立主被叫双方的会话参数。SIP会话双方通过协商媒体类型和媒体参数，最终选择双方都具有的能力建立起会话。</li>
<li>管理会话：可以更改会话参数或中止会话。</li>
</ol>
<h2 id="SIP方法"><a href="#SIP方法" class="headerlink" title="SIP方法"></a>SIP方法</h2><ol>
<li>REGISTER：注册联系信息。</li>
<li>INVITE： 初始化一个会话</li>
<li>ACK： 对INVITE消息的最终响应。</li>
<li>CANCEL： 终止一个等待处理或正在处理的请求。</li>
<li>BYE： 终止一个会话。</li>
<li>OPTIONS： 查询服务器的性能。</li>
</ol>
<p>附加方法</p>
<ol>
<li>SUBSCRIBE：订阅方法</li>
<li>NOTIFY： 事件通知方法</li>
<li>MESSAGE： 即时消息方法</li>
</ol>
<h2 id="SIP访问码"><a href="#SIP访问码" class="headerlink" title="SIP访问码"></a>SIP访问码</h2><table>
<thead>
<tr>
<th>1xx</th>
<th>进展相应</th>
<th>临时相应</th>
</tr>
</thead>
<tbody><tr>
<td>2xx</td>
<td>成功</td>
<td>最终相应</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向错误</td>
<td>最终相应</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误</td>
<td>最终相应</td>
</tr>
<tr>
<td>5xx</td>
<td>服务端错误</td>
<td>最终相应</td>
</tr>
<tr>
<td>6xx</td>
<td>全局错误</td>
<td>最终相应</td>
</tr>
</tbody></table>
<h2 id="SIP的请求标题头"><a href="#SIP的请求标题头" class="headerlink" title="SIP的请求标题头"></a>SIP的请求标题头</h2><table>
<thead>
<tr>
<th>Header</th>
<th>含义说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>Call-ID</td>
<td>由本地设备(Client)生成，全局唯一，每次呼叫这个值唯一不变</td>
<td>Call-ID: <a href="mailto:&#x61;&#x73;&#x64;&#56;&#56;&#x61;&#x73;&#100;&#x37;&#x37;&#x61;&#x40;&#49;&#x2e;&#x32;&#x2e;&#x33;&#46;&#x34;">&#x61;&#x73;&#x64;&#56;&#56;&#x61;&#x73;&#100;&#x37;&#x37;&#x61;&#x40;&#49;&#x2e;&#x32;&#x2e;&#x33;&#46;&#x34;</a></td>
</tr>
<tr>
<td>From</td>
<td>表示请求的发起者</td>
<td>From: sip:<a href="mailto:&#117;&#115;&#101;&#x72;&#49;&#64;&#100;&#x6f;&#x6d;&#97;&#105;&#x6e;&#x2e;&#x63;&#x6f;&#109;">&#117;&#115;&#101;&#x72;&#49;&#64;&#100;&#x6f;&#x6d;&#97;&#105;&#x6e;&#x2e;&#x63;&#x6f;&#109;</a>;tag&#x3D;49583</td>
</tr>
<tr>
<td>To</td>
<td>表示请求的接收者</td>
<td>To: sip:<a href="mailto:&#x75;&#115;&#x65;&#x72;&#x32;&#64;&#100;&#x6f;&#x6d;&#x61;&#x69;&#110;&#46;&#99;&#x6f;&#x6d;">&#x75;&#115;&#x65;&#x72;&#x32;&#64;&#100;&#x6f;&#x6d;&#x61;&#x69;&#110;&#46;&#99;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>Via</td>
<td>Via头域是被服务器插入request中，用来检查路由环的，并且可以使response根据via找到返回的路</td>
<td>Via: SIP&#x2F;2.0&#x2F;TCP user1pc.domain.com;branch&#x3D;z9hG4bK776sgdkse</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>用于表示这个包最多可以传送多少跳，每经过一跳都会减一当Max-Forwards&#x3D;&#x3D;0系统会返回483。默认为70</td>
<td>Max-Forwards: 70</td>
</tr>
<tr>
<td>Contact</td>
<td>包含源的URI信息，用来给响应方直接和源建立连接用</td>
<td>Contact: sip:192.168.100.1:1111</td>
</tr>
<tr>
<td>Content-Type</td>
<td>指明消息体的类型 (SDP会话描述协议)</td>
<td>Content-Type: text&#x2F;plain；Content-Type: application&#x2F;sdp; Content-Type: application&#x2F;cpim;</td>
</tr>
<tr>
<td>Content-Length</td>
<td>指明消息体的字节大小</td>
<td>Content-Length: 18</td>
</tr>
</tbody></table>
<h1 id="Poco-Event"><a href="#Poco-Event" class="headerlink" title="Poco::Event"></a>Poco::Event</h1><hr>
<blockquote>
<p>Poco::Event用于多线程之间的同步，</p>
</blockquote>
<p>事件是一个同步对象，允许一个线程向一个或者多个线程发出特定事件已经发生的信号。</p>
<p>通常一个线程发出事件信号，而一个或者多个线程在等待事件信号。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Event</span>(<span class="type">bool</span> autoReset = <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>创建一个事件，如果autoReset是true时，当一个wait()成功返回时，事件会自动复位。</p>
<h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>发出事件信号，如果autoReset为true，则只有一个等待事件的线程可以恢复执行。</p>
<p>如果autoReset为false，则所有等待线程都可以恢复执行。</p>
<h3 id="等待状态"><a href="#等待状态" class="headerlink" title="等待状态"></a>等待状态</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>等待事件发出信号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(<span class="type">long</span> milliseconds)</span></span>;</span><br></pre></td></tr></table></figure>

<p>等待事件发出信号，如果未在给定事件里发出信号，则抛出一个超时异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tryWait</span><span class="params">(<span class="type">long</span> milliseconds)</span></span>;</span><br></pre></td></tr></table></figure>

<p>等待事件信号，如果事件在给定时间内发出信号返回true，否则返回false。</p>
<h3 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>将事件重置为没有收到信号前的状态。</p>
<h1 id="std-memcpy"><a href="#std-memcpy" class="headerlink" title="std::memcpy"></a>std::memcpy</h1><hr>
<p>定义于头文件<cstring>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memcpy</span><span class="params">( <span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, std::<span class="type">size_t</span> count )</span></span>;</span><br></pre></td></tr></table></figure>

<p>从src所指向的对象复制count个字符到dest所指向的对象。两个对象都将转译成unsigned char的数组。</p>
<p>若对象重叠，则行为未定义。若dest或者src为非法或空指针则行为未定义。</p>
<h1 id="ntohl-htonl-函数"><a href="#ntohl-htonl-函数" class="headerlink" title="ntohl() htonl()函数"></a>ntohl() htonl()函数</h1><hr>
<p>ntohl()将一个无符号长整型数从网络字节顺序转为主机字节顺序，ntohl()返回一个以主机顺序表达的数。</p>
<p>htonl()将主机数转换成无符号长整型的网络字节顺序。本函数将一个32位数从主机字节序转换成网络字节顺序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> uint16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>  uint32;</span><br><span class="line"><span class="comment">//短整形高低字节交换</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Swap16(A) ((((uint16)(A) &amp; 0xff00) &gt;&gt; 8) | (((uint16)(A) &amp; 0x00ff) &lt;&lt; 8))</span></span><br><span class="line"><span class="comment">//长整形高低字节交换</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Swap32(A) ((((uint32)(A) &amp; 0xff000000) &gt;&gt; 24) | \</span></span><br><span class="line"><span class="meta">				   (((uint32)(A) &amp; 0x00ff0000) &gt;&gt;  8) | \</span></span><br><span class="line"><span class="meta">				   (((uint32)(A) &amp; 0x0000ff00) &lt;&lt;  8) | \</span></span><br><span class="line"><span class="meta">				   (((uint32)(A) &amp; 0x000000ff) &lt;&lt; 24))</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">union</span> &#123;   </span><br><span class="line">    <span class="type">char</span> c[<span class="number">4</span>];   </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mylong;   </span><br><span class="line">&#125; endian_test = &#123;&#123; <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;b&#x27;</span> &#125; &#125;;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">ENDIANNESS返回结果</span></span><br><span class="line"><span class="comment">	l:小端模式</span></span><br><span class="line"><span class="comment">	b:打断模式</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENDIANNESS ((char)endian_test.mylong)  </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//将主机的无符号短整形数转换成网络字节顺序</span></span><br><span class="line"><span class="function">uint16 <span class="title">htons</span><span class="params">(uint16 hs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ENDIANNESS==<span class="string">&#x27;l&#x27;</span>) ? <span class="built_in">Swap16</span>(hs): hs;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将主机的无符号长整形数转换成网络字节顺序</span></span><br><span class="line"><span class="function">uint32 <span class="title">htonl</span><span class="params">(uint32 hl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ENDIANNESS==<span class="string">&#x27;l&#x27;</span>) ? <span class="built_in">Swap32</span>(hl): hl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将一个无符号短整形数从网络字节顺序转换为主机字节顺序</span></span><br><span class="line"><span class="function">uint16 <span class="title">ntohs</span><span class="params">(uint16 ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ENDIANNESS==<span class="string">&#x27;l&#x27;</span>) ? <span class="built_in">Swap16</span>(ns): ns;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将一个无符号长整形数从网络字节顺序转换为主机字节顺序</span></span><br><span class="line"><span class="function">uint32 <span class="title">ntohl</span><span class="params">(uint32 nl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ENDIANNESS==<span class="string">&#x27;l&#x27;</span>) ? <span class="built_in">Swap32</span>(nl): nl;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	uint16 hs=<span class="number">0x1234</span>;</span><br><span class="line">	uint32 hl=<span class="number">0x12345678</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; htons(0x%4x) = 0x%4x\n&quot;</span>,hs,<span class="built_in">htons</span>(hs));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ntons(0x%4x) = 0x%4x\n&quot;</span>,hs,<span class="built_in">ntohs</span>(hs));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; htonl(0x%8x) = 0x%8x\n&quot;</span>,hl,<span class="built_in">htonl</span>(hl));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ntohl(0x%8x) = 0x%8x\n&quot;</span>,hl,<span class="built_in">ntohl</span>(hl));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TLV编码格式详解"><a href="#TLV编码格式详解" class="headerlink" title="TLV编码格式详解"></a>TLV编码格式详解</h1><hr>
<blockquote>
<p>BER是一种编码规格说明，只有确定了通信协议，才能理解数据含义。BER的数据由三个域构成：标识域(Tag)+长度域(Length)+值域(Value)，简称TLV格式</p>
</blockquote>
<ol>
<li><p>TLV简介</p>
<p>TLV是一种可变的格式，其中：</p>
<ul>
<li>T可以理解为Tag或者Type。用于标识标签或者编码格式信息</li>
<li>L定义数值的长度</li>
<li>V表示实际的数值</li>
</ul>
<p>T和L的长度固定，V的长度由Length指定</p>
</li>
<li><p>字节序</p>
<p>要正确的解析对方发来的数据除了统一数据格式之外还要统一字节序。字节序是指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。字节序一般分为<strong>大端</strong>和<strong>小端</strong>。</p>
<p>2.1 大端和小端</p>
<p>大端模式：高位字节放在内存的低地地址，低位字节存放在内存的高位位置。</p>
<p>小端模式：低位字节放在内存的低地址端，高位字节放在内存的高地址端。</p>
<p>2.2 网络字节序</p>
<p>网络字节序是TCP&#x2F;IP中规定好的一种数据表示格式，它与具体的CPU类型，操作系统等无关，从而可以保证数据在不同主句之间传输数据时能够被正确解释，网络字节大端序</p>
<p>为了进行转换，使用四个数据</p>
<ul>
<li>htons 把unsigned short类型从主机序转换到网络序</li>
<li>htonl 把unsigned long类型从主机序转换到网络序</li>
<li>ntohs 把unsigned short类型从网络序转换到主机序</li>
<li>ntohl 把unsigned long类型从网络序转换到主机序</li>
</ul>
</li>
<li><p>解编码</p>
<p>假设Tag(或Type)和Length都是四个字节表示</p>
<p>3.1 编码步骤</p>
<ol>
<li>使用htonl将Tag（或Type）转成网络字节序，指针偏移 4；</li>
<li>使用 <strong>htonl</strong> 将 Length 转成网络字节序，指针偏移 4；</li>
<li>若值 Value 为 int、char、short、long 类型，将其转为网络字节序，指针偏移；若值为字符串，写入后指针偏移 Length；</li>
<li>重复上述三步，继续编码后面的 TLV 单元。</li>
</ol>
<p>3.2 解码步骤</p>
<ol>
<li>读取 Tag（或Type）并使用 <strong>ntohl</strong> 将其转成主机字节序，指针偏移4；</li>
<li>读取 Length ntohl** 将其转成主机字节序，指针偏移4；</li>
<li>根据得到的长度读取 Value，若为 int、char、short、long 类型，将其转为主机字节序，指针偏移；若值为字符串，读取后指针偏移 Length；</li>
<li>重复上述三步，继续读取后面的 TLV 单元。</li>
</ol>
</li>
</ol>
<hr>
<h1 id="日志的几个等级"><a href="#日志的几个等级" class="headerlink" title="日志的几个等级"></a>日志的几个等级</h1><hr>
<ol>
<li>ALL：打开所有的日志</li>
<li>TRACE：级别很低的日志，一般不会用</li>
<li>DEBUG：开发过程中的运行信息</li>
<li>INFO：打印感兴趣的信息</li>
<li>WARN：潜在错误</li>
<li>ERROR：虽然发生错误信息，仍不影响系统的继续运行</li>
<li>FATAL：指出每个严重的错误事件将会导致应用程序的退出</li>
<li>OFF：最高等级的，关闭所有日志</li>
</ol>
<h1 id="atomic-store"><a href="#atomic-store" class="headerlink" title="atomic_store"></a>atomic_store</h1><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">atomic_store</span> <span class="params">(<span class="keyword">volatile</span> atomic&lt;T&gt;* obj, T val)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">atomic_store</span> <span class="params">(atomic&lt;T&gt;* obj, T val)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>修改包含的值，将obj中包含的值替换为val。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">大大怪下士</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/posts/37176/">http://example.com/posts/37176/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">明月清风居</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></div><div class="post_share"><div class="social-share" data-image="/./img/28.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/54626/" title="HTML"><img class="cover" src="/./img/6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HTML</div></div></a></div><div class="next-post pull-right"><a href="/posts/31628/" title="9.7"><img class="cover" src="/./img/27.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">9.7</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/30988/" title="9.1"><img class="cover" src="/./img/22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-04</div><div class="title">9.1</div></div></a></div><div><a href="/posts/31628/" title="9.7"><img class="cover" src="/./img/27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-14</div><div class="title">9.7</div></div></a></div><div><a href="/posts/25246/" title="Git"><img class="cover" src="/./img/21.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-29</div><div class="title">Git</div></div></a></div><div><a href="/posts/47629/" title="9.5"><img class="cover" src="/./img/25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-05</div><div class="title">9.5</div></div></a></div><div><a href="/posts/18835/" title="Java开发规范"><img class="cover" src="/./img/26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-14</div><div class="title">Java开发规范</div></div></a></div><div><a href="/posts/60186/" title="正则表达式使用"><img class="cover" src="/./img/15.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-22</div><div class="title">正则表达式使用</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">大大怪下士</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dadaguaixiashi"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/dadaguaixiashi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/626675831@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">行天之道，总司一切</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#kbps"><span class="toc-number">1.</span> <span class="toc-text">kbps</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ptime"><span class="toc-number">2.</span> <span class="toc-text">ptime</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90json%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">解析json文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9Fjson%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">观察json格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#json%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B"><span class="toc-number">3.2.</span> <span class="toc-text">json文件简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#json%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">3.2.1.</span> <span class="toc-text">json文件的语法规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#json%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">json值的类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#json%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">json文件解析流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">String的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#substr-%E6%88%AA%E5%8F%96string"><span class="toc-number">4.1.</span> <span class="toc-text">substr:截取string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stringstream%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">stringstream的用法:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#thread"><span class="toc-number">5.</span> <span class="toc-text">thread</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#notify-one-%E4%B8%8Enotify-all-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">notify_one()与notify_all()的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pragma-once"><span class="toc-number">7.</span> <span class="toc-text">#pragma once</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ICE-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">8.</span> <span class="toc-text">ICE (面对对象中间件)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ICE%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">8.1.</span> <span class="toc-text">ICE实现过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-str-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">9.</span> <span class="toc-text">c_str()方法解析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">10.</span> <span class="toc-text">C++实现线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">10.1.</span> <span class="toc-text">线程池的介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9F%A5%E8%AF%86%E8%83%8C%E6%99%AF"><span class="toc-number">10.2.</span> <span class="toc-text">线程池知识背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">10.3.</span> <span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">10.3.1.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">10.3.2.</span> <span class="toc-text">线程池的组成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">10.4.</span> <span class="toc-text">线程池工作的四种情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.5.</span> <span class="toc-text">线程池的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">10.5.1.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E5%87%BD%E6%95%B0"><span class="toc-number">10.5.2.</span> <span class="toc-text">提交函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AE%9E%E4%BE%8B"><span class="toc-number">10.6.</span> <span class="toc-text">线程池的实现实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E8%A7%A3%E5%92%8C%E7%A1%AC%E8%A7%A3"><span class="toc-number">11.</span> <span class="toc-text">软解和硬解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E8%A7%A3"><span class="toc-number">11.1.</span> <span class="toc-text">软解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E8%A7%A3"><span class="toc-number">11.2.</span> <span class="toc-text">硬解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E7%A1%AC%E8%A7%A3%E7%9A%84%E4%BC%98%E5%8A%A3%E5%8C%BA%E5%88%AB"><span class="toc-number">11.3.</span> <span class="toc-text">软硬解的优劣区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-chrono-%E5%BA%93%E4%B8%AD%E7%9A%84-steady-clock-%E5%92%8C-system-clock"><span class="toc-number">11.4.</span> <span class="toc-text">C++ chrono 库中的 steady_clock 和 system_clock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.5.</span> <span class="toc-text">代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E7%BB%93%E6%9E%9C"><span class="toc-number">11.5.1.</span> <span class="toc-text">示例结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-number">12.</span> <span class="toc-text">对象池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-number">12.1.</span> <span class="toc-text">什么是对象池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">12.2.</span> <span class="toc-text">对象池解决什么问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">12.3.</span> <span class="toc-text">对象池的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">12.4.</span> <span class="toc-text">对象池的弊端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">12.5.</span> <span class="toc-text">对象池的特征</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HANDLE%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">HANDLE的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#handle%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">13.0.1.</span> <span class="toc-text">handle使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E4%B8%8D%E8%AE%B8%E8%AE%BF%E9%97%AEUI"><span class="toc-number">13.0.1.1.</span> <span class="toc-text">子程序不许访问UI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5Handler"><span class="toc-number">13.0.1.2.</span> <span class="toc-text">引入Handler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">13.1.</span> <span class="toc-text">Handler的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#post-Runnable"><span class="toc-number">13.1.0.1.</span> <span class="toc-text">post(Runnable)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sendMessage-Message"><span class="toc-number">13.1.0.2.</span> <span class="toc-text">sendMessage(Message)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%8C%96%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82"><span class="toc-number">14.</span> <span class="toc-text">显式化模板实参</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#std-recursive-mutex"><span class="toc-number">15.</span> <span class="toc-text">std::recursive_mutex</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Poco-NumberParser"><span class="toc-number">16.</span> <span class="toc-text">Poco::NumberParser</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F"><span class="toc-number">17.</span> <span class="toc-text">原子变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#string-npos"><span class="toc-number">18.</span> <span class="toc-text">string::npos</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#npos%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">18.0.1.</span> <span class="toc-text">npos的用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">19.</span> <span class="toc-text">通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FPS"><span class="toc-number">19.0.1.</span> <span class="toc-text">FPS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#initializer-list%E8%AF%A6%E8%A7%A3"><span class="toc-number">20.</span> <span class="toc-text">initializer_list详解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84INL%E6%96%87%E4%BB%B6"><span class="toc-number">21.</span> <span class="toc-text">C++的INL文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SIP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">22.</span> <span class="toc-text">SIP协议的总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SIP%E6%A6%82%E5%BF%B5"><span class="toc-number">22.1.</span> <span class="toc-text">SIP概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SIP%E7%9A%84%E5%8A%9F%E8%83%BD%E7%89%B9%E7%82%B9"><span class="toc-number">22.2.</span> <span class="toc-text">SIP的功能特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SIP%E6%96%B9%E6%B3%95"><span class="toc-number">22.3.</span> <span class="toc-text">SIP方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SIP%E8%AE%BF%E9%97%AE%E7%A0%81"><span class="toc-number">22.4.</span> <span class="toc-text">SIP访问码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SIP%E7%9A%84%E8%AF%B7%E6%B1%82%E6%A0%87%E9%A2%98%E5%A4%B4"><span class="toc-number">22.5.</span> <span class="toc-text">SIP的请求标题头</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Poco-Event"><span class="toc-number">23.</span> <span class="toc-text">Poco::Event</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">23.0.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">23.0.2.</span> <span class="toc-text">发送信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81"><span class="toc-number">23.0.3.</span> <span class="toc-text">等待状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE"><span class="toc-number">23.0.4.</span> <span class="toc-text">重置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#std-memcpy"><span class="toc-number">24.</span> <span class="toc-text">std::memcpy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ntohl-htonl-%E5%87%BD%E6%95%B0"><span class="toc-number">25.</span> <span class="toc-text">ntohl() htonl()函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TLV%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="toc-number">26.</span> <span class="toc-text">TLV编码格式详解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AD%89%E7%BA%A7"><span class="toc-number">27.</span> <span class="toc-text">日志的几个等级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#atomic-store"><span class="toc-number">28.</span> <span class="toc-text">atomic_store</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/ee1/" title="计算机组成与结构"><img src="/./img/29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机组成与结构"/></a><div class="content"><a class="title" href="/posts/ee1/" title="计算机组成与结构">计算机组成与结构</a><time datetime="2023-08-24T13:18:25.000Z" title="发表于 2023-08-24 21:18:25">2023-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/54626/" title="HTML"><img src="/./img/6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTML"/></a><div class="content"><a class="title" href="/posts/54626/" title="HTML">HTML</a><time datetime="2022-09-21T13:07:15.000Z" title="发表于 2022-09-21 21:07:15">2022-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/37176/" title="8月知识点"><img src="/./img/28.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="8月知识点"/></a><div class="content"><a class="title" href="/posts/37176/" title="8月知识点">8月知识点</a><time datetime="2022-09-17T11:38:50.000Z" title="发表于 2022-09-17 19:38:50">2022-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/31628/" title="9.7"><img src="/./img/27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="9.7"/></a><div class="content"><a class="title" href="/posts/31628/" title="9.7">9.7</a><time datetime="2022-09-14T14:49:22.000Z" title="发表于 2022-09-14 22:49:22">2022-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/18835/" title="Java开发规范"><img src="/./img/26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java开发规范"/></a><div class="content"><a class="title" href="/posts/18835/" title="Java开发规范">Java开发规范</a><time datetime="2022-09-14T14:36:31.000Z" title="发表于 2022-09-14 22:36:31">2022-09-14</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 大大怪下士</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async src="/js/diytitle.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" href="categories/琐碎知识/">琐碎知识</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr">每天进步一点点</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover2.webp);"> <a class="categoryBar-list-link" href="categories/系统架构设计师/">系统架构设计师</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">复习基础</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><div id="ghbdages" style="overflow:hidden;max-height:90px;height:auto;text-align:center;margin-top:10px"><div class="swiper-wrapper"><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v5.4.0"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v3.8.2"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本站项目由Github托管"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></div></div></div><style>a.github-badge:hover:before {display:none}</style>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/ee1/" alt=""><img width="48" height="48" src="./img/29.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-24</span><a class="blog-slider__title" href="posts/ee1/" alt="">计算机组成与结构</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="posts/ee1/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/40917/" alt=""><img width="48" height="48" src="./img/8.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-21</span><a class="blog-slider__title" href="posts/40917/" alt="">ffmpag解码基础</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="posts/40917/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>