<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>8月知识点 | 明月清风居</title><meta name="keywords" content="基础知识"><meta name="author" content="大大怪下士"><meta name="copyright" content="大大怪下士"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="8月知识点"><meta name="application-name" content="8月知识点"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="8月知识点"><meta property="og:url" content="http://example.com/posts/37176/index.html"><meta property="og:site_name" content="明月清风居"><meta property="og:description" content="kbps  比特率单位(千比特每秒),又称千比特率,指的是数字信号的传输速率，也就是每秒钟传输多少个千位的信息(k表示千，kb表示的是多少千个位),也可以表示网络的传输速度.   VBR（Variable Bitrate）动态比特率 也就是没有固定的比特率，压缩软件在压缩时根据视频数据即时确定使用什"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/img/28.jpg"><meta property="article:author" content="大大怪下士"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/28.jpg"><meta name="description" content="kbps  比特率单位(千比特每秒),又称千比特率,指的是数字信号的传输速率，也就是每秒钟传输多少个千位的信息(k表示千，kb表示的是多少千个位),也可以表示网络的传输速度.   VBR（Variable Bitrate）动态比特率 也就是没有固定的比特率，压缩软件在压缩时根据视频数据即时确定使用什"><link rel="shortcut icon" href="/img/avatar.png"><link rel="canonical" href="http://example.com/posts/37176/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 大大怪下士","link":"链接: ","source":"来源: 明月清风居","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '明月清风居',
  title: '8月知识点',
  postAI: '',
  pageFillDescription: 'kbps, ptime, 解析json文件, 观察json格式, json文件简介, json文件的语法规则, json值的类型, json文件解析流程, String的使用, substr截取string, stringstream的用法, thread, notify_one()与notify_all()的区别, pragma once, ICE (面对对象中间件), ICE实现过程, c_str()方法解析, C++实现线程池, 线程池的介绍, 线程池知识背景, 基础概念, 线程池, 线程池的组成, 线程池工作的四种情况, 线程池的实现, 队列, 提交函数, 线程池的实现实例, 软解和硬解, 软解, 硬解, 软硬解的优劣区别, C++ chrono 库中的 steady_clock 和 system_clock, 代码示例, 示例结果, 对象池, 什么是对象池, 对象池解决什么问题, 对象池的优点, 对象池的弊端, 对象池的特征, HANDLE的用法, handle使用场景, 子程序不许访问UI, 引入Handler, Handler的使用, post(Runnable), sendMessage(Message), 显式化模板实参, stdrecursive_mutex, PocoNumberParser, 原子变量, stringnpos, npos的用法, 通配符, FPS, initializer_list详解, C++的INL文件, SIP协议的总结, SIP概念, SIP的功能特点, SIP方法, SIP访问码, SIP的请求标题头, PocoEvent, 构造函数, 发送信号, 等待状态, 重置, stdmemcpy, ntohl() htonl()函数, TLV编码格式详解, 日志的几个等级, atomic_store比特率单位千比特每秒又称千比特率指的是数字信号的传输速率也就是每秒钟传输多少个千位的信息表示千表示的是多少千个位也可以表示网络的传输速度动态比特率也就是没有固定的比特率压缩软件在压缩时根据视频数据即时确定使用什么比特率这是以质量为前提兼顾文件大小的方式也是推荐的编码模式平均比特率是的一种插值参数在指定的文件大小内以固定的帧数为一段可以做为和的一种折衷选择常数比特率指文件从头到尾都是一种位速率相对于和来讲它压缩出来的文件体积很大而且画质相对于和不会有明显的提高官方给出的定义为就是一个数据包中媒体的时长通信两侧协定的尽量一致这个是根据协议进行读取的解析文件观察格式荔枝新闻不止是阅读江苏广电旗下资讯类手机应用荔枝新闻于近期推出全新升级换代的版文件简介若有很多参数需要频繁更改可以将这种类型的参数文件放在一个文本里面然后设计一个函数接口来读取这些参数并存储在结构体或者其他类型的容器内文件的语法规则每一条数据通过的形式储存如数据之间通过逗号分隔如花括号用于保存对象如一个数组中可以包含多个对象一个对象中也可以包含多个数组值的类型数字整型或浮点型字符串双引号逻辑值布尔型对象在花括号中数组在中括号中文件解析流程创建对象读取根节点获取子节点信息对于规则子节点信息进行遍历的使用截取从开始的位置截取个字符从开始的位置一直到最后的用法是提供的串流物件需要处理字符串时往往是输入的一行中包含多个字符以及空格这个时候就可以利用进行单个字符或者单个字符串分析处理了的作用就是从对象读取字符或字符串是中提供多线程编程的模块使用的时候需要包含头文件函数是一个布尔类型的函数他会返回一个布尔值来表示当前的线程是否是可执行线程是将指定的线程加入当前线程指定线程结束时才会继续执行当前线程是将线程从当前线程分离出去即不会受阻塞基于已经存在的它基本上是一个包装器它为线程带来了两个新功能默认情况下它们可以协同中断并加入与的区别因为只唤醒等待队列中的第一个线程不存在锁争用所以能够立即获得锁其余的线程不会被唤醒需要等待再次调用或者会唤醒所有等待队列中阻塞的线程存在锁争用只有一个线程能够获得锁其余线程会继续尝试获得锁类似于轮询而不会再次阻塞在中在使用预编译指令的时候为了防止重复引用造成二义性通常有两种方式指令防止代码块重复引用指令在想要保护的文件开头写入一般由编译器提供保证同一个文件不会被包含多次这里所说的同一个文件是指物理上的一个文件而不是指内容相同的两个文件无法对一个头文件中的一段代码作声明而只能针对文件面对对象中间件对象是本地或远地的地址空间中能响应客户请求的实体一个对象可在一个或多个服务器中实例化每个对象都有一个或多个接口一个接口是一个对象所支持的一系列有名称的操作客户通过调用操作来发出请求一个操作有零个或更多参数以及一个返回值每个对象都有一个唯一的对象标识对象标识是用于把一个对象与其他所有对象区别开来的标识值对象模型假定对象标识是全局唯一的也就是说在一个通信域中不会有两个对象具有相同的对象标识对象标识既可以通过调用全局唯一产生也可以根据自己的喜好随意创建一个只要没与其他对象标识重复即可代理要想与某个对象联系客户必须持有这个对象的代理对客户而言代理就是对象的本地代表该对象可能在远地代理所封装的信息有寻址信息用于让客户端联系正确的服务器对象标识用于确定服务器中的哪一个对象是请求的目标可选的标识符用于确定代理所引用的是对象的哪一个对象是一种具有类型标识以及寻址信息在本地或远地的地址空间中能响应客户请求的实体的概念性实体而是服务器端用具体的编程语言实现的实体并且在服务器的地址空间中进行实例化为客户发送的操作调用提供服务器端行为动态映射表动态映射表简称之所以称为动态映射表是因为它可以动态维护的数量可以添加也可以删除它是一个查找表用于把对象标识映射到要激活一个就将它添加进动态映射表这个过程可以看作是在对象的标识与对应的用编程语言编写的负责为该对象处理请求的之间创建链接这个链接创建好之后一旦客户端的请求到来时就可以将该请求分派给正确的来执行动态映射表的几种操作行为如下操作把一个具有指定标识的增加到中一旦被调用请求就会分派给这个返回值是这个所体现的对象的代理你不能用同一标识多次调用如果你试图在中增加一个已经存在的标识就会引发操作的行为和操作一样但你不需要为提供标识会生成一个作为对应的对象的标识操作中断对象标识与其之间的关联从中移除对应的条目一旦解除了激活新到来的针对已移除的对象标识的请求会引发实现过程服务器端创建类并在服务器端上注册实例化类创建具体的为这个所体现的对象创建标识激活即将添加进动态映射表客户端当客户端要调用某一操作时客户端会将对象标识以及请求一起发给服务器服务器端的对象适配器接收到了请求和对象标识对象适配器继而根据这个对象标识在它所维护管理的中查找其相对应的正确的若找到了与对象标识对应的正确的就把调用分派给它若查找不到就会引发最后客户端接收到来自服务器端的返回值或异常信息方法解析指向一个字符串数组的指针实现线程池线程池的介绍作为五大池之一内存池连接池线程池进程池携程池线程池的应用十分广泛不管是客户端程序还是后台服务端都是提高业务处理能力的必备模块线程池知识背景面向对象的标准组合和继承多态容器智能指针函数对象绑定器可变参数等多线程编程等基础概念线程池当进行并行的任务作业操作时线程的建立与销毁的开销是阻碍性能进步的关键因此线程池由此产生使用多个线程无限制循环等待队列进行计算和操作帮助快速降低和减少性能损耗线程池的组成线程池管理器初始化和创建线程启动和停止线程调配任务管理线程池工作线程线程池中等待并执行分配的任务任务接口添加任务的接口以提供工作线程调度任务的执行任务队列用于存放没有处理的任务提供一种缓冲机制同时具有调度功能高优先级的任务放在队列前面线程池工作的四种情况没有任务要执行缓冲队列为空队列中任务数量小于等于线程池中线程任务数量任务数量大于线程池数量缓冲队列未满任务数量大于线程池数量缓冲队列已满线程池的实现任务队列线程池完成队列队列我们使用队列来存储工作因为它是更合理的数据结构我们希望以与发送它相同的顺序启动工作但是这个队列有点特殊正如我在上一节中所说的线程是连续的好吧不是真的但我们假设它们是查询队列要求工作当有可用的工作时线程从队列中获取工作并执行它如果两个线程试图同时执行相同的工作会发生什么好吧程序会崩溃为了避免这种问题我在标准上实现了一个包装器它使用来限制并发访问让我们看一下类的一小部分示例提交函数线程池最重要的方法是负责向队列添加工作的方法我打电话给这个方法提交不难理解它是如何工作的但它的实现起初可能看起来很吓人让我们考虑应该做什么之后我们会担心如何做到这一点什么接受任何参数的任何函数立即返回东西以避免阻塞主线程此返回的对象最终应包含操作的结果完整的提交函数如下所示线程池的实现实例内置线程工作类工作所属线程池构造函数重载操作定义基础函数类是否正在取出队列中元素判断线程池是否关闭没有关闭循环提取为线程环境锁加锁互访问工作线程的休眠和唤醒如果任务队列为空阻塞当前线程等待条件变量通知开启线程取出任务队列中的元素如果成功取出执行工作函数线程池是否关闭执行函数安全队列即任务队列工作线程队列线程休眠锁互斥变量线程环境锁让线程可以处于休眠或者唤醒状态线程池构造函数拷贝构造函数并且取消默认父类构造函数拷贝构造函数允许右值引用赋值操作赋值操作分配工作线程通知唤醒所有工作线程判断线程是否正在等待将线程加入等待队列线程的主要工作函数使用了后置返回类型自动判断函数返回值连接函数和参数定义特殊函数类型避免左右值错误封装获取任务对象方便另外一个线程查看结果利用正则表达式返回一个函数对象队列通用安全封包函数并压入安全队列唤醒一个等待中的线程返回先前注册的任务指针软解和硬解软解利用软件本身解码但是实际上还是使用进行解码在软件解码过程中需要对于大量的视频信息进行运算对于的性能要求非常高对于高清大大码率的视频来说巨大的运算量就会造成转换效率低发热量高等问题软解码不需要过多的硬件支持兼容性非常高即使出现新的视频编码格式只要安装好相应的解码器文件就可以顺利播放而且软解码拥有丰富的滤镜字幕画面处理优化等效果只有你够强悍就能够实现更加出色的画面效果硬解字面上的意思就是硬件解码通过设备上的显卡的视频加速功能对高清视频进行解码硬解调用的专门模块编码来解码减少运算显卡核心拥有独特的计算方法解码效率非常高这样不但能够减轻的负担还有着低功耗发热少等特点但是由于硬解码起步比较晚软件和驱动对他的支持度很低基本上硬解码内置什么样的模块就解码什么样的视频面对网上各色各样的视频编码样式往往会出现兼容性不好的问题此外硬解码的滤镜字幕画质方面都做的不够理想软硬解的优劣区别硬解码高清视频的优势不需要太好的单核足矣方面节约不少资金硬解码基本相当于免费附送不到元的整合主板都能完美支持硬解码让占用率超低系统有能力在看的同时进行多任务操作需要倾尽全力才能解码而只需动用亿晶体管的解码模块就能完成任务功耗控制更好硬解码高清视频的劣势起步较晚软件支持度无法与软解相提并论面对杂乱无章的视频编码封装格式硬解码无法做到全面兼容软解拥有大量画面输出补偿及画质增强技术而硬解这方面做得还远远不够硬解码软件设置较为复杂很多朋友根本不知道该如何正确使用硬件解码库中的和中的标准库中有三种时钟是单调的时钟只会增长适用于程序耗时是系统的时钟因为系统的时钟可以修改甚至可以网络对时所以用系统时间计算时间差可能不准是当前系统能够提供的最高精度的时钟它也是不可以修改的相当于的高精度版本代码示例示例结果对象池什么是对象池对象池就是一定数量的已经创建好的对象的集合当需要创建对象时先在池子中获取如果池子里没有符合条件的对象在创建新的对象同样当对象需要销毁时不做真正的销毁而是将其并存入池子中避免了大量对象的创建对象池解决什么问题少频繁创建和销毁对象带来的成本实现对象的缓存和复用创建对象的成本比较大并且创建比较频繁比如线程的创建代价比较大于是就有了常用的线程池对象池模式是一种创建型设计模式它持有一个初始化好的对象的集合将对象提供给调用者对象池的优点提升了获取对象的响应速度比如单个线程和资源连接的创建成本都比较大运用对象池化技术可以显著地提升性能尤其是当对象的初始化过程代价较大或者频率较高时一定程度上减少了的压力对于实时性要求较高的程序有很大的帮助比如说链接的对象池对象池等等都使用了对象池对象池的弊端脏对象的问题所谓的脏对象就是指的是当对象被放回对象池后还保留着刚刚被客户端调用时生成的数据生命周期的问题对象池的特征一般来说对象池有以下特征有一定数量已经建立好的对象对象池向用户提供对象的接口当用户需要新的对象时便可通过调用此接口获取新的对象如果对象池中有事先创建好的对象时就直接返回给用户如果没有了对象池还可以创建新的对象加入其中然后返回给用户对象池向用户提供归还对象的接口用户不再使用某对象时便可通过此接口把该对象归还给对象池的用法是一个消息分发对象进行发送和处理消息并且其对象与一个线程的关联作用调度消息将一个任务切换到某个指定的线程中执行使用场景子程序不许访问假若子线程允许访问则在多线程并发访问情况下会使得控件处于不可预期的状态传统解决方法加锁但是会使得访问逻辑变得复杂其次降低访问效率引入采用单线程模型处理操作通过切换到线程解决子线程中无法访问的问题的使用创建一个工作线程实现接口实现方法处理耗时操作创建一个通过投递创建的在方法中进行更新操作耗时操作更新创建一个工作线程继承重新方法处理耗时操作创建一个对象设置标志及数据通过进行投递消息创建一个重写方法根据信息判断接收对应的信息再在这里重新更新判断标志位获取数据更新耗时操作从全局池中返回一个实例避免多次创建如标志消息的标志显式化模板实参在使用一个模板时额外提供信息这些信息就是显式化模板实参列表他们被绑定到模板参数编译器使用这些实参来实例化例如一个就是进行一个型单例的初始化锁与锁的区别是锁允许已经获得了一个递归互斥体所有权的线程允许在同一个互斥体上再次调用和线程调用方法的次数应该等于这个递归体获得递归互斥体锁的次数递归锁在此处变得有用类提供静态方法用于从字符串中解析数字不允许使用前导或尾随空格在字符串内能否找到的整数找到返回找不到返回原子变量提供了一个原子类型通过这个原子类型管理的内部变量就可以称为原子变量可以提供任何变量作为模板参数多线程访问时不用再使用互斥量来保护变量了的使用方法将会用替换包含的值操作是原子的并遵循指定的内存顺序的使用方法返回包含的值是一个常数表示的最大值许多容器提供这个位置表示不存在的最大值的用法表示的结束位置是类型的也就是返回的类型函数在找不到指定值的情况下会返回作为成员函数的一个长度参数时表示直到字符串结束作为长度参数表示直到字符串结束通配符数据库查询时的通配符谓词可以用来进行字符串的匹配其一般的语法格式如下匹配串换码字符其含义是查找指定的属性列值与匹配串相匹配的元组可含有通配符和表示任意长度可为零的字符串表示任意单个字符每秒传输帧数详解提供的新类型定义在头文件中首先有了之后对于的容器初始化就方便多了可以使容器拥有数组的初始化能力的文件文件是内连函数的源文件内联函数一般在头文件中实现但有时为了别的考虑也会将文件添加到文件中在头文件的末尾用引入协议的总结概念会话发起协议是一个用于建立更改和终止多媒体会话的应用层控制协议其中的会话可以是电话多媒体分发及多媒体会议协议采用模型主要通过与之间的通信来完成用户呼叫的建立过程终端通过发送邀请消息给会话目的终端消息中携带了自己的描述信息目的终端可以根据邀请信息和自身的能力接受或拒绝请求可以通过称为代理服务器的实体来转发邀请消息代理服务器可以完成确定目的终端的位置查找路由的工作根据会话终端的要求进行认证和授权还能提供会话终端的呼叫路由策略通过注册服务器记录各终端的描述信息包括地址信息路由信息号码信息等各终端可以通过发送注册消息给注册服务器以登记或更新其描述信息另外作为应用层协议在传输层上可以使用也可以使用可以支持和的功能特点确定用户位置确定被叫终端所在的位置的最强大之处就是用户定位功能本身含有向注册服务器注册的功能也可以利用其他定位服务器如等提供的定位服务器来增强其定位功能确定用户可用性确定被叫会话终端是否可以参加此会话支持多种地址描述和寻址包括用户名主机地址被叫号码网关地址和普通电话号码如的描述等这样主叫按照被叫地址就可以识别出被叫是否在传统电话网上然后通过一个与传统电话网相连的网关向被叫发起并建立呼叫确定用户能力确定被叫终端可用于参加会话的媒体类型及媒体参数终端在消息交互过程中携带自身的媒体类型和媒体参数这使得会话都可以明确对方的会话能力建立会话建立主被叫双方的会话参数会话双方通过协商媒体类型和媒体参数最终选择双方都具有的能力建立起会话管理会话可以更改会话参数或中止会话方法注册联系信息初始化一个会话对消息的最终响应终止一个等待处理或正在处理的请求终止一个会话查询服务器的性能附加方法订阅方法事件通知方法即时消息方法访问码进展相应临时相应成功最终相应重定向错误最终相应客户端错误最终相应服务端错误最终相应全局错误最终相应的请求标题头含义说明举例由本地设备生成全局唯一每次呼叫这个值唯一不变表示请求的发起者表示请求的接收者头域是被服务器插入中用来检查路由环的并且可以使根据找到返回的路用于表示这个包最多可以传送多少跳每经过一跳都会减一当系统会返回默认为包含源的信息用来给响应方直接和源建立连接用指明消息体的类型会话描述协议指明消息体的字节大小用于多线程之间的同步事件是一个同步对象允许一个线程向一个或者多个线程发出特定事件已经发生的信号通常一个线程发出事件信号而一个或者多个线程在等待事件信号构造函数创建一个事件如果是时当一个成功返回时事件会自动复位发送信号发出事件信号如果为则只有一个等待事件的线程可以恢复执行如果为则所有等待线程都可以恢复执行等待状态等待事件发出信号等待事件发出信号如果未在给定事件里发出信号则抛出一个超时异常等待事件信号如果事件在给定时间内发出信号返回否则返回重置将事件重置为没有收到信号前的状态定义于头文件中从所指向的对象复制个字符到所指向的对象两个对象都将转译成的数组若对象重叠则行为未定义若或者为非法或空指针则行为未定义函数将一个无符号长整型数从网络字节顺序转为主机字节顺序返回一个以主机顺序表达的数将主机数转换成无符号长整型的网络字节顺序本函数将一个位数从主机字节序转换成网络字节顺序短整形高低字节交换长整形高低字节交换返回结果小端模式打断模式将主机的无符号短整形数转换成网络字节顺序将主机的无符号长整形数转换成网络字节顺序将一个无符号短整形数从网络字节顺序转换为主机字节顺序将一个无符号长整形数从网络字节顺序转换为主机字节顺序编码格式详解是一种编码规格说明只有确定了通信协议才能理解数据含义的数据由三个域构成标识域长度域值域简称格式简介是一种可变的格式其中可以理解为或者用于标识标签或者编码格式信息定义数值的长度表示实际的数值和的长度固定的长度由指定字节序要正确的解析对方发来的数据除了统一数据格式之外还要统一字节序字节序是指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序字节序一般分为大端和小端大端和小端大端模式高位字节放在内存的低地地址低位字节存放在内存的高位位置小端模式低位字节放在内存的低地址端高位字节放在内存的高地址端网络字节序网络字节序是中规定好的一种数据表示格式它与具体的类型操作系统等无关从而可以保证数据在不同主句之间传输数据时能够被正确解释网络字节大端序为了进行转换使用四个数据把类型从主机序转换到网络序把类型从主机序转换到网络序把类型从网络序转换到主机序把类型从网络序转换到主机序解编码假设或和都是四个字节表示编码步骤使用将或转成网络字节序指针偏移使用将转成网络字节序指针偏移若值为类型将其转为网络字节序指针偏移若值为字符串写入后指针偏移重复上述三步继续编码后面的单元解码步骤读取或并使用将其转成主机字节序指针偏移读取将其转成主机字节序指针偏移根据得到的长度读取若为类型将其转为主机字节序指针偏移若值为字符串读取后指针偏移重复上述三步继续读取后面的单元日志的几个等级打开所有的日志级别很低的日志一般不会用开发过程中的运行信息打印感兴趣的信息潜在错误虽然发生错误信息仍不影响系统的继续运行指出每个严重的错误事件将会导致应用程序的退出最高等级的关闭所有日志修改包含的值将中包含的值替换为',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-24 20:57:49',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="明月清风居" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">明月清风居</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>5</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.05rem;">前端<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">基础知识<sup>11</sup></a><a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 1.05rem;">密码学<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>7</sup></a><a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/" style="font-size: 1.05rem;">音视频<sup>9</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/09/"><span class="card-archive-list-date">九月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/08/"><span class="card-archive-list-date">八月 2022</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">18</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86/" itemprop="url">琐碎知识</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>基础知识</span></a></span></div></div><h1 class="post-title" itemprop="name headline">8月知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2022-09-17T11:38:50.000Z" title="发表于 2022-09-17 19:38:50">2022-09-17</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-08-24T12:57:49.503Z" title="更新于 2023-08-24 20:57:49">2023-08-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为哈尔滨"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>哈尔滨</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/./img/28.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/posts/37176/"><header><a class="post-meta-categories" href="/categories/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86/" itemprop="url">琐碎知识</a><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" tabindex="-1" itemprop="url">基础知识</a><h1 id="CrawlerTitle" itemprop="name headline">8月知识点</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">大大怪下士</span><time itemprop="dateCreated datePublished" datetime="2022-09-17T11:38:50.000Z" title="发表于 2022-09-17 19:38:50">2022-09-17</time><time itemprop="dateCreated datePublished" datetime="2023-08-24T12:57:49.503Z" title="更新于 2023-08-24 20:57:49">2023-08-24</time></header><h1 id="kbps"><a href="#kbps" class="headerlink" title="kbps"></a>kbps</h1><hr>
<blockquote>
<p>比特率单位(千比特每秒),又称千比特率,指的是数字信号的传输速率，也就是每秒钟传输多少个千位的信息(k表示千，kb表示的是多少千个位),也可以表示网络的传输速度.</p>
</blockquote>
<ol>
<li>VBR（Variable Bitrate）动态比特率 也就是没有固定的比特率，压缩软件在压缩时根据视频数据即时确定使用什么比特率，这是以质量为前提兼顾文件大小的方式，也是推荐的编码模式；</li>
<li>ABR（Average Bitrate）平均比特率 是VBR的一种插值参数。ABR在指定的文件大小内，以固定的帧数为一段，可以做为VBR和CBR的一种折衷选择。</li>
<li>CBR（Constant Bitrate），常数比特率 指文件从头到尾都是一种位速率。相对于VBR和ABR来讲，它压缩出来的文件体积很大，而且画质相对于VBR和ABR不会有明显的提高。</li>
</ol>
<h1 id="ptime"><a href="#ptime" class="headerlink" title="ptime"></a>ptime</h1><hr>
<blockquote>
<p>官方给出的ptime定义为:ptime gives the length of time in milliseconds represented by themedia in a packet .就是一个数据包中媒体的时长，通信两侧协定的ptime尽量一致。  </p>
</blockquote>
<p>这个是根据<strong>协议</strong>进行读取的。</p>
<h1 id="解析json文件"><a href="#解析json文件" class="headerlink" title="解析json文件"></a>解析json文件</h1><hr>
<h2 id="观察json格式"><a href="#观察json格式" class="headerlink" title="观察json格式"></a>观察json格式</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;paramz&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;feeds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">299076</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;oid&quot;</span><span class="punctuation">:</span> <span class="number">288340</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;article&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;subject&quot;</span><span class="punctuation">:</span> <span class="string">&quot;荔枝新闻3.0：不止是阅读&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;summary&quot;</span><span class="punctuation">:</span> <span class="string">&quot;江苏广电旗下资讯类手机应用“荔枝新闻”于近期推出全新升级换代的3.0版。&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cover&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/Attachs/Article/288340/3e8e2c397c70469f8845fad73aa38165_padmini.JPG&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;pic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;txt&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;changed&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2015-09-22 16:01:41&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;PageIndex&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;PageSize&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;TotalCount&quot;</span><span class="punctuation">:</span> <span class="number">53521</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;TotalPage&quot;</span><span class="punctuation">:</span> <span class="number">2677</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="json文件简介"><a href="#json文件简介" class="headerlink" title="json文件简介"></a>json文件简介</h2><p>若有很多参数需要频繁更改，可以将这种类型的参数文件放在一个文本里面，然后设计一个函数接口来读取这些参数并存储在结构体或者其他类型的容器内  </p>
<h3 id="json文件的语法规则"><a href="#json文件的语法规则" class="headerlink" title="json文件的语法规则"></a>json文件的语法规则</h3><ol>
<li>每一条数据通过key:value的形式储存，如”name”:”lsx”</li>
<li>数据之间通过逗号分隔，如”name”:”lsx”,”age”:16</li>
<li>花括号用于保存对象，如”info”:{“name”:”lsx”,”age”:16}</li>
<li>一个数组中可以包含多个对象，一个对象中也可以包含多个数组</li>
</ol>
<h3 id="json值的类型"><a href="#json值的类型" class="headerlink" title="json值的类型"></a>json值的类型</h3><ol>
<li>数字(整型或浮点型)</li>
<li>字符串(双引号)“”</li>
<li>逻辑值(布尔型)</li>
<li>对象(在花括号中){}</li>
<li>数组(在中括号中)</li>
</ol>
<h2 id="json文件解析流程"><a href="#json文件解析流程" class="headerlink" title="json文件解析流程"></a>json文件解析流程</h2><ol>
<li>创建对象</li>
<li>读取根节点</li>
<li>获取子节点信息</li>
<li>对于规则子节点信息进行遍历</li>
</ol>
<h1 id="String的使用"><a href="#String的使用" class="headerlink" title="String的使用"></a>String的使用</h1><hr>
<h2 id="substr-截取string"><a href="#substr-截取string" class="headerlink" title="substr:截取string"></a>substr:截取string</h2><p>substr(str,pos,len):从pos开始的位置，截取len个字符<br>SUBSTR(str,pos):从pos开始的位置，一直到最后  </p>
<h2 id="stringstream的用法"><a href="#stringstream的用法" class="headerlink" title="stringstream的用法:"></a>stringstream的用法:</h2><p>stringstream是C++提供的串流（stream）物件 ，需要处理字符串时，往往是输入的一行中包含多个字符以及空格，这个时候就可以利用 stringstream进行单个字符或者单个字符串分析处理了  </p>
<p>stringstream的作用就是从string对象读取字符或字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>(ss&gt;&gt;ch)&#123;</span><br><span class="line">    cout&lt;&lt;ch&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h1><hr>
<blockquote>
<p>thread是C++11中提供多线程编程的模块，使用的时候需要包含<thread>头文件。</p>
</blockquote>
<p>joinable()函数是一个布尔类型的函数，他会返回一个布尔值来表示当前的线程是否是可执行线程. </p>
<p>join是将指定的线程加入当前线程，指定线程结束时才会继续执行当前线程。</p>
<p>detach是将线程从当前线程分离出去，即不会受阻塞。</p>
<p>std::jthread基于已经存在的std::thread。它基本上是一个包装器，它为线程带来了两个新功能：默认情况下，它们可以协同中断并加入。   </p>
<h1 id="notify-one-与notify-all-的区别"><a href="#notify-one-与notify-all-的区别" class="headerlink" title="notify_one()与notify_all()的区别"></a>notify_one()与notify_all()的区别</h1><hr>
<p>notify_one()：因为只唤醒等待队列中的第一个线程；不存在锁争用，所以能够立即获得锁。其余的线程不会被唤醒，需要等待再次调用notify_one()或者notify_all()。</p>
<p>notify_all()：会唤醒所有等待队列中阻塞的线程，存在锁争用，只有一个线程能够获得锁。其余线程会继续尝试获得锁(类似于轮询)，而不会再次阻塞。  </p>
<h1 id="pragma-once"><a href="#pragma-once" class="headerlink" title="#pragma once"></a>#pragma once</h1><hr>
<p>在C&#x2F;C++中，在使用预编译指令#include的时候，为了防止重复引用造成二义性，通常有两种方式  </p>
<ul>
<li>#ifndef指令防止代码块重复引用  </li>
<li>#pragma once指令，在想要保护的文件开头写入</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure>

<p>#pragma once一般由编译器提供保证：<strong>同一个文件</strong>不会被包含多次。这里所说的”同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。无法对一个头文件中的一段代码作#pragma once声明，而只能针对文件.</p>
<h1 id="ICE-面对对象中间件"><a href="#ICE-面对对象中间件" class="headerlink" title="ICE (面对对象中间件)"></a>ICE (面对对象中间件)</h1><hr>
<p>Ice 对象是本地或远地的地址空间中、能响应客户请求的实体。一个Ice对象可在一个或多个服务器中实例化。每个Ice对象都有一个或多个接口。一个接口是一个对象所支持的一系列有名称的操作，客户通过调用操作来发出请求。一个操作有零个或更多参数，以及一个返回值。每个Ice 对象都有一个唯一的对象标识。对象标识是用于把一个对象与其他所有对象区别开来的标识值。 Ice 对象模型假定对象标识是全局唯一的，也就是说，在一个Ice 通信域中，不会有两个对象具有相同的对象标识。对象标识既可以通过调用GenerateUUID（）全局唯一产生，也可以根据自己的喜好随意创建一个，只要没与其他对象标识重复即可。</p>
<ul>
<li>代理<br>要想与某个Ice对象联系，客户必须持有这个对象的代理。对客户而言，代理就是Ice对象的本地代表（该对象可能在远地）。代理所封装的信息有：寻址信息：用于让客户端run time 联系正确的服务器对象标识：用于确定服务器中的哪一个对象是请求的目标可选的facet 标识符：用于确定代理所引用的是对象的哪一个facet。</li>
<li>Servants<br>Ice 对象是一种具有类型、标识，以及寻址信息，在本地或远地的地址空间中、能响应客户请求的实体的概念性实体。而Servants是服务器端用具体的编程语言实现的实体，并且在服务器的地址空间中进行实例化。 Servants 为“客户发送的操作调用”提供服务器端行为。  </li>
<li>动态映射表<br>动态映射表（ Active servant map），简称ASM。之所以称为动态映射表，是因为它可以动态维护servant的数量，可以添加，也可以删除。它是一个查找表，用于把对象标识映射到servant；要激活一个servant，就将它添加进动态映射表。这个过程可以看作是在“Ice 对象的标识”与“对应的用编程语言编写的、负责为该ICE对象处理请求的servant”之间创建链接。这个链接创建好之后，一旦客户端的请求到来时， Ice run time 就可以将该请求分派给正确的servant来执行。动态servant映射表的几种操作行为如下：  </li>
<li>add<br>add 操作把一个具有指定标识的servant 增加到ASM中。一旦add 被调用，请求就会分派给这个servant。返回值是这个servant 所体现的Ice对象的代理。你不能用同一标识多次调用add：如果你试图在ASM 中增加一个已经存在的标识，就会引发AlreadyRegisteredException  </li>
<li>addWithUUID<br>addWithUUID 操作的行为和add 操作一样，但你不需要为servant 提供标识。addWithUUID 会生成一个UUID，作为对应的Ice 对象的标识。</li>
<li>remove<br>remove 操作中断对象标识与其servant 之间的关联，从ASM 中移除对应的条目。一旦servant 解除了激活，新到来的针对已移除的对象标识的请求会引发ObjectNotExistException</li>
</ul>
<h2 id="ICE实现过程"><a href="#ICE实现过程" class="headerlink" title="ICE实现过程"></a>ICE实现过程</h2><ul>
<li>服务器端</li>
</ul>
<ol>
<li>创建 servant 类，并在服务器端 Ice run time 上注册。  </li>
<li>实例化 servant 类，创建具体的 servant。  </li>
<li>为这个 servant 所体现的 Ice 对象创建标识。  </li>
<li>激活 servant（即将 servant 添加进动态 servant 映射表）</li>
</ol>
<ul>
<li>客户端</li>
</ul>
<ol>
<li>当客户端要调用某一操作时， 客户端 run time 会将对象标识以及请求一起发给服务器。  </li>
<li>服务器端的对象适配器接收到了请求和对象标识， 对象适配器继而根据这个对象标识，在它所维护管理的active servant map中查找其相对应的正确的servant。  </li>
<li>若找到了与对象标识对应的正确的servant，就把调用分派给它。若查找不到，就会引发Object Not Exist Exception。最后客户端接收到来自服务器端的返回值或异常信息。</li>
</ol>
<h1 id="c-str-方法解析"><a href="#c-str-方法解析" class="headerlink" title="c_str()方法解析"></a>c_str()方法解析</h1><hr>
<p>指向一个字符串数组的指针</p>
<h1 id="C-实现线程池"><a href="#C-实现线程池" class="headerlink" title="C++实现线程池"></a>C++实现线程池</h1><hr>
<h2 id="线程池的介绍"><a href="#线程池的介绍" class="headerlink" title="线程池的介绍"></a>线程池的介绍</h2><blockquote>
<p>作为五大池之一(内存池，连接池，线程池，进程池，携程池)，线程池的应用十分广泛，不管是客户端程序还是后台服务端，都是提高业务处理能力的必备模块。</p>
</blockquote>
<h2 id="线程池知识背景"><a href="#线程池知识背景" class="headerlink" title="线程池知识背景"></a>线程池知识背景</h2><ul>
<li>C++面向对象的标准：组合和继承，多态，STL容器，智能指针，函数对象，绑定器，可变参数等    </li>
<li>C++11多线程编程：thread、mutex、atomic、condition_variable、unique_lock等</li>
</ul>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>当进行并行的任务作业操作时，线程的建立与销毁的开销是，阻碍性能进步的关键，因此线程池，由此产生。使用多个线程，无限制循环等待队列，进行计算和操作。帮助快速降低和减少性能损耗。</p>
<h3 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h3><ol>
<li>线程池管理器:初始化和创建线程，启动和停止线程，调配任务，管理线程池。</li>
<li>工作线程:线程池中等待并执行分配的任务</li>
<li>任务接口:添加任务的接口，以提供工作线程调度任务的执行。</li>
<li>任务队列:用于存放没有处理的任务，提供一种缓冲机制，同时具有调度功能，高优先级的任务放在队列前面。</li>
</ol>
<h2 id="线程池工作的四种情况"><a href="#线程池工作的四种情况" class="headerlink" title="线程池工作的四种情况"></a>线程池工作的四种情况</h2><p>1.<strong>没有任务要执行，缓冲队列为空</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../img/3805f625e05f8e2d1d0b69910323d7a9.png"></p>
<ol start="2">
<li><p><strong>队列中任务数量，小于等于线程池中线程任务数量</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../img/b72937b576e8e3e4a0b14ff5a9b3a1b9.png"></p>
</li>
</ol>
<p>3.<strong>任务数量大于线程池数量,缓冲队列未满</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../img/3bc05a0abf3eff2c7e25427e1c2636bb.png"></p>
<p>4.<strong>任务数量大于线程池数量，缓冲队列已满</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../img/4a50fc4f32e13a1761c2e687a58a83a4.png"></p>
<h2 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h2><ul>
<li>任务队列</li>
<li>线程池</li>
<li>完成队列</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>我们使用队列来存储工作，因为它是更合理的数据结构。 我们希望以与发送它相同的顺序启动工作。 但是，这个队列有点特殊。正如我在上一节中所说的，线程是连续的（好吧，不是真的，但我们假设它们是）查询队列要求工作。当有可用的工作时，线程从队列中获取工作并执行它。如果两个线程试图同时执行相同的工作会发生什么？ 好吧，程序会崩溃。<br>为了避免这种问题，我在标准C ++ Queue上实现了一个包装器，它使用mutex来限制并发访问。 让我们看一下SafeQueue类的一小部分示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_queue.<span class="built_in">push</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提交函数"><a href="#提交函数" class="headerlink" title="提交函数"></a>提交函数</h3><p>线程池最重要的方法是负责向队列添加工作的方法。我打电话给这个方法提交。不难理解它是如何工作的，但它的实现起初可能看起来很吓人。让我们考虑应该做什么，之后我们会担心如何做到这一点。 什么：</p>
<ul>
<li>接受任何参数的任何函数。</li>
<li>立即返回“东西”以避免阻塞主线程。 此返回的对象最终应包含操作的结果。<br>完整的提交函数如下所示：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Submit a function to be executed asynchronously by the pool template&lt;typename F, typename...Args&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Create a function with bounded parameters ready to execute</span></span><br><span class="line">    std::function&lt;<span class="keyword">decltype</span>(f(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="comment">// Encapsulate it into a shared ptr in order to be able to copy construct / assign </span></span><br><span class="line">    <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt;&gt;(func);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wrap packaged task into void function</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; wrapper_func = [task_ptr]() &#123;</span><br><span class="line">      (*task_ptr)(); </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue generic wrapper function</span></span><br><span class="line">    m_queue.<span class="built_in">enqueue</span>(wrapperfunc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake up one thread if its waiting</span></span><br><span class="line">    m_conditional_lock.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return future from promise</span></span><br><span class="line">    <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="线程池的实现实例"><a href="#线程池的实现实例" class="headerlink" title="线程池的实现实例"></a>线程池的实现实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadPool.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SafeQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ThreadWorker</span> &#123;<span class="comment">//内置线程工作类</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_id; <span class="comment">//工作id</span></span><br><span class="line"></span><br><span class="line">    ThreadPool * m_pool;<span class="comment">//所属线程池</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadWorker</span>(ThreadPool * pool, <span class="type">const</span> <span class="type">int</span> id) </span><br><span class="line">      : <span class="built_in">m_pool</span>(pool), <span class="built_in">m_id</span>(id) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载`()`操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      std::function&lt;<span class="type">void</span>()&gt; func; <span class="comment">//定义基础函数类func</span></span><br><span class="line">      </span><br><span class="line">      <span class="type">bool</span> dequeued; <span class="comment">//是否正在取出队列中元素</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//判断线程池是否关闭，没有关闭，循环提取</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (!m_pool-&gt;m_shutdown) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//为线程环境锁加锁，互访问工作线程的休眠和唤醒</span></span><br><span class="line"></span><br><span class="line">          <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_pool-&gt;m_conditional_mutex)</span></span>;</span><br><span class="line">          <span class="comment">//如果任务队列为空，阻塞当前线程</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (m_pool-&gt;m_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            m_pool-&gt;m_conditional_lock.<span class="built_in">wait</span>(lock); <span class="comment">//等待条件变量通知，开启线程</span></span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//取出任务队列中的元素</span></span><br><span class="line"></span><br><span class="line">          dequeued = m_pool-&gt;m_queue.<span class="built_in">dequeue</span>(func);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果成功取出，执行工作函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dequeued) &#123;</span><br><span class="line">          <span class="built_in">func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> m_shutdown; <span class="comment">//线程池是否关闭</span></span><br><span class="line"></span><br><span class="line">  SafeQueue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; m_queue;<span class="comment">//执行函数安全队列，即任务队列</span></span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::thread&gt; m_threads; <span class="comment">//工作线程队列</span></span><br><span class="line"></span><br><span class="line">  std::mutex m_conditional_mutex;<span class="comment">//线程休眠锁互斥变量</span></span><br><span class="line"></span><br><span class="line">  std::condition_variable m_conditional_lock; <span class="comment">//线程环境锁，让线程可以处于休眠或者唤醒状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//线程池构造函数</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">ThreadPool</span>(<span class="type">const</span> <span class="type">int</span> n_threads)</span><br><span class="line">    : <span class="built_in">m_threads</span>(std::<span class="built_in">vector</span>&lt;std::thread&gt;(n_threads)), <span class="built_in">m_shutdown</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>; <span class="comment">//拷贝构造函数，并且取消默认父类构造函数</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">ThreadPool</span>(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>; <span class="comment">// 拷贝构造函数，允许右值引用</span></span><br><span class="line"></span><br><span class="line">  ThreadPool &amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>; <span class="comment">// 赋值操作</span></span><br><span class="line"></span><br><span class="line">  ThreadPool &amp; <span class="keyword">operator</span>=(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Inits thread pool</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      m_threads[i] = std::<span class="built_in">thread</span>(<span class="built_in">ThreadWorker</span>(<span class="keyword">this</span>, i));<span class="comment">//分配工作线程</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Waits until threads finish their current task and shutdowns the pool</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_shutdown = <span class="literal">true</span>;</span><br><span class="line">    m_conditional_lock.<span class="built_in">notify_all</span>(); <span class="comment">//通知 唤醒所有工作线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span>(m_threads[i].<span class="built_in">joinable</span>()) &#123; <span class="comment">//判断线程是否正在等待</span></span><br><span class="line"></span><br><span class="line">        m_threads[i].<span class="built_in">join</span>();  <span class="comment">//将线程加入等待队列</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Submit a function to be executed asynchronously by the pool</span></span><br><span class="line">  <span class="comment">//线程的主要工作函数，使用了后置返回类型，自动判断函数返回值</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Create a function with bounded parameters ready to execute</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="keyword">decltype</span>(f(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);<span class="comment">//连接函数和参数定义，特殊函数类型,避免左、右值错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encapsulate it into a shared ptr in order to be able to copy construct // assign </span></span><br><span class="line">    <span class="comment">//封装获取任务对象，方便另外一个线程查看结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt;&gt;(func);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wrap packaged task into void function</span></span><br><span class="line">    <span class="comment">//利用正则表达式，返回一个函数对象</span></span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; wrapper_func = [task_ptr]() &#123;</span><br><span class="line">      (*task_ptr)(); </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列通用安全封包函数，并压入安全队列</span></span><br><span class="line"></span><br><span class="line">    m_queue.<span class="built_in">enqueue</span>(wrapper_func);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒一个等待中的线程</span></span><br><span class="line"></span><br><span class="line">    m_conditional_lock.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回先前注册的任务指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="软解和硬解"><a href="#软解和硬解" class="headerlink" title="软解和硬解"></a>软解和硬解</h1><hr>
<h2 id="软解"><a href="#软解" class="headerlink" title="软解"></a>软解</h2><blockquote>
<p>利用软件本身解码，但是实际上还是使用CPU进行解码</p>
</blockquote>
<p>在软件解码过程中，需要对于大量的视频信息进行运算，对于CPU的性能要求非常高。对于高清大大码率的视频来说，巨大的运算量就会造成转换效率低，发热量高等问题。</p>
<p>软解码不需要过多的硬件支持，兼容性非常高，即使出现新的视频编码格式，只要安装好相应的解码器文件，就可以顺利播放。而且软解码拥有丰富的滤镜，字幕，画面处理优化等效果，只有你CPU够强悍，就能够实现更加出色的画面效果。</p>
<h2 id="硬解"><a href="#硬解" class="headerlink" title="硬解"></a>硬解</h2><blockquote>
<p>字面上的意思就是硬件解码。通过设备上的显卡GPU的视频加速功能对高清视频进行解码。</p>
</blockquote>
<p>硬解调用GPU的专门模块编码来解码，减少CPU运算。显卡核心GPU拥有独特的计算方法，解码效率非常高，这样不但能够减轻CPU的负担，还有着低功耗，发热少等特点。</p>
<p>但是，由于硬解码起步比较晚，软件和驱动对他的支持度很低，基本上硬解码内置什么样的模块，就解码什么样的视频，面对网上各色各样的视频编码样式，往往会出现兼容性不好的问题。此外，硬解码的滤镜、字幕、画质方面都做的不够理想。</p>
<h2 id="软硬解的优劣区别"><a href="#软硬解的优劣区别" class="headerlink" title="软硬解的优劣区别"></a>软硬解的优劣区别</h2><hr>
<ul>
<li>GPU硬解码高清视频的优势<ol>
<li>不需要太好的CPU，单核足矣，CPU方面节约不少资金；</li>
<li>硬解码基本相当于免费附送，不到500元的整合主板都能完美支持；</li>
<li>硬解码让CPU占用率超低，系统有能力在看HDTV的同时进行多任务操作；</li>
<li>CPU需要倾尽全力才能解码HDTV，而GPU只需动用0.1亿晶体管的解码模块就能完成任务，功耗控制更好；</li>
</ol>
</li>
<li>GPU硬解码高清视频的劣势<ol>
<li>起步较晚，软件支持度无法与软解相提并论；</li>
<li>面对杂乱无章的视频编码、封装格式，硬解码无法做到全面兼容；</li>
<li>软解拥有大量画面输出补偿及画质增强技术，而硬解这方面做得还远远不够；</li>
<li>硬解码软件设置较为复杂，很多朋友根本不知道该如何正确使用GPU硬件解码。</li>
</ol>
</li>
</ul>
<h2 id="C-chrono-库中的-steady-clock-和-system-clock"><a href="#C-chrono-库中的-steady-clock-和-system-clock" class="headerlink" title="C++ chrono 库中的 steady_clock 和 system_clock"></a>C++ chrono 库中的 steady_clock 和 system_clock</h2><p>C++11中的标准库<chrono>中有三种时钟:steady_clock,system_clock,high_resolution_clock</p>
<ol>
<li>steady_clock是**单调的时钟,**只会增长，适用于程序耗时</li>
<li>system_clock 是<strong>系统的时钟</strong>；因为系统的时钟可以修改；甚至可以网络对时； 所以用系统时间计算时间差可能不准。</li>
<li>high_resolution_clock 是<strong>当前系统能够提供的最高精度的时钟</strong>；它也是<strong>不可以修改的</strong>。相当于 steady_clock 的高精度版本。</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copied from http://www.informit.com/articles/article.aspx?p=1881386&amp;seqNum=2;</span></span><br><span class="line"><span class="comment">// Author: Nicolai M. Josuttis</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printClockData</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;- precision: &quot;</span>;</span><br><span class="line">    <span class="comment">// if time unit is less or equal one millisecond</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> C::period P;<span class="comment">// type of time unit</span></span><br><span class="line">    <span class="keyword">if</span> (ratio_less_equal&lt;P,milli&gt;::value) &#123;</span><br><span class="line">       <span class="comment">// convert to and print as milliseconds</span></span><br><span class="line">       <span class="keyword">typedef</span> <span class="keyword">typename</span> ratio_multiply&lt;P,kilo&gt;::type TT;</span><br><span class="line">       cout &lt;&lt; fixed &lt;&lt; <span class="built_in">double</span>(TT::num)/TT::den</span><br><span class="line">            &lt;&lt; <span class="string">&quot; milliseconds&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// print as seconds</span></span><br><span class="line">        cout &lt;&lt; fixed &lt;&lt; <span class="built_in">double</span>(P::num)/P::den &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;- is_steady: &quot;</span> &lt;&lt; boolalpha &lt;&lt; C::is_steady &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;system_clock: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printClockData</span>&lt;std::chrono::system_clock&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nhigh_resolution_clock: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printClockData</span>&lt;std::chrono::high_resolution_clock&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nsteady_clock: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printClockData</span>&lt;std::chrono::steady_clock&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;。</span><br></pre></td></tr></table></figure>

<h3 id="示例结果"><a href="#示例结果" class="headerlink" title="示例结果"></a>示例结果</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../img/111.png"></p>
<h1 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h1><hr>
<h2 id="什么是对象池"><a href="#什么是对象池" class="headerlink" title="什么是对象池"></a>什么是对象池</h2><p>对象池，就是一定数量的已经创建好的对象的集合。当需要创建对象时，先在池子中获取，如果池子里没有符合条件的对象，在创建新的对象。同样，当对象需要销毁时，不做真正的销毁，而是将其setActive(False)，并存入池子中。避免了大量对象的创建。</p>
<h2 id="对象池解决什么问题"><a href="#对象池解决什么问题" class="headerlink" title="对象池解决什么问题"></a>对象池解决什么问题</h2><p>少频繁创建和销毁对象带来的成本，实现对象的缓存和复用，创建对象的成本比较大，并且创建比较频繁。比如线程的创建代价比较大，于是就有了常用的线程 池。对象池（模式）是一种创建型设计模式，它持有一个初始化好的对象的集合，将对象提供给调用者。</p>
<h2 id="对象池的优点"><a href="#对象池的优点" class="headerlink" title="对象池的优点"></a>对象池的优点</h2><ol>
<li>提升了t获取对象的响应速度，比如单个线程和资源连接的创建成本都比较大。</li>
<li>运用对象池化技术可以显著地提升性能，尤其是当对象的初始化过程代价较大或者频率较高时。</li>
<li>一定程度上减少了GC的压力。对于实时性要求较高的程序有很大的帮助，比如说 http 链接的对象池，Redis对象池等等都使用了对象池</li>
</ol>
<h2 id="对象池的弊端"><a href="#对象池的弊端" class="headerlink" title="对象池的弊端"></a>对象池的弊端</h2><ol>
<li><p>脏对象的问题</p>
<p>所谓的脏对象就是指的是当对象被放回对象池后，还保留着刚刚被客户端调用时生成的数据。</p>
</li>
<li><p>生命周期的问题</p>
</li>
</ol>
<h2 id="对象池的特征"><a href="#对象池的特征" class="headerlink" title="对象池的特征"></a>对象池的特征</h2><p>一般来说，对象池有以下特征</p>
<ol>
<li>有一定数量已经建立好的对象</li>
<li>对象池向用户提供对象的接口，当用户需要新的对象时，便可通过调用此接口获取新的对象。如果对象池中有事先创建好的对象时，就直接返回给用 户；如果没有了，对象池还可以创建新的对象加入其中，然后返回给用户</li>
<li>对象池向用户提供归还对象的接口，用户不再使用某对象时，便可通过此接口把该对象归还给对象池</li>
</ol>
<h1 id="HANDLE的用法"><a href="#HANDLE的用法" class="headerlink" title="HANDLE的用法"></a>HANDLE的用法</h1><hr>
<p>Handle:是一个消息分发对象，进行发送和处理消息，并且其Runnable对象与一个线程的MessageQueue关联。</p>
<p><strong>作用</strong>：调度消息，将一个任务切换到某个指定的线程中执行。</p>
<h3 id="handle使用场景"><a href="#handle使用场景" class="headerlink" title="handle使用场景"></a>handle使用场景</h3><h4 id="子程序不许访问UI"><a href="#子程序不许访问UI" class="headerlink" title="子程序不许访问UI"></a>子程序不许访问UI</h4><p>假若子线程允许访问UI，则在多线程并发访问情况下，会使得UI控件处于不可预期的状态</p>
<p>传统解决方法：加锁，但是会使得UI访问逻辑变得复杂，其次降低UI访问效率</p>
<h4 id="引入Handler"><a href="#引入Handler" class="headerlink" title="引入Handler"></a>引入Handler</h4><p>采用单线程模型处理UI操作，通过Handler切换到UI线程，解决子线程中无法访问UI的问题。</p>
<h2 id="Handler的使用"><a href="#Handler的使用" class="headerlink" title="Handler的使用"></a>Handler的使用</h2><h4 id="post-Runnable"><a href="#post-Runnable" class="headerlink" title="post(Runnable)"></a>post(Runnable)</h4><p>创建一个工作线程，实现Runnable接口，实现run方法，处理耗时操作</p>
<p>创建一个Handler，通过Handler.post&#x2F;postDelay，投递创建的Runnable，在run方法中进行更新UI操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">          耗时操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      handler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">                更新UI</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;).start();</span><br></pre></td></tr></table></figure>

<h4 id="sendMessage-Message"><a href="#sendMessage-Message" class="headerlink" title="sendMessage(Message)"></a>sendMessage(Message)</h4><p>创建一个工作线程，继承Thread，重新run方法，处理耗时操作</p>
<p>创建一个Message对象，设置what标志及数据</p>
<p>通过sendMessage进行投递消息</p>
<p>创建一个handler，重写handMessage方法，根据msg.what信息判断，接收对应的信息，再在这里重新更新UI</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;      <span class="comment">//判断标志位</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 获取数据，更新UI</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">         耗时操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="comment">//从全局池中返回一个message实例，避免多次创建message（如new Message）</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span>Message.obtain();  </span><br><span class="line">        msg.obj = data;</span><br><span class="line">        msg.what=<span class="number">1</span>;   <span class="comment">//标志消息的标志</span></span><br><span class="line">        handler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">WorkThread</span>().start();</span><br></pre></td></tr></table></figure>

<h1 id="显式化模板实参"><a href="#显式化模板实参" class="headerlink" title="显式化模板实参"></a>显式化模板实参</h1><hr>
<blockquote>
<p>在使用一个模板时，额外提供信息，这些信息就是显式化模板实参列表，他们被绑定到模板参数。编译器使用这些实参来实例化</p>
</blockquote>
<p>例如一个Poco::SingletonHolder</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Poco::SingletonHolder&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="comment">//就是进行一个int型单例的初始化</span></span><br></pre></td></tr></table></figure>

<h1 id="std-recursive-mutex"><a href="#std-recursive-mutex" class="headerlink" title="std::recursive_mutex"></a>std::recursive_mutex</h1><hr>
<p>recursive_mutex锁与mutex锁的区别是，recursive_mutex锁允许已经获得了一个递归互斥体所有权的线程允许在同一个互斥体上再次调用lock()和try_lock()。线程调用unlock()方法的次数应该等于这个递归体获得递归互斥体锁的次数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    std::recursive_mutex m;</span><br><span class="line">    std::string shared;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">      shared = <span class="string">&quot;fun1&quot;</span>;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;in fun1, shared variable is now &quot;</span> &lt;&lt; shared &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">      shared = <span class="string">&quot;fun2&quot;</span>;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;in fun2, shared variable is now &quot;</span> &lt;&lt; shared &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="built_in">fun1</span>(); <span class="comment">// ① 递归锁在此处变得有用</span></span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;back in fun2, shared variable is &quot;</span> &lt;&lt; shared &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(&amp;X::fun1, &amp;x)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(&amp;X::fun2, &amp;x)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Poco-NumberParser"><a href="#Poco-NumberParser" class="headerlink" title="Poco::NumberParser"></a>Poco::NumberParser</h1><hr>
<blockquote>
<p>NumberParser类提供静态方法，用于从字符串中解析数字，不允许使用前导或尾随空格</p>
</blockquote>
<p>static bool tryParse(const std::string&amp; s,int &amp; value, char thousandSeparator &#x3D;’,’);</p>
<p>在s字符串内能否找到value的整数，找到返回true，找不到返回false</p>
<h1 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h1><hr>
<blockquote>
<p>C++11提供了一个原子类型std::atomic<T>,通过这个原子类型管理的内部变量就可以称为原子变量，可以提供任何变量作为模板参数。</p>
</blockquote>
<p>多线程访问时不用再使用互斥量来保护变量了。</p>
<p>atomic::store的使用方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//将会用value替换包含的值，操作是原子的，并遵循sync指定的内存顺序</span></span><br></pre></td></tr></table></figure>

<p>atomic::load的使用方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">load</span> <span class="params">(memory_order sync = memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//返回包含的值</span></span><br></pre></td></tr></table></figure>

<h1 id="string-npos"><a href="#string-npos" class="headerlink" title="string::npos"></a>string::npos</h1><hr>
<blockquote>
<p>npos是一个常数，表示size_t的最大值，许多容器提供这个位置表示不存在的最大值</p>
</blockquote>
<h3 id="npos的用法"><a href="#npos的用法" class="headerlink" title="npos的用法"></a>npos的用法</h3><ol>
<li><p>npos表示string的结束位置，是string::type_size类型的，也就是find()返回的类型。find函数在找不到指定值的情况下会返回string::npos。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string b;</span><br><span class="line">    <span class="built_in">getline</span>(cin,b);</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">127</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(b.<span class="built_in">find</span>(i)!=string::npos)</span><br><span class="line">        count++;</span><br><span class="line">    cout&lt;&lt;count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>string::npos作为string成员函数的一个长度参数时，表示直到字符串结束</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    string filename = <span class="string">&quot;test.cpp&quot;</span>;    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;filename : &quot;</span> &lt;&lt; filename &lt;&lt; endl;    </span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> idx = filename.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>);   <span class="comment">//as a return value    </span></span><br><span class="line">    <span class="keyword">if</span>(idx == string::npos)        </span><br><span class="line">    &#123;    </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;filename does not contain any period!&quot;</span> &lt;&lt; endl;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">    &#123;    </span><br><span class="line">        string tmpname = filename;    </span><br><span class="line">        tmpname.<span class="built_in">replace</span>(idx + <span class="number">1</span>, string::npos, <span class="string">&quot;xxx&quot;</span>); <span class="comment">//string::npos作为长度参数，表示直到字符串结束    </span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;repalce: &quot;</span> &lt;&lt; tmpname &lt;&lt; endl;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><hr>
<blockquote>
<p>数据库查询时的通配符</p>
</blockquote>
<p>谓词<strong>LIKE</strong>可以用来进行字符串的匹配，其一般的语法格式如下</p>
<p>[NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE’&lt;换码字符&gt;’]</p>
<p>其含义是查找指定的属性列值与&lt;匹配串&gt;相匹配的元组，可含有通配符%和_</p>
<ul>
<li>%表示任意长度(可为零)的字符串</li>
<li>_表示任意单个字符</li>
</ul>
<h3 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h3><hr>
<p>每秒传输帧数</p>
<h1 id="initializer-list详解"><a href="#initializer-list详解" class="headerlink" title="initializer_list详解"></a>initializer_list详解</h1><hr>
<p>C++11提供的新类型，定义在<initializer_list>头文件中</p>
<p>首先有了initializer_list之后，对于STL的容器初始化就方便多了，可以使STL容器拥有数组的初始化能力</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooVector</span></span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; content_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooVector</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            content_.<span class="built_in">push_back</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooMap</span></span><br><span class="line">&#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; content_;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">pair_t</span> = std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::value_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooMap</span>(std::initializer_list&lt;<span class="type">pair_t</span>&gt; list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            content_.<span class="built_in">insert</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FooVector foo_1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">FooMap foo_2 = &#123; &#123; <span class="number">1</span>, <span class="number">2</span> &#125;, &#123; <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span> &#125; &#125;;</span><br></pre></td></tr></table></figure>

<h1 id="C-的INL文件"><a href="#C-的INL文件" class="headerlink" title="C++的INL文件"></a>C++的INL文件</h1><hr>
<p>,INL文件是内连函数的源文件，内联函数一般在头文件中实现，但有时为了别的考虑，也会将文件添加到INL文件中，在头文件的末尾用#include引入。</p>
<h1 id="SIP协议的总结"><a href="#SIP协议的总结" class="headerlink" title="SIP协议的总结"></a>SIP协议的总结</h1><hr>
<h2 id="SIP概念"><a href="#SIP概念" class="headerlink" title="SIP概念"></a>SIP概念</h2><p>SIP(会话发起协议)是一个用于建立，更改和终止多媒体会话的应用层控制协议，其中的会话可以是IP电话、多媒体分发及多媒体会议。SIP协议采用Client&#x2F;Server模型，主要通过与Proxy Server之间的通信来完成用户呼叫的建立过程。</p>
<p> SIP终端通过发送“邀请”消息给会话目的终端，消息中携带了自己的描述信息。目的终端可以根据“邀请”信息和自身的能力接受或拒绝请求。SIP可以通过称为“代理服务器”的实体来转发“邀请”消息。代理服务器可以完成确定目的终端的位置、查找路由的工作，根据会话终端的要求进行认证和授权，还能提供会话终端的呼叫路由策略。SIP通过“注册服务器”记录各终端的描述信息，包括地址信息，路由信息，号码信息等，各SIP终端可以通过发送“注册”消息给注册服务器，以登记或更新其描述信息。</p>
<p> 另外，SIP作为应用层协议，在传输层上可以使用TCP，也可以使用UDP。SIP可以支持IPv4和IPv6。</p>
<h2 id="SIP的功能特点"><a href="#SIP的功能特点" class="headerlink" title="SIP的功能特点"></a>SIP的功能特点</h2><ol>
<li>确定用户位置：确定被叫SIP终端所在的位置。SIP的最强大之处就是用户定位功能。SIP本身含有向注册服务器注册的功能，也可以利用其他定位服务器如DNS、LDAP等提供的定位服务器来增强其定位功能。</li>
<li>确定用户可用性：确定被叫会话终端是否可以参加此会话。SIP支持多种地址描述和寻址，包括：用户名@主机地址、被叫号码@PSTN网关地址和普通电话号码（如Tel：01012345678）的描述等。这样，SIP主叫按照被叫地址，就可以识别出被叫是否在传统电话网上，然后通过一个与传统电话网相连的网关向被叫发起并建立呼叫。</li>
<li>确定用户能力：确定被叫终端可用于参加会话的媒体类型及媒体参数。SIP终端在消息交互过程中携带自身的媒体类型和媒体参数，这使得会话都可以明确对方的会话能力。</li>
<li>建立会话：建立主被叫双方的会话参数。SIP会话双方通过协商媒体类型和媒体参数，最终选择双方都具有的能力建立起会话。</li>
<li>管理会话：可以更改会话参数或中止会话。</li>
</ol>
<h2 id="SIP方法"><a href="#SIP方法" class="headerlink" title="SIP方法"></a>SIP方法</h2><ol>
<li>REGISTER：注册联系信息。</li>
<li>INVITE： 初始化一个会话</li>
<li>ACK： 对INVITE消息的最终响应。</li>
<li>CANCEL： 终止一个等待处理或正在处理的请求。</li>
<li>BYE： 终止一个会话。</li>
<li>OPTIONS： 查询服务器的性能。</li>
</ol>
<p>附加方法</p>
<ol>
<li>SUBSCRIBE：订阅方法</li>
<li>NOTIFY： 事件通知方法</li>
<li>MESSAGE： 即时消息方法</li>
</ol>
<h2 id="SIP访问码"><a href="#SIP访问码" class="headerlink" title="SIP访问码"></a>SIP访问码</h2><table>
<thead>
<tr>
<th>1xx</th>
<th>进展相应</th>
<th>临时相应</th>
</tr>
</thead>
<tbody><tr>
<td>2xx</td>
<td>成功</td>
<td>最终相应</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向错误</td>
<td>最终相应</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误</td>
<td>最终相应</td>
</tr>
<tr>
<td>5xx</td>
<td>服务端错误</td>
<td>最终相应</td>
</tr>
<tr>
<td>6xx</td>
<td>全局错误</td>
<td>最终相应</td>
</tr>
</tbody></table>
<h2 id="SIP的请求标题头"><a href="#SIP的请求标题头" class="headerlink" title="SIP的请求标题头"></a>SIP的请求标题头</h2><table>
<thead>
<tr>
<th>Header</th>
<th>含义说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>Call-ID</td>
<td>由本地设备(Client)生成，全局唯一，每次呼叫这个值唯一不变</td>
<td>Call-ID: <a href="mailto:&#x61;&#115;&#100;&#x38;&#x38;&#x61;&#x73;&#x64;&#x37;&#x37;&#x61;&#64;&#49;&#x2e;&#50;&#x2e;&#x33;&#x2e;&#x34;">&#x61;&#115;&#100;&#x38;&#x38;&#x61;&#x73;&#x64;&#x37;&#x37;&#x61;&#64;&#49;&#x2e;&#50;&#x2e;&#x33;&#x2e;&#x34;</a></td>
</tr>
<tr>
<td>From</td>
<td>表示请求的发起者</td>
<td>From: sip:<a href="mailto:&#x75;&#x73;&#x65;&#114;&#x31;&#x40;&#100;&#111;&#x6d;&#x61;&#105;&#110;&#46;&#99;&#111;&#109;">&#x75;&#x73;&#x65;&#114;&#x31;&#x40;&#100;&#111;&#x6d;&#x61;&#105;&#110;&#46;&#99;&#111;&#109;</a>;tag&#x3D;49583</td>
</tr>
<tr>
<td>To</td>
<td>表示请求的接收者</td>
<td>To: sip:<a href="mailto:&#117;&#115;&#x65;&#x72;&#x32;&#x40;&#100;&#111;&#109;&#x61;&#x69;&#110;&#46;&#x63;&#x6f;&#x6d;">&#117;&#115;&#x65;&#x72;&#x32;&#x40;&#100;&#111;&#109;&#x61;&#x69;&#110;&#46;&#x63;&#x6f;&#x6d;</a></td>
</tr>
<tr>
<td>Via</td>
<td>Via头域是被服务器插入request中，用来检查路由环的，并且可以使response根据via找到返回的路</td>
<td>Via: SIP&#x2F;2.0&#x2F;TCP user1pc.domain.com;branch&#x3D;z9hG4bK776sgdkse</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>用于表示这个包最多可以传送多少跳，每经过一跳都会减一当Max-Forwards&#x3D;&#x3D;0系统会返回483。默认为70</td>
<td>Max-Forwards: 70</td>
</tr>
<tr>
<td>Contact</td>
<td>包含源的URI信息，用来给响应方直接和源建立连接用</td>
<td>Contact: sip:192.168.100.1:1111</td>
</tr>
<tr>
<td>Content-Type</td>
<td>指明消息体的类型 (SDP会话描述协议)</td>
<td>Content-Type: text&#x2F;plain；Content-Type: application&#x2F;sdp; Content-Type: application&#x2F;cpim;</td>
</tr>
<tr>
<td>Content-Length</td>
<td>指明消息体的字节大小</td>
<td>Content-Length: 18</td>
</tr>
</tbody></table>
<h1 id="Poco-Event"><a href="#Poco-Event" class="headerlink" title="Poco::Event"></a>Poco::Event</h1><hr>
<blockquote>
<p>Poco::Event用于多线程之间的同步，</p>
</blockquote>
<p>事件是一个同步对象，允许一个线程向一个或者多个线程发出特定事件已经发生的信号。</p>
<p>通常一个线程发出事件信号，而一个或者多个线程在等待事件信号。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Event</span>(<span class="type">bool</span> autoReset = <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>创建一个事件，如果autoReset是true时，当一个wait()成功返回时，事件会自动复位。</p>
<h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>发出事件信号，如果autoReset为true，则只有一个等待事件的线程可以恢复执行。</p>
<p>如果autoReset为false，则所有等待线程都可以恢复执行。</p>
<h3 id="等待状态"><a href="#等待状态" class="headerlink" title="等待状态"></a>等待状态</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>等待事件发出信号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(<span class="type">long</span> milliseconds)</span></span>;</span><br></pre></td></tr></table></figure>

<p>等待事件发出信号，如果未在给定事件里发出信号，则抛出一个超时异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tryWait</span><span class="params">(<span class="type">long</span> milliseconds)</span></span>;</span><br></pre></td></tr></table></figure>

<p>等待事件信号，如果事件在给定时间内发出信号返回true，否则返回false。</p>
<h3 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>将事件重置为没有收到信号前的状态。</p>
<h1 id="std-memcpy"><a href="#std-memcpy" class="headerlink" title="std::memcpy"></a>std::memcpy</h1><hr>
<p>定义于头文件<cstring>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memcpy</span><span class="params">( <span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, std::<span class="type">size_t</span> count )</span></span>;</span><br></pre></td></tr></table></figure>

<p>从src所指向的对象复制count个字符到dest所指向的对象。两个对象都将转译成unsigned char的数组。</p>
<p>若对象重叠，则行为未定义。若dest或者src为非法或空指针则行为未定义。</p>
<h1 id="ntohl-htonl-函数"><a href="#ntohl-htonl-函数" class="headerlink" title="ntohl() htonl()函数"></a>ntohl() htonl()函数</h1><hr>
<p>ntohl()将一个无符号长整型数从网络字节顺序转为主机字节顺序，ntohl()返回一个以主机顺序表达的数。</p>
<p>htonl()将主机数转换成无符号长整型的网络字节顺序。本函数将一个32位数从主机字节序转换成网络字节顺序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> uint16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>  uint32;</span><br><span class="line"><span class="comment">//短整形高低字节交换</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Swap16(A) ((((uint16)(A) &amp; 0xff00) &gt;&gt; 8) | (((uint16)(A) &amp; 0x00ff) &lt;&lt; 8))</span></span><br><span class="line"><span class="comment">//长整形高低字节交换</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Swap32(A) ((((uint32)(A) &amp; 0xff000000) &gt;&gt; 24) | \</span></span><br><span class="line"><span class="meta">				   (((uint32)(A) &amp; 0x00ff0000) &gt;&gt;  8) | \</span></span><br><span class="line"><span class="meta">				   (((uint32)(A) &amp; 0x0000ff00) &lt;&lt;  8) | \</span></span><br><span class="line"><span class="meta">				   (((uint32)(A) &amp; 0x000000ff) &lt;&lt; 24))</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">union</span> &#123;   </span><br><span class="line">    <span class="type">char</span> c[<span class="number">4</span>];   </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mylong;   </span><br><span class="line">&#125; endian_test = &#123;&#123; <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;b&#x27;</span> &#125; &#125;;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">ENDIANNESS返回结果</span></span><br><span class="line"><span class="comment">	l:小端模式</span></span><br><span class="line"><span class="comment">	b:打断模式</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENDIANNESS ((char)endian_test.mylong)  </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//将主机的无符号短整形数转换成网络字节顺序</span></span><br><span class="line"><span class="function">uint16 <span class="title">htons</span><span class="params">(uint16 hs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ENDIANNESS==<span class="string">&#x27;l&#x27;</span>) ? <span class="built_in">Swap16</span>(hs): hs;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将主机的无符号长整形数转换成网络字节顺序</span></span><br><span class="line"><span class="function">uint32 <span class="title">htonl</span><span class="params">(uint32 hl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ENDIANNESS==<span class="string">&#x27;l&#x27;</span>) ? <span class="built_in">Swap32</span>(hl): hl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将一个无符号短整形数从网络字节顺序转换为主机字节顺序</span></span><br><span class="line"><span class="function">uint16 <span class="title">ntohs</span><span class="params">(uint16 ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ENDIANNESS==<span class="string">&#x27;l&#x27;</span>) ? <span class="built_in">Swap16</span>(ns): ns;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将一个无符号长整形数从网络字节顺序转换为主机字节顺序</span></span><br><span class="line"><span class="function">uint32 <span class="title">ntohl</span><span class="params">(uint32 nl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ENDIANNESS==<span class="string">&#x27;l&#x27;</span>) ? <span class="built_in">Swap32</span>(nl): nl;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	uint16 hs=<span class="number">0x1234</span>;</span><br><span class="line">	uint32 hl=<span class="number">0x12345678</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; htons(0x%4x) = 0x%4x\n&quot;</span>,hs,<span class="built_in">htons</span>(hs));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ntons(0x%4x) = 0x%4x\n&quot;</span>,hs,<span class="built_in">ntohs</span>(hs));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; htonl(0x%8x) = 0x%8x\n&quot;</span>,hl,<span class="built_in">htonl</span>(hl));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ntohl(0x%8x) = 0x%8x\n&quot;</span>,hl,<span class="built_in">ntohl</span>(hl));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TLV编码格式详解"><a href="#TLV编码格式详解" class="headerlink" title="TLV编码格式详解"></a>TLV编码格式详解</h1><hr>
<blockquote>
<p>BER是一种编码规格说明，只有确定了通信协议，才能理解数据含义。BER的数据由三个域构成：标识域(Tag)+长度域(Length)+值域(Value)，简称TLV格式</p>
</blockquote>
<ol>
<li><p>TLV简介</p>
<p>TLV是一种可变的格式，其中：</p>
<ul>
<li>T可以理解为Tag或者Type。用于标识标签或者编码格式信息</li>
<li>L定义数值的长度</li>
<li>V表示实际的数值</li>
</ul>
<p>T和L的长度固定，V的长度由Length指定</p>
</li>
<li><p>字节序</p>
<p>要正确的解析对方发来的数据除了统一数据格式之外还要统一字节序。字节序是指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。字节序一般分为<strong>大端</strong>和<strong>小端</strong>。</p>
<p>2.1 大端和小端</p>
<p>大端模式：高位字节放在内存的低地地址，低位字节存放在内存的高位位置。</p>
<p>小端模式：低位字节放在内存的低地址端，高位字节放在内存的高地址端。</p>
<p>2.2 网络字节序</p>
<p>网络字节序是TCP&#x2F;IP中规定好的一种数据表示格式，它与具体的CPU类型，操作系统等无关，从而可以保证数据在不同主句之间传输数据时能够被正确解释，网络字节大端序</p>
<p>为了进行转换，使用四个数据</p>
<ul>
<li>htons 把unsigned short类型从主机序转换到网络序</li>
<li>htonl 把unsigned long类型从主机序转换到网络序</li>
<li>ntohs 把unsigned short类型从网络序转换到主机序</li>
<li>ntohl 把unsigned long类型从网络序转换到主机序</li>
</ul>
</li>
<li><p>解编码</p>
<p>假设Tag(或Type)和Length都是四个字节表示</p>
<p>3.1 编码步骤</p>
<ol>
<li>使用htonl将Tag（或Type）转成网络字节序，指针偏移 4；</li>
<li>使用 <strong>htonl</strong> 将 Length 转成网络字节序，指针偏移 4；</li>
<li>若值 Value 为 int、char、short、long 类型，将其转为网络字节序，指针偏移；若值为字符串，写入后指针偏移 Length；</li>
<li>重复上述三步，继续编码后面的 TLV 单元。</li>
</ol>
<p>3.2 解码步骤</p>
<ol>
<li>读取 Tag（或Type）并使用 <strong>ntohl</strong> 将其转成主机字节序，指针偏移4；</li>
<li>读取 Length ntohl** 将其转成主机字节序，指针偏移4；</li>
<li>根据得到的长度读取 Value，若为 int、char、short、long 类型，将其转为主机字节序，指针偏移；若值为字符串，读取后指针偏移 Length；</li>
<li>重复上述三步，继续读取后面的 TLV 单元。</li>
</ol>
</li>
</ol>
<hr>
<h1 id="日志的几个等级"><a href="#日志的几个等级" class="headerlink" title="日志的几个等级"></a>日志的几个等级</h1><hr>
<ol>
<li>ALL：打开所有的日志</li>
<li>TRACE：级别很低的日志，一般不会用</li>
<li>DEBUG：开发过程中的运行信息</li>
<li>INFO：打印感兴趣的信息</li>
<li>WARN：潜在错误</li>
<li>ERROR：虽然发生错误信息，仍不影响系统的继续运行</li>
<li>FATAL：指出每个严重的错误事件将会导致应用程序的退出</li>
<li>OFF：最高等级的，关闭所有日志</li>
</ol>
<h1 id="atomic-store"><a href="#atomic-store" class="headerlink" title="atomic_store"></a>atomic_store</h1><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">atomic_store</span> <span class="params">(<span class="keyword">volatile</span> atomic&lt;T&gt;* obj, T val)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">atomic_store</span> <span class="params">(atomic&lt;T&gt;* obj, T val)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>

<p>修改包含的值，将obj中包含的值替换为val。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">大大怪下士</div><div class="post-copyright__author_desc">大大怪下士</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/posts/37176/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/posts/37176/')">8月知识点</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/posts/37176/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=8月知识点&amp;url=http://example.com/posts/37176/&amp;pic=/./img/28.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">明月清风居</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>基础知识<span class="tagsPageCount">11</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/./img/7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/31628/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/27.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">9.7</div></div></a></div><div class="next-post pull-right"><a href="/posts/54626/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">HTML</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/30988/" title="9.1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-09-04</div><div class="title">9.1</div></div></a></div><div><a href="/posts/31628/" title="9.7"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-09-14</div><div class="title">9.7</div></div></a></div><div><a href="/posts/47629/" title="9.5"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/25.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-09-05</div><div class="title">9.5</div></div></a></div><div><a href="/posts/29df/" title="FTP"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-09-03</div><div class="title">FTP</div></div></a></div><div><a href="/posts/25246/" title="Git"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/21.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-08-29</div><div class="title">Git</div></div></a></div><div><a href="/posts/18835/" title="Java开发规范"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-09-14</div><div class="title">Java开发规范</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#kbps"><span class="toc-number">1.</span> <span class="toc-text">kbps</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ptime"><span class="toc-number">2.</span> <span class="toc-text">ptime</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90json%E6%96%87%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">解析json文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9Fjson%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">观察json格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#json%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B"><span class="toc-number">3.2.</span> <span class="toc-text">json文件简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#json%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">3.2.1.</span> <span class="toc-text">json文件的语法规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#json%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">json值的类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#json%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">json文件解析流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">String的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#substr-%E6%88%AA%E5%8F%96string"><span class="toc-number">4.1.</span> <span class="toc-text">substr:截取string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stringstream%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">stringstream的用法:</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#thread"><span class="toc-number">5.</span> <span class="toc-text">thread</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#notify-one-%E4%B8%8Enotify-all-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">notify_one()与notify_all()的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pragma-once"><span class="toc-number">7.</span> <span class="toc-text">#pragma once</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ICE-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">8.</span> <span class="toc-text">ICE (面对对象中间件)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ICE%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">8.1.</span> <span class="toc-text">ICE实现过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-str-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">9.</span> <span class="toc-text">c_str()方法解析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">10.</span> <span class="toc-text">C++实现线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">10.1.</span> <span class="toc-text">线程池的介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9F%A5%E8%AF%86%E8%83%8C%E6%99%AF"><span class="toc-number">10.2.</span> <span class="toc-text">线程池知识背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">10.3.</span> <span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">10.3.1.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">10.3.2.</span> <span class="toc-text">线程池的组成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">10.4.</span> <span class="toc-text">线程池工作的四种情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.5.</span> <span class="toc-text">线程池的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">10.5.1.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E5%87%BD%E6%95%B0"><span class="toc-number">10.5.2.</span> <span class="toc-text">提交函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AE%9E%E4%BE%8B"><span class="toc-number">10.6.</span> <span class="toc-text">线程池的实现实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E8%A7%A3%E5%92%8C%E7%A1%AC%E8%A7%A3"><span class="toc-number">11.</span> <span class="toc-text">软解和硬解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E8%A7%A3"><span class="toc-number">11.1.</span> <span class="toc-text">软解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E8%A7%A3"><span class="toc-number">11.2.</span> <span class="toc-text">硬解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E7%A1%AC%E8%A7%A3%E7%9A%84%E4%BC%98%E5%8A%A3%E5%8C%BA%E5%88%AB"><span class="toc-number">11.3.</span> <span class="toc-text">软硬解的优劣区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-chrono-%E5%BA%93%E4%B8%AD%E7%9A%84-steady-clock-%E5%92%8C-system-clock"><span class="toc-number">11.4.</span> <span class="toc-text">C++ chrono 库中的 steady_clock 和 system_clock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.5.</span> <span class="toc-text">代码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E7%BB%93%E6%9E%9C"><span class="toc-number">11.5.1.</span> <span class="toc-text">示例结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-number">12.</span> <span class="toc-text">对象池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-number">12.1.</span> <span class="toc-text">什么是对象池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">12.2.</span> <span class="toc-text">对象池解决什么问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">12.3.</span> <span class="toc-text">对象池的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-number">12.4.</span> <span class="toc-text">对象池的弊端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">12.5.</span> <span class="toc-text">对象池的特征</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HANDLE%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">HANDLE的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#handle%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">13.0.1.</span> <span class="toc-text">handle使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E4%B8%8D%E8%AE%B8%E8%AE%BF%E9%97%AEUI"><span class="toc-number">13.0.1.1.</span> <span class="toc-text">子程序不许访问UI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5Handler"><span class="toc-number">13.0.1.2.</span> <span class="toc-text">引入Handler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">13.1.</span> <span class="toc-text">Handler的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#post-Runnable"><span class="toc-number">13.1.0.1.</span> <span class="toc-text">post(Runnable)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sendMessage-Message"><span class="toc-number">13.1.0.2.</span> <span class="toc-text">sendMessage(Message)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%8C%96%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82"><span class="toc-number">14.</span> <span class="toc-text">显式化模板实参</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#std-recursive-mutex"><span class="toc-number">15.</span> <span class="toc-text">std::recursive_mutex</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Poco-NumberParser"><span class="toc-number">16.</span> <span class="toc-text">Poco::NumberParser</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F"><span class="toc-number">17.</span> <span class="toc-text">原子变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#string-npos"><span class="toc-number">18.</span> <span class="toc-text">string::npos</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#npos%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">18.0.1.</span> <span class="toc-text">npos的用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">19.</span> <span class="toc-text">通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FPS"><span class="toc-number">19.0.1.</span> <span class="toc-text">FPS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#initializer-list%E8%AF%A6%E8%A7%A3"><span class="toc-number">20.</span> <span class="toc-text">initializer_list详解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%9A%84INL%E6%96%87%E4%BB%B6"><span class="toc-number">21.</span> <span class="toc-text">C++的INL文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SIP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">22.</span> <span class="toc-text">SIP协议的总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SIP%E6%A6%82%E5%BF%B5"><span class="toc-number">22.1.</span> <span class="toc-text">SIP概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SIP%E7%9A%84%E5%8A%9F%E8%83%BD%E7%89%B9%E7%82%B9"><span class="toc-number">22.2.</span> <span class="toc-text">SIP的功能特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SIP%E6%96%B9%E6%B3%95"><span class="toc-number">22.3.</span> <span class="toc-text">SIP方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SIP%E8%AE%BF%E9%97%AE%E7%A0%81"><span class="toc-number">22.4.</span> <span class="toc-text">SIP访问码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SIP%E7%9A%84%E8%AF%B7%E6%B1%82%E6%A0%87%E9%A2%98%E5%A4%B4"><span class="toc-number">22.5.</span> <span class="toc-text">SIP的请求标题头</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Poco-Event"><span class="toc-number">23.</span> <span class="toc-text">Poco::Event</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">23.0.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">23.0.2.</span> <span class="toc-text">发送信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81"><span class="toc-number">23.0.3.</span> <span class="toc-text">等待状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE"><span class="toc-number">23.0.4.</span> <span class="toc-text">重置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#std-memcpy"><span class="toc-number">24.</span> <span class="toc-text">std::memcpy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ntohl-htonl-%E5%87%BD%E6%95%B0"><span class="toc-number">25.</span> <span class="toc-text">ntohl() htonl()函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TLV%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="toc-number">26.</span> <span class="toc-text">TLV编码格式详解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%9A%84%E5%87%A0%E4%B8%AA%E7%AD%89%E7%BA%A7"><span class="toc-number">27.</span> <span class="toc-text">日志的几个等级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#atomic-store"><span class="toc-number">28.</span> <span class="toc-text">atomic_store</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/7061/" title="红黑树"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="红黑树"/></a><div class="content"><a class="title" href="/posts/7061/" title="红黑树">红黑树</a><time datetime="2023-11-19T15:21:10.000Z" title="发表于 2023-11-19 23:21:10">2023-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1b47/" title="B_B+树"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="B_B+树"/></a><div class="content"><a class="title" href="/posts/1b47/" title="B_B+树">B_B+树</a><time datetime="2023-11-19T15:20:23.000Z" title="发表于 2023-11-19 23:20:23">2023-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ef35/" title="排序算法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="排序算法"/></a><div class="content"><a class="title" href="/posts/ef35/" title="排序算法">排序算法</a><time datetime="2023-11-19T15:19:10.000Z" title="发表于 2023-11-19 23:19:10">2023-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/42f5/" title="hash算法原理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hash算法原理"/></a><div class="content"><a class="title" href="/posts/42f5/" title="hash算法原理">hash算法原理</a><time datetime="2023-11-19T15:18:18.000Z" title="发表于 2023-11-19 23:18:18">2023-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d07f/" title="动态回溯分治贪心"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="动态回溯分治贪心"/></a><div class="content"><a class="title" href="/posts/d07f/" title="动态回溯分治贪心">动态回溯分治贪心</a><time datetime="2023-11-19T15:16:42.000Z" title="发表于 2023-11-19 23:16:42">2023-11-19</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="大大怪下士" target="_blank">大大怪下士</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">4</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>5</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.88rem;">前端<sup>1</sup></a><a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">基础知识<sup>11</sup></a><a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" style="font-size: 0.88rem;">密码学<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">计算机网络<sup>7</sup></a><a href="/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/" style="font-size: 0.88rem;">音视频<sup>9</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.9",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 大大怪下士 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>