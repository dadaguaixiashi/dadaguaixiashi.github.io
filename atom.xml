<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>明月清风居</title>
  
  <subtitle>大大怪下士</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-24T14:19:14.003Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>大大怪下士</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机组成与结构</title>
    <link href="http://example.com/posts/ee1/"/>
    <id>http://example.com/posts/ee1/</id>
    <published>2023-08-24T13:18:25.000Z</published>
    <updated>2023-08-24T14:19:14.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成与结构"><a href="#计算机组成与结构" class="headerlink" title="计算机组成与结构"></a>计算机组成与结构</h1><hr><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul><li>计算机基本硬件组成</li><li>中央处理单元组成</li><li>计算机指令系统</li><li>存储系统</li><li>总线系统</li></ul><h2 id="计算机系统基础知识"><a href="#计算机系统基础知识" class="headerlink" title="计算机系统基础知识"></a>计算机系统基础知识</h2><blockquote><p>计算机的基本硬件系统由运算器，控制器，存储器，输入输出设备组成</p></blockquote><ol><li>运算器，控制器被集成为中央处理单元（CPU），是硬件系统的核心</li><li>存储器，分为内存和外存。内存速度高，容量小，临时存储。后者容量大，存储慢，长期存储</li><li>输入和输出设备，统称为外设</li></ol><h3 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h3><ol><li>程序控制<br>CPU通过指令来控制程序</li><li>操作控制<br>一条指令执行需要若干操作信号配合完成</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机组成与结构&quot;&gt;&lt;a href=&quot;#计算机组成与结构&quot; class=&quot;headerlink&quot; title=&quot;计算机组成与结构&quot;&gt;&lt;/a&gt;计算机组成与结构&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;考点&quot;&gt;&lt;a href=&quot;#考点&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="系统架构设计师" scheme="http://example.com/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    
    <category term="基础知识" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>HTML</title>
    <link href="http://example.com/posts/54626/"/>
    <id>http://example.com/posts/54626/</id>
    <published>2022-09-21T13:07:15.000Z</published>
    <updated>2023-08-24T12:31:49.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><hr><p> 网页组成：文字，图片，音视频，超链接</p><p>前端代码通过浏览器的渲染和解析组成网页，浏览器：网页显示和运行的平台</p><p>常见浏览器：IE，火狐，谷歌，Safari，欧明</p><h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><blockquote><p>浏览器中<strong>对代码进行渲染的部分</strong></p></blockquote><p>渲染浏览器不同，解析代码的速度，性能等不同</p><h3 id="Web标准"><a href="#Web标准" class="headerlink" title="Web标准"></a>Web标准</h3><p>面向不同浏览器内核的代码标准</p><p><em><strong>Web标准的三个构成</strong></em></p><p>结构：HTML——页面元素和内容</p><p>表现： CSS——网页元素的外观位置等页面样式</p><p>‘行为：JavaScript——网页模型定义核页面交互</p><h2 id="HTML的概念"><a href="#HTML的概念" class="headerlink" title="HTML的概念"></a>HTML的概念</h2><blockquote><p>HTML中文译为超文本标记语言</p></blockquote><p>在写的时候遵循语法规则。</p><p><strong>HTML骨架结构</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        网页内容</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="VSCode的基础使用"><a href="#VSCode的基础使用" class="headerlink" title="VSCode的基础使用"></a>VSCode的基础使用</h3><p>将文件拖入即可使用，使用！创建基本骨架</p><h3 id="HTML注释"><a href="#HTML注释" class="headerlink" title="HTML注释"></a>HTML注释</h3><p>VScode中：ctrl+ &#x2F;将一行注释</p><h3 id="HTML标签的结构"><a href="#HTML标签的结构" class="headerlink" title="HTML标签的结构"></a>HTML标签的结构</h3><p>标签由&lt;&gt;&#x2F;英文字母组成，并且把&lt;&gt;包括起来的英文单词或字母称为标签名。</p><p>常见标签由两部分组成：<strong>双标签</strong>，开始和结束标签</p><p>少数标签由一部分组成：<strong>单标签</strong>，自成一体，无法包裹内容。</p><h3 id="HTML标签之间的关系"><a href="#HTML标签之间的关系" class="headerlink" title="HTML标签之间的关系"></a>HTML标签之间的关系</h3><ul><li>父子</li><li>兄弟</li></ul><h2 id="HTML标签学习"><a href="#HTML标签学习" class="headerlink" title="HTML标签学习"></a>HTML标签学习</h2><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><p>代码样式：h1到h6</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">    二级标题</span><br><span class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">    三级标题</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在CSCode中ctrl+d进行选择</p><p><strong>特点</strong></p><ul><li>文字加粗</li><li>文字变大，从h1到h6逐渐减小</li><li>独占一行</li></ul><h3 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h3><p>场景：在新闻和文章中，用于分段显示</p><p>代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    我是一段文字</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>语义：段落</p><p><strong>特点</strong></p><ul><li>独占一行</li><li>段落之间有空白</li></ul><h3 id="换行标签"><a href="#换行标签" class="headerlink" title="换行标签"></a>换行标签</h3><p>代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>语义：强制换行</p><h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h3><p>代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br></pre></td></tr></table></figure><p>语义：添加水平分割线</p><h3 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h3><p>文字加粗，下划线，倾斜，删除等效果</p><p>代码</p><table><thead><tr><th align="center"><strong>标签</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">b</td><td align="center">加粗</td></tr><tr><td align="center">u</td><td align="center">下划线</td></tr><tr><td align="center">i</td><td align="center">倾斜</td></tr><tr><td align="center">s</td><td align="center">删除线</td></tr></tbody></table><p>突出强调时用这个</p><table><thead><tr><th align="center">标签</th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">strong</td><td align="center">加粗</td></tr><tr><td align="center">ins</td><td align="center">下划线</td></tr><tr><td align="center">em</td><td align="center">倾斜</td></tr><tr><td align="center">del</td><td align="center">删除线</td></tr></tbody></table><p>语义：突出重要性的强调语句</p><h2 id="媒体信息的基础使用"><a href="#媒体信息的基础使用" class="headerlink" title="媒体信息的基础使用"></a>媒体信息的基础使用</h2><h3 id="图片标签的介绍"><a href="#图片标签的介绍" class="headerlink" title="图片标签的介绍"></a>图片标签的介绍</h3><p>场景：在网页中显示图片</p><p>代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>特点：</p><ul><li><p>单标签</p></li><li><p>img标签需要展示对应的效果，需要借助标签进行设置</p><p>src是图片资源地址</p><p>alt是图片替换资源，图片不显示显示的文件</p></li><li><p>一个图片可以有多个属性</p></li><li><p>属性之间空格隔开</p></li><li><p>标签名和属性之间可以空格隔开</p></li><li><p>属性没有顺序之分</p></li></ul><h3 id="图片的title属性"><a href="#图片的title属性" class="headerlink" title="图片的title属性"></a>图片的title属性</h3><p>属性名：title</p><p>属性值：提示文本，当鼠标悬停时显示的文本</p><p><strong>注意</strong>：title也可以用于其他标签</p><h3 id="图片的width和height属性"><a href="#图片的width和height属性" class="headerlink" title="图片的width和height属性"></a>图片的width和height属性</h3><p>属性名：width，eight</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt; 网页组成：文字，图片，音视频，超链接&lt;/p&gt;
&lt;p&gt;前端代码通过浏览器的渲染和解析组成网页，浏览器：网页显示和运</summary>
      
    
    
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>8月知识点</title>
    <link href="http://example.com/posts/37176/"/>
    <id>http://example.com/posts/37176/</id>
    <published>2022-09-17T11:38:50.000Z</published>
    <updated>2023-08-24T12:57:49.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kbps"><a href="#kbps" class="headerlink" title="kbps"></a>kbps</h1><hr><blockquote><p>比特率单位(千比特每秒),又称千比特率,指的是数字信号的传输速率，也就是每秒钟传输多少个千位的信息(k表示千，kb表示的是多少千个位),也可以表示网络的传输速度.</p></blockquote><ol><li>VBR（Variable Bitrate）动态比特率 也就是没有固定的比特率，压缩软件在压缩时根据视频数据即时确定使用什么比特率，这是以质量为前提兼顾文件大小的方式，也是推荐的编码模式；</li><li>ABR（Average Bitrate）平均比特率 是VBR的一种插值参数。ABR在指定的文件大小内，以固定的帧数为一段，可以做为VBR和CBR的一种折衷选择。</li><li>CBR（Constant Bitrate），常数比特率 指文件从头到尾都是一种位速率。相对于VBR和ABR来讲，它压缩出来的文件体积很大，而且画质相对于VBR和ABR不会有明显的提高。</li></ol><h1 id="ptime"><a href="#ptime" class="headerlink" title="ptime"></a>ptime</h1><hr><blockquote><p>官方给出的ptime定义为:ptime gives the length of time in milliseconds represented by themedia in a packet .就是一个数据包中媒体的时长，通信两侧协定的ptime尽量一致。  </p></blockquote><p>这个是根据<strong>协议</strong>进行读取的。</p><h1 id="解析json文件"><a href="#解析json文件" class="headerlink" title="解析json文件"></a>解析json文件</h1><hr><h2 id="观察json格式"><a href="#观察json格式" class="headerlink" title="观察json格式"></a>观察json格式</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;paramz&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;feeds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">299076</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;oid&quot;</span><span class="punctuation">:</span> <span class="number">288340</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;article&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;subject&quot;</span><span class="punctuation">:</span> <span class="string">&quot;荔枝新闻3.0：不止是阅读&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;summary&quot;</span><span class="punctuation">:</span> <span class="string">&quot;江苏广电旗下资讯类手机应用“荔枝新闻”于近期推出全新升级换代的3.0版。&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;cover&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/Attachs/Article/288340/3e8e2c397c70469f8845fad73aa38165_padmini.JPG&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;pic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;txt&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;changed&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2015-09-22 16:01:41&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;PageIndex&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;PageSize&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;TotalCount&quot;</span><span class="punctuation">:</span> <span class="number">53521</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;TotalPage&quot;</span><span class="punctuation">:</span> <span class="number">2677</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="json文件简介"><a href="#json文件简介" class="headerlink" title="json文件简介"></a>json文件简介</h2><p>若有很多参数需要频繁更改，可以将这种类型的参数文件放在一个文本里面，然后设计一个函数接口来读取这些参数并存储在结构体或者其他类型的容器内  </p><h3 id="json文件的语法规则"><a href="#json文件的语法规则" class="headerlink" title="json文件的语法规则"></a>json文件的语法规则</h3><ol><li>每一条数据通过key:value的形式储存，如”name”:”lsx”</li><li>数据之间通过逗号分隔，如”name”:”lsx”,”age”:16</li><li>花括号用于保存对象，如”info”:{“name”:”lsx”,”age”:16}</li><li>一个数组中可以包含多个对象，一个对象中也可以包含多个数组</li></ol><h3 id="json值的类型"><a href="#json值的类型" class="headerlink" title="json值的类型"></a>json值的类型</h3><ol><li>数字(整型或浮点型)</li><li>字符串(双引号)“”</li><li>逻辑值(布尔型)</li><li>对象(在花括号中){}</li><li>数组(在中括号中)</li></ol><h2 id="json文件解析流程"><a href="#json文件解析流程" class="headerlink" title="json文件解析流程"></a>json文件解析流程</h2><ol><li>创建对象</li><li>读取根节点</li><li>获取子节点信息</li><li>对于规则子节点信息进行遍历</li></ol><h1 id="String的使用"><a href="#String的使用" class="headerlink" title="String的使用"></a>String的使用</h1><hr><h2 id="substr-截取string"><a href="#substr-截取string" class="headerlink" title="substr:截取string"></a>substr:截取string</h2><p>substr(str,pos,len):从pos开始的位置，截取len个字符<br>SUBSTR(str,pos):从pos开始的位置，一直到最后  </p><h2 id="stringstream的用法"><a href="#stringstream的用法" class="headerlink" title="stringstream的用法:"></a>stringstream的用法:</h2><p>stringstream是C++提供的串流（stream）物件 ，需要处理字符串时，往往是输入的一行中包含多个字符以及空格，这个时候就可以利用 stringstream进行单个字符或者单个字符串分析处理了  </p><p>stringstream的作用就是从string对象读取字符或字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>(ss&gt;&gt;ch)&#123;</span><br><span class="line">    cout&lt;&lt;ch&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h1><hr><blockquote><p>thread是C++11中提供多线程编程的模块，使用的时候需要包含<thread>头文件。</p></blockquote><p>joinable()函数是一个布尔类型的函数，他会返回一个布尔值来表示当前的线程是否是可执行线程. </p><p>join是将指定的线程加入当前线程，指定线程结束时才会继续执行当前线程。</p><p>detach是将线程从当前线程分离出去，即不会受阻塞。</p><p>std::jthread基于已经存在的std::thread。它基本上是一个包装器，它为线程带来了两个新功能：默认情况下，它们可以协同中断并加入。   </p><h1 id="notify-one-与notify-all-的区别"><a href="#notify-one-与notify-all-的区别" class="headerlink" title="notify_one()与notify_all()的区别"></a>notify_one()与notify_all()的区别</h1><hr><p>notify_one()：因为只唤醒等待队列中的第一个线程；不存在锁争用，所以能够立即获得锁。其余的线程不会被唤醒，需要等待再次调用notify_one()或者notify_all()。</p><p>notify_all()：会唤醒所有等待队列中阻塞的线程，存在锁争用，只有一个线程能够获得锁。其余线程会继续尝试获得锁(类似于轮询)，而不会再次阻塞。  </p><h1 id="pragma-once"><a href="#pragma-once" class="headerlink" title="#pragma once"></a>#pragma once</h1><hr><p>在C&#x2F;C++中，在使用预编译指令#include的时候，为了防止重复引用造成二义性，通常有两种方式  </p><ul><li>#ifndef指令防止代码块重复引用  </li><li>#pragma once指令，在想要保护的文件开头写入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure><p>#pragma once一般由编译器提供保证：<strong>同一个文件</strong>不会被包含多次。这里所说的”同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。无法对一个头文件中的一段代码作#pragma once声明，而只能针对文件.</p><h1 id="ICE-面对对象中间件"><a href="#ICE-面对对象中间件" class="headerlink" title="ICE (面对对象中间件)"></a>ICE (面对对象中间件)</h1><hr><p>Ice 对象是本地或远地的地址空间中、能响应客户请求的实体。一个Ice对象可在一个或多个服务器中实例化。每个Ice对象都有一个或多个接口。一个接口是一个对象所支持的一系列有名称的操作，客户通过调用操作来发出请求。一个操作有零个或更多参数，以及一个返回值。每个Ice 对象都有一个唯一的对象标识。对象标识是用于把一个对象与其他所有对象区别开来的标识值。 Ice 对象模型假定对象标识是全局唯一的，也就是说，在一个Ice 通信域中，不会有两个对象具有相同的对象标识。对象标识既可以通过调用GenerateUUID（）全局唯一产生，也可以根据自己的喜好随意创建一个，只要没与其他对象标识重复即可。</p><ul><li>代理<br>要想与某个Ice对象联系，客户必须持有这个对象的代理。对客户而言，代理就是Ice对象的本地代表（该对象可能在远地）。代理所封装的信息有：寻址信息：用于让客户端run time 联系正确的服务器对象标识：用于确定服务器中的哪一个对象是请求的目标可选的facet 标识符：用于确定代理所引用的是对象的哪一个facet。</li><li>Servants<br>Ice 对象是一种具有类型、标识，以及寻址信息，在本地或远地的地址空间中、能响应客户请求的实体的概念性实体。而Servants是服务器端用具体的编程语言实现的实体，并且在服务器的地址空间中进行实例化。 Servants 为“客户发送的操作调用”提供服务器端行为。  </li><li>动态映射表<br>动态映射表（ Active servant map），简称ASM。之所以称为动态映射表，是因为它可以动态维护servant的数量，可以添加，也可以删除。它是一个查找表，用于把对象标识映射到servant；要激活一个servant，就将它添加进动态映射表。这个过程可以看作是在“Ice 对象的标识”与“对应的用编程语言编写的、负责为该ICE对象处理请求的servant”之间创建链接。这个链接创建好之后，一旦客户端的请求到来时， Ice run time 就可以将该请求分派给正确的servant来执行。动态servant映射表的几种操作行为如下：  </li><li>add<br>add 操作把一个具有指定标识的servant 增加到ASM中。一旦add 被调用，请求就会分派给这个servant。返回值是这个servant 所体现的Ice对象的代理。你不能用同一标识多次调用add：如果你试图在ASM 中增加一个已经存在的标识，就会引发AlreadyRegisteredException  </li><li>addWithUUID<br>addWithUUID 操作的行为和add 操作一样，但你不需要为servant 提供标识。addWithUUID 会生成一个UUID，作为对应的Ice 对象的标识。</li><li>remove<br>remove 操作中断对象标识与其servant 之间的关联，从ASM 中移除对应的条目。一旦servant 解除了激活，新到来的针对已移除的对象标识的请求会引发ObjectNotExistException</li></ul><h2 id="ICE实现过程"><a href="#ICE实现过程" class="headerlink" title="ICE实现过程"></a>ICE实现过程</h2><ul><li>服务器端</li></ul><ol><li>创建 servant 类，并在服务器端 Ice run time 上注册。  </li><li>实例化 servant 类，创建具体的 servant。  </li><li>为这个 servant 所体现的 Ice 对象创建标识。  </li><li>激活 servant（即将 servant 添加进动态 servant 映射表）</li></ol><ul><li>客户端</li></ul><ol><li>当客户端要调用某一操作时， 客户端 run time 会将对象标识以及请求一起发给服务器。  </li><li>服务器端的对象适配器接收到了请求和对象标识， 对象适配器继而根据这个对象标识，在它所维护管理的active servant map中查找其相对应的正确的servant。  </li><li>若找到了与对象标识对应的正确的servant，就把调用分派给它。若查找不到，就会引发Object Not Exist Exception。最后客户端接收到来自服务器端的返回值或异常信息。</li></ol><h1 id="c-str-方法解析"><a href="#c-str-方法解析" class="headerlink" title="c_str()方法解析"></a>c_str()方法解析</h1><hr><p>指向一个字符串数组的指针</p><h1 id="C-实现线程池"><a href="#C-实现线程池" class="headerlink" title="C++实现线程池"></a>C++实现线程池</h1><hr><h2 id="线程池的介绍"><a href="#线程池的介绍" class="headerlink" title="线程池的介绍"></a>线程池的介绍</h2><blockquote><p>作为五大池之一(内存池，连接池，线程池，进程池，携程池)，线程池的应用十分广泛，不管是客户端程序还是后台服务端，都是提高业务处理能力的必备模块。</p></blockquote><h2 id="线程池知识背景"><a href="#线程池知识背景" class="headerlink" title="线程池知识背景"></a>线程池知识背景</h2><ul><li>C++面向对象的标准：组合和继承，多态，STL容器，智能指针，函数对象，绑定器，可变参数等    </li><li>C++11多线程编程：thread、mutex、atomic、condition_variable、unique_lock等</li></ul><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>当进行并行的任务作业操作时，线程的建立与销毁的开销是，阻碍性能进步的关键，因此线程池，由此产生。使用多个线程，无限制循环等待队列，进行计算和操作。帮助快速降低和减少性能损耗。</p><h3 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h3><ol><li>线程池管理器:初始化和创建线程，启动和停止线程，调配任务，管理线程池。</li><li>工作线程:线程池中等待并执行分配的任务</li><li>任务接口:添加任务的接口，以提供工作线程调度任务的执行。</li><li>任务队列:用于存放没有处理的任务，提供一种缓冲机制，同时具有调度功能，高优先级的任务放在队列前面。</li></ol><h2 id="线程池工作的四种情况"><a href="#线程池工作的四种情况" class="headerlink" title="线程池工作的四种情况"></a>线程池工作的四种情况</h2><p>1.<strong>没有任务要执行，缓冲队列为空</strong></p><p><img src="/../img/3805f625e05f8e2d1d0b69910323d7a9.png"></p><ol start="2"><li><p><strong>队列中任务数量，小于等于线程池中线程任务数量</strong></p><p><img src="/../img/b72937b576e8e3e4a0b14ff5a9b3a1b9.png"></p></li></ol><p>3.<strong>任务数量大于线程池数量,缓冲队列未满</strong></p><p><img src="/../img/3bc05a0abf3eff2c7e25427e1c2636bb.png"></p><p>4.<strong>任务数量大于线程池数量，缓冲队列已满</strong></p><p><img src="/../img/4a50fc4f32e13a1761c2e687a58a83a4.png"></p><h2 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h2><ul><li>任务队列</li><li>线程池</li><li>完成队列</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>我们使用队列来存储工作，因为它是更合理的数据结构。 我们希望以与发送它相同的顺序启动工作。 但是，这个队列有点特殊。正如我在上一节中所说的，线程是连续的（好吧，不是真的，但我们假设它们是）查询队列要求工作。当有可用的工作时，线程从队列中获取工作并执行它。如果两个线程试图同时执行相同的工作会发生什么？ 好吧，程序会崩溃。<br>为了避免这种问题，我在标准C ++ Queue上实现了一个包装器，它使用mutex来限制并发访问。 让我们看一下SafeQueue类的一小部分示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_queue.<span class="built_in">push</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提交函数"><a href="#提交函数" class="headerlink" title="提交函数"></a>提交函数</h3><p>线程池最重要的方法是负责向队列添加工作的方法。我打电话给这个方法提交。不难理解它是如何工作的，但它的实现起初可能看起来很吓人。让我们考虑应该做什么，之后我们会担心如何做到这一点。 什么：</p><ul><li>接受任何参数的任何函数。</li><li>立即返回“东西”以避免阻塞主线程。 此返回的对象最终应包含操作的结果。<br>完整的提交函数如下所示：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Submit a function to be executed asynchronously by the pool template&lt;typename F, typename...Args&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Create a function with bounded parameters ready to execute</span></span><br><span class="line">    std::function&lt;<span class="keyword">decltype</span>(f(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="comment">// Encapsulate it into a shared ptr in order to be able to copy construct / assign </span></span><br><span class="line">    <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt;&gt;(func);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wrap packaged task into void function</span></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; wrapper_func = [task_ptr]() &#123;</span><br><span class="line">      (*task_ptr)(); </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue generic wrapper function</span></span><br><span class="line">    m_queue.<span class="built_in">enqueue</span>(wrapperfunc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake up one thread if its waiting</span></span><br><span class="line">    m_conditional_lock.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return future from promise</span></span><br><span class="line">    <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线程池的实现实例"><a href="#线程池的实现实例" class="headerlink" title="线程池的实现实例"></a>线程池的实现实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadPool.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SafeQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ThreadWorker</span> &#123;<span class="comment">//内置线程工作类</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_id; <span class="comment">//工作id</span></span><br><span class="line"></span><br><span class="line">    ThreadPool * m_pool;<span class="comment">//所属线程池</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadWorker</span>(ThreadPool * pool, <span class="type">const</span> <span class="type">int</span> id) </span><br><span class="line">      : <span class="built_in">m_pool</span>(pool), <span class="built_in">m_id</span>(id) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载`()`操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      std::function&lt;<span class="type">void</span>()&gt; func; <span class="comment">//定义基础函数类func</span></span><br><span class="line">      </span><br><span class="line">      <span class="type">bool</span> dequeued; <span class="comment">//是否正在取出队列中元素</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//判断线程池是否关闭，没有关闭，循环提取</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (!m_pool-&gt;m_shutdown) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//为线程环境锁加锁，互访问工作线程的休眠和唤醒</span></span><br><span class="line"></span><br><span class="line">          <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_pool-&gt;m_conditional_mutex)</span></span>;</span><br><span class="line">          <span class="comment">//如果任务队列为空，阻塞当前线程</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (m_pool-&gt;m_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            m_pool-&gt;m_conditional_lock.<span class="built_in">wait</span>(lock); <span class="comment">//等待条件变量通知，开启线程</span></span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//取出任务队列中的元素</span></span><br><span class="line"></span><br><span class="line">          dequeued = m_pool-&gt;m_queue.<span class="built_in">dequeue</span>(func);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果成功取出，执行工作函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dequeued) &#123;</span><br><span class="line">          <span class="built_in">func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> m_shutdown; <span class="comment">//线程池是否关闭</span></span><br><span class="line"></span><br><span class="line">  SafeQueue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; m_queue;<span class="comment">//执行函数安全队列，即任务队列</span></span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::thread&gt; m_threads; <span class="comment">//工作线程队列</span></span><br><span class="line"></span><br><span class="line">  std::mutex m_conditional_mutex;<span class="comment">//线程休眠锁互斥变量</span></span><br><span class="line"></span><br><span class="line">  std::condition_variable m_conditional_lock; <span class="comment">//线程环境锁，让线程可以处于休眠或者唤醒状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//线程池构造函数</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">ThreadPool</span>(<span class="type">const</span> <span class="type">int</span> n_threads)</span><br><span class="line">    : <span class="built_in">m_threads</span>(std::<span class="built_in">vector</span>&lt;std::thread&gt;(n_threads)), <span class="built_in">m_shutdown</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ThreadPool</span>(<span class="type">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>; <span class="comment">//拷贝构造函数，并且取消默认父类构造函数</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">ThreadPool</span>(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>; <span class="comment">// 拷贝构造函数，允许右值引用</span></span><br><span class="line"></span><br><span class="line">  ThreadPool &amp; <span class="keyword">operator</span>=(<span class="type">const</span> ThreadPool &amp;) = <span class="keyword">delete</span>; <span class="comment">// 赋值操作</span></span><br><span class="line"></span><br><span class="line">  ThreadPool &amp; <span class="keyword">operator</span>=(ThreadPool &amp;&amp;) = <span class="keyword">delete</span>; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Inits thread pool</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      m_threads[i] = std::<span class="built_in">thread</span>(<span class="built_in">ThreadWorker</span>(<span class="keyword">this</span>, i));<span class="comment">//分配工作线程</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Waits until threads finish their current task and shutdowns the pool</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_shutdown = <span class="literal">true</span>;</span><br><span class="line">    m_conditional_lock.<span class="built_in">notify_all</span>(); <span class="comment">//通知 唤醒所有工作线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_threads.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span>(m_threads[i].<span class="built_in">joinable</span>()) &#123; <span class="comment">//判断线程是否正在等待</span></span><br><span class="line"></span><br><span class="line">        m_threads[i].<span class="built_in">join</span>();  <span class="comment">//将线程加入等待队列</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Submit a function to be executed asynchronously by the pool</span></span><br><span class="line">  <span class="comment">//线程的主要工作函数，使用了后置返回类型，自动判断函数返回值</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>...Args&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">auto</span> <span class="title">submit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Create a function with bounded parameters ready to execute</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="keyword">decltype</span>(f(args...))()&gt; func = std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);<span class="comment">//连接函数和参数定义，特殊函数类型,避免左、右值错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encapsulate it into a shared ptr in order to be able to copy construct // assign </span></span><br><span class="line">    <span class="comment">//封装获取任务对象，方便另外一个线程查看结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task_ptr = std::make_shared&lt;std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt;&gt;(func);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wrap packaged task into void function</span></span><br><span class="line">    <span class="comment">//利用正则表达式，返回一个函数对象</span></span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; wrapper_func = [task_ptr]() &#123;</span><br><span class="line">      (*task_ptr)(); </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列通用安全封包函数，并压入安全队列</span></span><br><span class="line"></span><br><span class="line">    m_queue.<span class="built_in">enqueue</span>(wrapper_func);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒一个等待中的线程</span></span><br><span class="line"></span><br><span class="line">    m_conditional_lock.<span class="built_in">notify_one</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回先前注册的任务指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="软解和硬解"><a href="#软解和硬解" class="headerlink" title="软解和硬解"></a>软解和硬解</h1><hr><h2 id="软解"><a href="#软解" class="headerlink" title="软解"></a>软解</h2><blockquote><p>利用软件本身解码，但是实际上还是使用CPU进行解码</p></blockquote><p>在软件解码过程中，需要对于大量的视频信息进行运算，对于CPU的性能要求非常高。对于高清大大码率的视频来说，巨大的运算量就会造成转换效率低，发热量高等问题。</p><p>软解码不需要过多的硬件支持，兼容性非常高，即使出现新的视频编码格式，只要安装好相应的解码器文件，就可以顺利播放。而且软解码拥有丰富的滤镜，字幕，画面处理优化等效果，只有你CPU够强悍，就能够实现更加出色的画面效果。</p><h2 id="硬解"><a href="#硬解" class="headerlink" title="硬解"></a>硬解</h2><blockquote><p>字面上的意思就是硬件解码。通过设备上的显卡GPU的视频加速功能对高清视频进行解码。</p></blockquote><p>硬解调用GPU的专门模块编码来解码，减少CPU运算。显卡核心GPU拥有独特的计算方法，解码效率非常高，这样不但能够减轻CPU的负担，还有着低功耗，发热少等特点。</p><p>但是，由于硬解码起步比较晚，软件和驱动对他的支持度很低，基本上硬解码内置什么样的模块，就解码什么样的视频，面对网上各色各样的视频编码样式，往往会出现兼容性不好的问题。此外，硬解码的滤镜、字幕、画质方面都做的不够理想。</p><h2 id="软硬解的优劣区别"><a href="#软硬解的优劣区别" class="headerlink" title="软硬解的优劣区别"></a>软硬解的优劣区别</h2><hr><ul><li>GPU硬解码高清视频的优势<ol><li>不需要太好的CPU，单核足矣，CPU方面节约不少资金；</li><li>硬解码基本相当于免费附送，不到500元的整合主板都能完美支持；</li><li>硬解码让CPU占用率超低，系统有能力在看HDTV的同时进行多任务操作；</li><li>CPU需要倾尽全力才能解码HDTV，而GPU只需动用0.1亿晶体管的解码模块就能完成任务，功耗控制更好；</li></ol></li><li>GPU硬解码高清视频的劣势<ol><li>起步较晚，软件支持度无法与软解相提并论；</li><li>面对杂乱无章的视频编码、封装格式，硬解码无法做到全面兼容；</li><li>软解拥有大量画面输出补偿及画质增强技术，而硬解这方面做得还远远不够；</li><li>硬解码软件设置较为复杂，很多朋友根本不知道该如何正确使用GPU硬件解码。</li></ol></li></ul><h2 id="C-chrono-库中的-steady-clock-和-system-clock"><a href="#C-chrono-库中的-steady-clock-和-system-clock" class="headerlink" title="C++ chrono 库中的 steady_clock 和 system_clock"></a>C++ chrono 库中的 steady_clock 和 system_clock</h2><p>C++11中的标准库<chrono>中有三种时钟:steady_clock,system_clock,high_resolution_clock</p><ol><li>steady_clock是**单调的时钟,**只会增长，适用于程序耗时</li><li>system_clock 是<strong>系统的时钟</strong>；因为系统的时钟可以修改；甚至可以网络对时； 所以用系统时间计算时间差可能不准。</li><li>high_resolution_clock 是<strong>当前系统能够提供的最高精度的时钟</strong>；它也是<strong>不可以修改的</strong>。相当于 steady_clock 的高精度版本。</li></ol><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copied from http://www.informit.com/articles/article.aspx?p=1881386&amp;seqNum=2;</span></span><br><span class="line"><span class="comment">// Author: Nicolai M. Josuttis</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printClockData</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;- precision: &quot;</span>;</span><br><span class="line">    <span class="comment">// if time unit is less or equal one millisecond</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> C::period P;<span class="comment">// type of time unit</span></span><br><span class="line">    <span class="keyword">if</span> (ratio_less_equal&lt;P,milli&gt;::value) &#123;</span><br><span class="line">       <span class="comment">// convert to and print as milliseconds</span></span><br><span class="line">       <span class="keyword">typedef</span> <span class="keyword">typename</span> ratio_multiply&lt;P,kilo&gt;::type TT;</span><br><span class="line">       cout &lt;&lt; fixed &lt;&lt; <span class="built_in">double</span>(TT::num)/TT::den</span><br><span class="line">            &lt;&lt; <span class="string">&quot; milliseconds&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// print as seconds</span></span><br><span class="line">        cout &lt;&lt; fixed &lt;&lt; <span class="built_in">double</span>(P::num)/P::den &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;- is_steady: &quot;</span> &lt;&lt; boolalpha &lt;&lt; C::is_steady &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;system_clock: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printClockData</span>&lt;std::chrono::system_clock&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nhigh_resolution_clock: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printClockData</span>&lt;std::chrono::high_resolution_clock&gt;();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nsteady_clock: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printClockData</span>&lt;std::chrono::steady_clock&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;。</span><br></pre></td></tr></table></figure><h3 id="示例结果"><a href="#示例结果" class="headerlink" title="示例结果"></a>示例结果</h3><p><img src="/../img/111.png"></p><h1 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h1><hr><h2 id="什么是对象池"><a href="#什么是对象池" class="headerlink" title="什么是对象池"></a>什么是对象池</h2><p>对象池，就是一定数量的已经创建好的对象的集合。当需要创建对象时，先在池子中获取，如果池子里没有符合条件的对象，在创建新的对象。同样，当对象需要销毁时，不做真正的销毁，而是将其setActive(False)，并存入池子中。避免了大量对象的创建。</p><h2 id="对象池解决什么问题"><a href="#对象池解决什么问题" class="headerlink" title="对象池解决什么问题"></a>对象池解决什么问题</h2><p>少频繁创建和销毁对象带来的成本，实现对象的缓存和复用，创建对象的成本比较大，并且创建比较频繁。比如线程的创建代价比较大，于是就有了常用的线程 池。对象池（模式）是一种创建型设计模式，它持有一个初始化好的对象的集合，将对象提供给调用者。</p><h2 id="对象池的优点"><a href="#对象池的优点" class="headerlink" title="对象池的优点"></a>对象池的优点</h2><ol><li>提升了t获取对象的响应速度，比如单个线程和资源连接的创建成本都比较大。</li><li>运用对象池化技术可以显著地提升性能，尤其是当对象的初始化过程代价较大或者频率较高时。</li><li>一定程度上减少了GC的压力。对于实时性要求较高的程序有很大的帮助，比如说 http 链接的对象池，Redis对象池等等都使用了对象池</li></ol><h2 id="对象池的弊端"><a href="#对象池的弊端" class="headerlink" title="对象池的弊端"></a>对象池的弊端</h2><ol><li><p>脏对象的问题</p><p>所谓的脏对象就是指的是当对象被放回对象池后，还保留着刚刚被客户端调用时生成的数据。</p></li><li><p>生命周期的问题</p></li></ol><h2 id="对象池的特征"><a href="#对象池的特征" class="headerlink" title="对象池的特征"></a>对象池的特征</h2><p>一般来说，对象池有以下特征</p><ol><li>有一定数量已经建立好的对象</li><li>对象池向用户提供对象的接口，当用户需要新的对象时，便可通过调用此接口获取新的对象。如果对象池中有事先创建好的对象时，就直接返回给用 户；如果没有了，对象池还可以创建新的对象加入其中，然后返回给用户</li><li>对象池向用户提供归还对象的接口，用户不再使用某对象时，便可通过此接口把该对象归还给对象池</li></ol><h1 id="HANDLE的用法"><a href="#HANDLE的用法" class="headerlink" title="HANDLE的用法"></a>HANDLE的用法</h1><hr><p>Handle:是一个消息分发对象，进行发送和处理消息，并且其Runnable对象与一个线程的MessageQueue关联。</p><p><strong>作用</strong>：调度消息，将一个任务切换到某个指定的线程中执行。</p><h3 id="handle使用场景"><a href="#handle使用场景" class="headerlink" title="handle使用场景"></a>handle使用场景</h3><h4 id="子程序不许访问UI"><a href="#子程序不许访问UI" class="headerlink" title="子程序不许访问UI"></a>子程序不许访问UI</h4><p>假若子线程允许访问UI，则在多线程并发访问情况下，会使得UI控件处于不可预期的状态</p><p>传统解决方法：加锁，但是会使得UI访问逻辑变得复杂，其次降低UI访问效率</p><h4 id="引入Handler"><a href="#引入Handler" class="headerlink" title="引入Handler"></a>引入Handler</h4><p>采用单线程模型处理UI操作，通过Handler切换到UI线程，解决子线程中无法访问UI的问题。</p><h2 id="Handler的使用"><a href="#Handler的使用" class="headerlink" title="Handler的使用"></a>Handler的使用</h2><h4 id="post-Runnable"><a href="#post-Runnable" class="headerlink" title="post(Runnable)"></a>post(Runnable)</h4><p>创建一个工作线程，实现Runnable接口，实现run方法，处理耗时操作</p><p>创建一个Handler，通过Handler.post&#x2F;postDelay，投递创建的Runnable，在run方法中进行更新UI操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">          耗时操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      handler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">                更新UI</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;).start();</span><br></pre></td></tr></table></figure><h4 id="sendMessage-Message"><a href="#sendMessage-Message" class="headerlink" title="sendMessage(Message)"></a>sendMessage(Message)</h4><p>创建一个工作线程，继承Thread，重新run方法，处理耗时操作</p><p>创建一个Message对象，设置what标志及数据</p><p>通过sendMessage进行投递消息</p><p>创建一个handler，重写handMessage方法，根据msg.what信息判断，接收对应的信息，再在这里重新更新UI</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;      <span class="comment">//判断标志位</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 获取数据，更新UI</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">         耗时操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="comment">//从全局池中返回一个message实例，避免多次创建message（如new Message）</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span>Message.obtain();  </span><br><span class="line">        msg.obj = data;</span><br><span class="line">        msg.what=<span class="number">1</span>;   <span class="comment">//标志消息的标志</span></span><br><span class="line">        handler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">WorkThread</span>().start();</span><br></pre></td></tr></table></figure><h1 id="显式化模板实参"><a href="#显式化模板实参" class="headerlink" title="显式化模板实参"></a>显式化模板实参</h1><hr><blockquote><p>在使用一个模板时，额外提供信息，这些信息就是显式化模板实参列表，他们被绑定到模板参数。编译器使用这些实参来实例化</p></blockquote><p>例如一个Poco::SingletonHolder</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Poco::SingletonHolder&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="comment">//就是进行一个int型单例的初始化</span></span><br></pre></td></tr></table></figure><h1 id="std-recursive-mutex"><a href="#std-recursive-mutex" class="headerlink" title="std::recursive_mutex"></a>std::recursive_mutex</h1><hr><p>recursive_mutex锁与mutex锁的区别是，recursive_mutex锁允许已经获得了一个递归互斥体所有权的线程允许在同一个互斥体上再次调用lock()和try_lock()。线程调用unlock()方法的次数应该等于这个递归体获得递归互斥体锁的次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    std::recursive_mutex m;</span><br><span class="line">    std::string shared;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">      shared = <span class="string">&quot;fun1&quot;</span>;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;in fun1, shared variable is now &quot;</span> &lt;&lt; shared &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::recursive_mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">      shared = <span class="string">&quot;fun2&quot;</span>;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;in fun2, shared variable is now &quot;</span> &lt;&lt; shared &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="built_in">fun1</span>(); <span class="comment">// ① 递归锁在此处变得有用</span></span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;back in fun2, shared variable is &quot;</span> &lt;&lt; shared &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(&amp;X::fun1, &amp;x)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(&amp;X::fun2, &amp;x)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Poco-NumberParser"><a href="#Poco-NumberParser" class="headerlink" title="Poco::NumberParser"></a>Poco::NumberParser</h1><hr><blockquote><p>NumberParser类提供静态方法，用于从字符串中解析数字，不允许使用前导或尾随空格</p></blockquote><p>static bool tryParse(const std::string&amp; s,int &amp; value, char thousandSeparator &#x3D;’,’);</p><p>在s字符串内能否找到value的整数，找到返回true，找不到返回false</p><h1 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h1><hr><blockquote><p>C++11提供了一个原子类型std::atomic<T>,通过这个原子类型管理的内部变量就可以称为原子变量，可以提供任何变量作为模板参数。</p></blockquote><p>多线程访问时不用再使用互斥量来保护变量了。</p><p>atomic::store的使用方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">store</span> <span class="params">(T val, memory_order sync = memory_order_seq_cst)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//将会用value替换包含的值，操作是原子的，并遵循sync指定的内存顺序</span></span><br></pre></td></tr></table></figure><p>atomic::load的使用方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">load</span> <span class="params">(memory_order sync = memory_order_seq_cst)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">//返回包含的值</span></span><br></pre></td></tr></table></figure><h1 id="string-npos"><a href="#string-npos" class="headerlink" title="string::npos"></a>string::npos</h1><hr><blockquote><p>npos是一个常数，表示size_t的最大值，许多容器提供这个位置表示不存在的最大值</p></blockquote><h3 id="npos的用法"><a href="#npos的用法" class="headerlink" title="npos的用法"></a>npos的用法</h3><ol><li><p>npos表示string的结束位置，是string::type_size类型的，也就是find()返回的类型。find函数在找不到指定值的情况下会返回string::npos。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string b;</span><br><span class="line">    <span class="built_in">getline</span>(cin,b);</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">127</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(b.<span class="built_in">find</span>(i)!=string::npos)</span><br><span class="line">        count++;</span><br><span class="line">    cout&lt;&lt;count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>string::npos作为string成员函数的一个长度参数时，表示直到字符串结束</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    string filename = <span class="string">&quot;test.cpp&quot;</span>;    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;filename : &quot;</span> &lt;&lt; filename &lt;&lt; endl;    </span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> idx = filename.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>);   <span class="comment">//as a return value    </span></span><br><span class="line">    <span class="keyword">if</span>(idx == string::npos)        </span><br><span class="line">    &#123;    </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;filename does not contain any period!&quot;</span> &lt;&lt; endl;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">    &#123;    </span><br><span class="line">        string tmpname = filename;    </span><br><span class="line">        tmpname.<span class="built_in">replace</span>(idx + <span class="number">1</span>, string::npos, <span class="string">&quot;xxx&quot;</span>); <span class="comment">//string::npos作为长度参数，表示直到字符串结束    </span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;repalce: &quot;</span> &lt;&lt; tmpname &lt;&lt; endl;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><hr><blockquote><p>数据库查询时的通配符</p></blockquote><p>谓词<strong>LIKE</strong>可以用来进行字符串的匹配，其一般的语法格式如下</p><p>[NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE’&lt;换码字符&gt;’]</p><p>其含义是查找指定的属性列值与&lt;匹配串&gt;相匹配的元组，可含有通配符%和_</p><ul><li>%表示任意长度(可为零)的字符串</li><li>_表示任意单个字符</li></ul><h3 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h3><hr><p>每秒传输帧数</p><h1 id="initializer-list详解"><a href="#initializer-list详解" class="headerlink" title="initializer_list详解"></a>initializer_list详解</h1><hr><p>C++11提供的新类型，定义在<initializer_list>头文件中</p><p>首先有了initializer_list之后，对于STL的容器初始化就方便多了，可以使STL容器拥有数组的初始化能力</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooVector</span></span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; content_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooVector</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            content_.<span class="built_in">push_back</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooMap</span></span><br><span class="line">&#123;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; content_;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">pair_t</span> = std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::value_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FooMap</span>(std::initializer_list&lt;<span class="type">pair_t</span>&gt; list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            content_.<span class="built_in">insert</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FooVector foo_1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">FooMap foo_2 = &#123; &#123; <span class="number">1</span>, <span class="number">2</span> &#125;, &#123; <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">5</span>, <span class="number">6</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><h1 id="C-的INL文件"><a href="#C-的INL文件" class="headerlink" title="C++的INL文件"></a>C++的INL文件</h1><hr><p>,INL文件是内连函数的源文件，内联函数一般在头文件中实现，但有时为了别的考虑，也会将文件添加到INL文件中，在头文件的末尾用#include引入。</p><h1 id="SIP协议的总结"><a href="#SIP协议的总结" class="headerlink" title="SIP协议的总结"></a>SIP协议的总结</h1><hr><h2 id="SIP概念"><a href="#SIP概念" class="headerlink" title="SIP概念"></a>SIP概念</h2><p>SIP(会话发起协议)是一个用于建立，更改和终止多媒体会话的应用层控制协议，其中的会话可以是IP电话、多媒体分发及多媒体会议。SIP协议采用Client&#x2F;Server模型，主要通过与Proxy Server之间的通信来完成用户呼叫的建立过程。</p><p> SIP终端通过发送“邀请”消息给会话目的终端，消息中携带了自己的描述信息。目的终端可以根据“邀请”信息和自身的能力接受或拒绝请求。SIP可以通过称为“代理服务器”的实体来转发“邀请”消息。代理服务器可以完成确定目的终端的位置、查找路由的工作，根据会话终端的要求进行认证和授权，还能提供会话终端的呼叫路由策略。SIP通过“注册服务器”记录各终端的描述信息，包括地址信息，路由信息，号码信息等，各SIP终端可以通过发送“注册”消息给注册服务器，以登记或更新其描述信息。</p><p> 另外，SIP作为应用层协议，在传输层上可以使用TCP，也可以使用UDP。SIP可以支持IPv4和IPv6。</p><h2 id="SIP的功能特点"><a href="#SIP的功能特点" class="headerlink" title="SIP的功能特点"></a>SIP的功能特点</h2><ol><li>确定用户位置：确定被叫SIP终端所在的位置。SIP的最强大之处就是用户定位功能。SIP本身含有向注册服务器注册的功能，也可以利用其他定位服务器如DNS、LDAP等提供的定位服务器来增强其定位功能。</li><li>确定用户可用性：确定被叫会话终端是否可以参加此会话。SIP支持多种地址描述和寻址，包括：用户名@主机地址、被叫号码@PSTN网关地址和普通电话号码（如Tel：01012345678）的描述等。这样，SIP主叫按照被叫地址，就可以识别出被叫是否在传统电话网上，然后通过一个与传统电话网相连的网关向被叫发起并建立呼叫。</li><li>确定用户能力：确定被叫终端可用于参加会话的媒体类型及媒体参数。SIP终端在消息交互过程中携带自身的媒体类型和媒体参数，这使得会话都可以明确对方的会话能力。</li><li>建立会话：建立主被叫双方的会话参数。SIP会话双方通过协商媒体类型和媒体参数，最终选择双方都具有的能力建立起会话。</li><li>管理会话：可以更改会话参数或中止会话。</li></ol><h2 id="SIP方法"><a href="#SIP方法" class="headerlink" title="SIP方法"></a>SIP方法</h2><ol><li>REGISTER：注册联系信息。</li><li>INVITE： 初始化一个会话</li><li>ACK： 对INVITE消息的最终响应。</li><li>CANCEL： 终止一个等待处理或正在处理的请求。</li><li>BYE： 终止一个会话。</li><li>OPTIONS： 查询服务器的性能。</li></ol><p>附加方法</p><ol><li>SUBSCRIBE：订阅方法</li><li>NOTIFY： 事件通知方法</li><li>MESSAGE： 即时消息方法</li></ol><h2 id="SIP访问码"><a href="#SIP访问码" class="headerlink" title="SIP访问码"></a>SIP访问码</h2><table><thead><tr><th>1xx</th><th>进展相应</th><th>临时相应</th></tr></thead><tbody><tr><td>2xx</td><td>成功</td><td>最终相应</td></tr><tr><td>3xx</td><td>重定向错误</td><td>最终相应</td></tr><tr><td>4xx</td><td>客户端错误</td><td>最终相应</td></tr><tr><td>5xx</td><td>服务端错误</td><td>最终相应</td></tr><tr><td>6xx</td><td>全局错误</td><td>最终相应</td></tr></tbody></table><h2 id="SIP的请求标题头"><a href="#SIP的请求标题头" class="headerlink" title="SIP的请求标题头"></a>SIP的请求标题头</h2><table><thead><tr><th>Header</th><th>含义说明</th><th>举例</th></tr></thead><tbody><tr><td>Call-ID</td><td>由本地设备(Client)生成，全局唯一，每次呼叫这个值唯一不变</td><td>Call-ID: <a href="mailto:&#x61;&#x73;&#100;&#x38;&#56;&#x61;&#x73;&#100;&#55;&#x37;&#97;&#64;&#49;&#x2e;&#x32;&#46;&#51;&#46;&#52;">&#x61;&#x73;&#100;&#x38;&#56;&#x61;&#x73;&#100;&#55;&#x37;&#97;&#64;&#49;&#x2e;&#x32;&#46;&#51;&#46;&#52;</a></td></tr><tr><td>From</td><td>表示请求的发起者</td><td>From: sip:<a href="mailto:&#117;&#x73;&#x65;&#114;&#49;&#x40;&#100;&#111;&#x6d;&#x61;&#x69;&#110;&#x2e;&#99;&#x6f;&#x6d;">&#117;&#x73;&#x65;&#114;&#49;&#x40;&#100;&#111;&#x6d;&#x61;&#x69;&#110;&#x2e;&#99;&#x6f;&#x6d;</a>;tag&#x3D;49583</td></tr><tr><td>To</td><td>表示请求的接收者</td><td>To: sip:<a href="mailto:&#x75;&#x73;&#x65;&#x72;&#50;&#64;&#100;&#x6f;&#x6d;&#97;&#x69;&#x6e;&#x2e;&#99;&#x6f;&#109;">&#x75;&#x73;&#x65;&#x72;&#50;&#64;&#100;&#x6f;&#x6d;&#97;&#x69;&#x6e;&#x2e;&#99;&#x6f;&#109;</a></td></tr><tr><td>Via</td><td>Via头域是被服务器插入request中，用来检查路由环的，并且可以使response根据via找到返回的路</td><td>Via: SIP&#x2F;2.0&#x2F;TCP user1pc.domain.com;branch&#x3D;z9hG4bK776sgdkse</td></tr><tr><td>Max-Forwards</td><td>用于表示这个包最多可以传送多少跳，每经过一跳都会减一当Max-Forwards&#x3D;&#x3D;0系统会返回483。默认为70</td><td>Max-Forwards: 70</td></tr><tr><td>Contact</td><td>包含源的URI信息，用来给响应方直接和源建立连接用</td><td>Contact: sip:192.168.100.1:1111</td></tr><tr><td>Content-Type</td><td>指明消息体的类型 (SDP会话描述协议)</td><td>Content-Type: text&#x2F;plain；Content-Type: application&#x2F;sdp; Content-Type: application&#x2F;cpim;</td></tr><tr><td>Content-Length</td><td>指明消息体的字节大小</td><td>Content-Length: 18</td></tr></tbody></table><h1 id="Poco-Event"><a href="#Poco-Event" class="headerlink" title="Poco::Event"></a>Poco::Event</h1><hr><blockquote><p>Poco::Event用于多线程之间的同步，</p></blockquote><p>事件是一个同步对象，允许一个线程向一个或者多个线程发出特定事件已经发生的信号。</p><p>通常一个线程发出事件信号，而一个或者多个线程在等待事件信号。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Event</span>(<span class="type">bool</span> autoReset = <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>创建一个事件，如果autoReset是true时，当一个wait()成功返回时，事件会自动复位。</p><h3 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h3><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>发出事件信号，如果autoReset为true，则只有一个等待事件的线程可以恢复执行。</p><p>如果autoReset为false，则所有等待线程都可以恢复执行。</p><h3 id="等待状态"><a href="#等待状态" class="headerlink" title="等待状态"></a>等待状态</h3><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>等待事件发出信号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(<span class="type">long</span> milliseconds)</span></span>;</span><br></pre></td></tr></table></figure><p>等待事件发出信号，如果未在给定事件里发出信号，则抛出一个超时异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">tryWait</span><span class="params">(<span class="type">long</span> milliseconds)</span></span>;</span><br></pre></td></tr></table></figure><p>等待事件信号，如果事件在给定时间内发出信号返回true，否则返回false。</p><h3 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h3><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>将事件重置为没有收到信号前的状态。</p><h1 id="std-memcpy"><a href="#std-memcpy" class="headerlink" title="std::memcpy"></a>std::memcpy</h1><hr><p>定义于头文件<cstring>中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">memcpy</span><span class="params">( <span class="type">void</span>* dest, <span class="type">const</span> <span class="type">void</span>* src, std::<span class="type">size_t</span> count )</span></span>;</span><br></pre></td></tr></table></figure><p>从src所指向的对象复制count个字符到dest所指向的对象。两个对象都将转译成unsigned char的数组。</p><p>若对象重叠，则行为未定义。若dest或者src为非法或空指针则行为未定义。</p><h1 id="ntohl-htonl-函数"><a href="#ntohl-htonl-函数" class="headerlink" title="ntohl() htonl()函数"></a>ntohl() htonl()函数</h1><hr><p>ntohl()将一个无符号长整型数从网络字节顺序转为主机字节顺序，ntohl()返回一个以主机顺序表达的数。</p><p>htonl()将主机数转换成无符号长整型的网络字节顺序。本函数将一个32位数从主机字节序转换成网络字节顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> uint16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>  uint32;</span><br><span class="line"><span class="comment">//短整形高低字节交换</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Swap16(A) ((((uint16)(A) &amp; 0xff00) &gt;&gt; 8) | (((uint16)(A) &amp; 0x00ff) &lt;&lt; 8))</span></span><br><span class="line"><span class="comment">//长整形高低字节交换</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Swap32(A) ((((uint32)(A) &amp; 0xff000000) &gt;&gt; 24) | \</span></span><br><span class="line"><span class="meta">   (((uint32)(A) &amp; 0x00ff0000) &gt;&gt;  8) | \</span></span><br><span class="line"><span class="meta">   (((uint32)(A) &amp; 0x0000ff00) &lt;&lt;  8) | \</span></span><br><span class="line"><span class="meta">   (((uint32)(A) &amp; 0x000000ff) &lt;&lt; 24))</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">union</span> &#123;   </span><br><span class="line">    <span class="type">char</span> c[<span class="number">4</span>];   </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mylong;   </span><br><span class="line">&#125; endian_test = &#123;&#123; <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;b&#x27;</span> &#125; &#125;;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">ENDIANNESS返回结果</span></span><br><span class="line"><span class="comment">l:小端模式</span></span><br><span class="line"><span class="comment">b:打断模式</span></span><br><span class="line"><span class="comment">******************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENDIANNESS ((char)endian_test.mylong)  </span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//将主机的无符号短整形数转换成网络字节顺序</span></span><br><span class="line"><span class="function">uint16 <span class="title">htons</span><span class="params">(uint16 hs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (ENDIANNESS==<span class="string">&#x27;l&#x27;</span>) ? <span class="built_in">Swap16</span>(hs): hs;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将主机的无符号长整形数转换成网络字节顺序</span></span><br><span class="line"><span class="function">uint32 <span class="title">htonl</span><span class="params">(uint32 hl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (ENDIANNESS==<span class="string">&#x27;l&#x27;</span>) ? <span class="built_in">Swap32</span>(hl): hl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将一个无符号短整形数从网络字节顺序转换为主机字节顺序</span></span><br><span class="line"><span class="function">uint16 <span class="title">ntohs</span><span class="params">(uint16 ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (ENDIANNESS==<span class="string">&#x27;l&#x27;</span>) ? <span class="built_in">Swap16</span>(ns): ns;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将一个无符号长整形数从网络字节顺序转换为主机字节顺序</span></span><br><span class="line"><span class="function">uint32 <span class="title">ntohl</span><span class="params">(uint32 nl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (ENDIANNESS==<span class="string">&#x27;l&#x27;</span>) ? <span class="built_in">Swap32</span>(nl): nl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint16 hs=<span class="number">0x1234</span>;</span><br><span class="line">uint32 hl=<span class="number">0x12345678</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; htons(0x%4x) = 0x%4x\n&quot;</span>,hs,<span class="built_in">htons</span>(hs));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ntons(0x%4x) = 0x%4x\n&quot;</span>,hs,<span class="built_in">ntohs</span>(hs));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; htonl(0x%8x) = 0x%8x\n&quot;</span>,hl,<span class="built_in">htonl</span>(hl));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ntohl(0x%8x) = 0x%8x\n&quot;</span>,hl,<span class="built_in">ntohl</span>(hl));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TLV编码格式详解"><a href="#TLV编码格式详解" class="headerlink" title="TLV编码格式详解"></a>TLV编码格式详解</h1><hr><blockquote><p>BER是一种编码规格说明，只有确定了通信协议，才能理解数据含义。BER的数据由三个域构成：标识域(Tag)+长度域(Length)+值域(Value)，简称TLV格式</p></blockquote><ol><li><p>TLV简介</p><p>TLV是一种可变的格式，其中：</p><ul><li>T可以理解为Tag或者Type。用于标识标签或者编码格式信息</li><li>L定义数值的长度</li><li>V表示实际的数值</li></ul><p>T和L的长度固定，V的长度由Length指定</p></li><li><p>字节序</p><p>要正确的解析对方发来的数据除了统一数据格式之外还要统一字节序。字节序是指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。字节序一般分为<strong>大端</strong>和<strong>小端</strong>。</p><p>2.1 大端和小端</p><p>大端模式：高位字节放在内存的低地地址，低位字节存放在内存的高位位置。</p><p>小端模式：低位字节放在内存的低地址端，高位字节放在内存的高地址端。</p><p>2.2 网络字节序</p><p>网络字节序是TCP&#x2F;IP中规定好的一种数据表示格式，它与具体的CPU类型，操作系统等无关，从而可以保证数据在不同主句之间传输数据时能够被正确解释，网络字节大端序</p><p>为了进行转换，使用四个数据</p><ul><li>htons 把unsigned short类型从主机序转换到网络序</li><li>htonl 把unsigned long类型从主机序转换到网络序</li><li>ntohs 把unsigned short类型从网络序转换到主机序</li><li>ntohl 把unsigned long类型从网络序转换到主机序</li></ul></li><li><p>解编码</p><p>假设Tag(或Type)和Length都是四个字节表示</p><p>3.1 编码步骤</p><ol><li>使用htonl将Tag（或Type）转成网络字节序，指针偏移 4；</li><li>使用 <strong>htonl</strong> 将 Length 转成网络字节序，指针偏移 4；</li><li>若值 Value 为 int、char、short、long 类型，将其转为网络字节序，指针偏移；若值为字符串，写入后指针偏移 Length；</li><li>重复上述三步，继续编码后面的 TLV 单元。</li></ol><p>3.2 解码步骤</p><ol><li>读取 Tag（或Type）并使用 <strong>ntohl</strong> 将其转成主机字节序，指针偏移4；</li><li>读取 Length ntohl** 将其转成主机字节序，指针偏移4；</li><li>根据得到的长度读取 Value，若为 int、char、short、long 类型，将其转为主机字节序，指针偏移；若值为字符串，读取后指针偏移 Length；</li><li>重复上述三步，继续读取后面的 TLV 单元。</li></ol></li></ol><hr><h1 id="日志的几个等级"><a href="#日志的几个等级" class="headerlink" title="日志的几个等级"></a>日志的几个等级</h1><hr><ol><li>ALL：打开所有的日志</li><li>TRACE：级别很低的日志，一般不会用</li><li>DEBUG：开发过程中的运行信息</li><li>INFO：打印感兴趣的信息</li><li>WARN：潜在错误</li><li>ERROR：虽然发生错误信息，仍不影响系统的继续运行</li><li>FATAL：指出每个严重的错误事件将会导致应用程序的退出</li><li>OFF：最高等级的，关闭所有日志</li></ol><h1 id="atomic-store"><a href="#atomic-store" class="headerlink" title="atomic_store"></a>atomic_store</h1><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">atomic_store</span> <span class="params">(<span class="keyword">volatile</span> atomic&lt;T&gt;* obj, T val)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">atomic_store</span> <span class="params">(atomic&lt;T&gt;* obj, T val)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>修改包含的值，将obj中包含的值替换为val。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;kbps&quot;&gt;&lt;a href=&quot;#kbps&quot; class=&quot;headerlink&quot; title=&quot;kbps&quot;&gt;&lt;/a&gt;kbps&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;比特率单位(千比特每秒),又称千比特率,指的是数字信号的传输速率，也就是每秒钟传输多少个</summary>
      
    
    
    
    <category term="琐碎知识" scheme="http://example.com/categories/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="基础知识" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>9.7</title>
    <link href="http://example.com/posts/31628/"/>
    <id>http://example.com/posts/31628/</id>
    <published>2022-09-14T14:49:22.000Z</published>
    <updated>2023-08-24T12:48:58.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Poco-NotificationCenter"><a href="#Poco-NotificationCenter" class="headerlink" title="Poco::NotificationCenter"></a>Poco::NotificationCenter</h1><hr><blockquote><p>NotificationCenter本质上是一个通知调度器。</p></blockquote><p>它通知所有复合特殊标准的观察者，这个信息封装在通知对象中。客户端对象向通知中心注册，作为其他对象发布特定通知的观察者。当事件发生时，对象将向通知中心发布适当的通知。通知在每个匹配的观察者上调用注册的方法，将通知作为参数传递。</p><p>观察员接收通知的顺序未定义，发出信息的对象和观察对象可以相同，NotificationCenter同步向观察者发送通知。换句话说，postNotification()方法不会返回，直到所有观察者接收并处理通知。如果观察者在处理通知时抛出异常，则NotificationCenter停止发送通知，postNotification()重新引发异常。</p><p>在多线程中，通知总是在发布通知的线程中传递，这可能不是观察者注册自己的线程。</p><h3 id="函数一览"><a href="#函数一览" class="headerlink" title="函数一览"></a>函数一览</h3><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NotificationCenter</span>();</span><br></pre></td></tr></table></figure><p>创建一个NotificationCenter</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addObserver</span><span class="params">(<span class="type">const</span> AbstractObserver&amp; observer)</span></span>;</span><br></pre></td></tr></table></figure><p>向NotificationCenter注册观察者，用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Observer&lt;MyClass, MyNotification&gt; <span class="title">obs</span><span class="params">(*<span class="keyword">this</span>, &amp;MyClass::handleNotification)</span></span>;</span><br><span class="line">notificationCenter.<span class="built_in">addObserver</span>(obs);</span><br></pre></td></tr></table></figure><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasObserver</span><span class="params">(<span class="type">const</span> AbstractObserver&amp; observer)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>如果观察者向这个Notification注册过就返回true</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postNotification</span><span class="params">(Notification::Ptr pNotification)</span></span>;</span><br></pre></td></tr></table></figure><p>向NotificationCenter发送通知，然后通知中心发送通知致所有感兴趣的观察员。如果观察者抛出异常，则调度终止，并且异常重新提交给调用方。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasObservers</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>如果最少有一个观察者返回true，可以在发送大型数据前调用。</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">countObservers</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>返回观察者的数量</p><hr><h1 id="reinterpret-cast与static-cast"><a href="#reinterpret-cast与static-cast" class="headerlink" title="reinterpret_cast与static_cast"></a>reinterpret_cast与static_cast</h1><hr><p><strong>reinterpret_cast<new_type>(expression)</strong></p><p>reinterpret_cast运算符是用来处理无关类型之间的转换：它会产生一个新的值，这个值会有与原始参数有完全相同的比特位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *p;</span><br><span class="line"><span class="comment">// 将地址 0x5800FF 付给指针 p</span></span><br><span class="line">p = <span class="built_in">reinterpret_cast</span>&lt; <span class="type">void</span>* &gt; (<span class="number">0x5800FF</span>);</span><br></pre></td></tr></table></figure><h1 id="SIP"><a href="#SIP" class="headerlink" title="SIP"></a>SIP</h1><hr><blockquote><p>会话发起协议</p></blockquote><p>SIP(Session initialization Protocol,会话初始协议)是由IETF(Internet Engineering Task Force,因特网工程任务组)制定的多媒体通信协议。</p><p>它是由一个基于文本的应用层控制协议，用于创建，修改和释放一个或者多个参与者的会话。SIP是一种原语互联网的IP语音会话控制协议，具有灵活，易于实现，便于扩展的特点。</p><h1 id="卫语句"><a href="#卫语句" class="headerlink" title="卫语句"></a>卫语句</h1><hr><blockquote><p>卫语句是一种改善嵌套代码的优化代码，将复杂的条件表达式拆分成多个条件表达式，减少嵌套。嵌套了好几层的if-else语句，转为多个if语句，实现它的逻辑，这多条的if语句就是卫语句。</p></blockquote><p>卫语句即代码逻辑优先考虑失败，异常，中断，退出等直接返回的情况。</p><p>复杂嵌套</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(boolean condition, <span class="type">int</span> aPara, <span class="type">int</span> bPara)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="comment">// TODO #1</span></span><br><span class="line">        <span class="keyword">if</span> (aPara &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// TODO #2</span></span><br><span class="line">            <span class="keyword">return</span> aPara;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO #3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO #4</span></span><br><span class="line">    <span class="keyword">return</span> bPara;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>卫语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(boolean condition, <span class="type">int</span> aPara, <span class="type">int</span> bPara)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!condition) &#123; <span class="comment">// 注意：此处将上面的条件进行了取反</span></span><br><span class="line">        <span class="comment">// TODO #4</span></span><br><span class="line">        <span class="keyword">return</span> bPara;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO #1</span></span><br><span class="line">    <span class="keyword">if</span> (aPara &lt;= <span class="number">0</span>) &#123; <span class="comment">// 注意：此处将上面的条件进行了取反</span></span><br><span class="line">        <span class="comment">// TODO #3</span></span><br><span class="line">        <span class="comment">// TODO #4 // 注意：此处也是 #4</span></span><br><span class="line">        <span class="keyword">return</span> bPara; <span class="comment">// 注意：此处将上面的返回值进行了变换</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO #2</span></span><br><span class="line">    <span class="keyword">return</span> aPara; <span class="comment">// 注意：此处将上面的返回值进行了变换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="atomic-load"><a href="#atomic-load" class="headerlink" title="atomic_load"></a>atomic_load</h1><hr><blockquote><p>作用，返回obj中包含的值</p></blockquote><p>该操作使用顺序一致性，返回对象所包含的值。</p><h1 id="Poco-ScopedLock"><a href="#Poco-ScopedLock" class="headerlink" title="Poco::ScopedLock"></a>Poco::ScopedLock</h1><hr><p>一个使用互斥体简化线程同步的类</p><p>构造器接收互斥量并加锁（以及可选的以毫秒为单位的超时值），析构函数进行解锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Poco-NotificationCenter&quot;&gt;&lt;a href=&quot;#Poco-NotificationCenter&quot; class=&quot;headerlink&quot; title=&quot;Poco::NotificationCenter&quot;&gt;&lt;/a&gt;Poco::Notificati</summary>
      
    
    
    
    <category term="琐碎知识" scheme="http://example.com/categories/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="基础知识" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java开发规范</title>
    <link href="http://example.com/posts/18835/"/>
    <id>http://example.com/posts/18835/</id>
    <published>2022-09-14T14:36:31.000Z</published>
    <updated>2023-08-24T12:31:49.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h1><hr><h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><hr><ol><li>DO(Data Object):与数据库表结构一一对应，通过DAO层向上传输数据源对象。</li><li>DTO(Data Transfer Object):数据传输对象，service和Manager向外传输的对象。</li><li>BO(Business Object):业务对象，可以由Service层输出的封装业务逻辑的对象。</li><li>Query:数据查询对象，各层就收上层的查询请求，超过两个参数的查询的封装，禁止使用map类传输</li><li>VO(View Object): 显示层对象，通常是Web向模板渲染引擎层传输的对象。</li></ol><h2 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h2><hr><ol><li><p>【强制】代码中的命名均不能以下划线或者美元符号开始，也不能以下划线或者美元符号结束</p></li><li><p>【强制】代码中的命名严禁用拼音与英文混合的方式，更不允许直接使用中文的方式。说明：正确的英文拼写和语法可以让阅读者更易于理解，避免歧义。注意：纯拼音命名方式也要避免采用。</p></li><li><p>【强制】类名使用UpperCamelCase风格，必须遵循驼峰形式，但是以下形式除外：DO&#x2F;BO&#x2F;DTO&#x2F;VO&#x2F;AO</p></li><li><p>【强制】方法名，参数名，成员变量，局部变量都统一使用lowerCamelCase风格，必须遵循驼峰形式。</p></li><li><p>【强制】常量名全部大写，单词用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</p></li><li><p>【强制】抽象类命名使用Abstract或者Base开头：异常类使用Exception结尾：测试类命名以他要测试的类的名称开始，以Test结尾。</p></li><li><p>【强制】中括号是数组类型的一部分，数组定义如下：String[] args.</p></li><li><p>【强制】POJO类中布尔类型的变量，都不加is，否则部分框架解析会引起序列化错误。</p></li><li><p>【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词，报名统一使用单数形式，若类名有复数定义，类名可以使用复数形式。</p></li><li><p>【强制】杜绝完全不规范的缩写，避免望文不知义</p></li><li><p>【推荐】如果在类名中使用了设计模式，建议在类名中体现出具体模式。</p></li><li><p>【推荐】接口类中的方法和属性不要加任何修饰符号(<code>public</code> 也不要加)，保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。</p></li><li><p>接口和实现类的命名有两套规则</p><ul><li>【强制】对于Service和DAO类，基于SOA的概念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别。</li><li>【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是-able的形式）</li></ul></li><li><p>【参考】枚举类型名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线进行隔开。</p><p>说明：枚举其实就是特殊的常量类，且构成方法被默认强制私有。</p></li><li><p>【参考】各层命名规则</p><ul><li><p>Service&#x2F;DAO层方法命名规约</p><p>获取单个对象的方法用get做前缀</p><p>获取多个对象的方法用list做前缀</p><p>获取统计值的方法用count做前缀</p><p>插入方法用save(推荐)或insert做前缀</p><p>删除的方法用remove或delete做前缀</p><p>修改的方法用update做前缀</p></li><li><p>领域模型命名规则</p><p>数据对象：xxxDO，xxx为表明</p><p>数据传输对象：xxxDTO，xxx为业务领域相关的名称</p><p>展示对象：xxxVO，xxx为网页名称</p><p>POJO是统称：禁止命名成POJO</p></li></ul></li></ol><h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><hr><ol><li><p>【强制】不允许任何魔法值(即未经定义的常量)直接出现在代码中。</p></li><li><p>【强制】long或者Long初始赋值时，必须使用大写的L，而不能是小写的l，小写容易跟数字1混淆，造成误解。</p></li><li><p>【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：CacheConsts下；系统配置相关的常量放在类：ConfigConsts下。</p><p>说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。</p></li><li><p>【推荐】常量的复用层次有五层：跨应用共享常量，应用内存共享常量，子工程共享常量，包内共享常量，类内共享常量。</p><ul><li>跨应用共享常量：放在二方库中</li><li>应用内共享常量：放置在一方库的modules中的constant目录下</li><li>子工程内部共享常量：在子工程的constant下</li><li>包内共享常量：即在当前包下单独的constant目录下</li><li>类内共享常量</li></ul></li><li><p>【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。</p></li></ol><h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><hr><ol><li><p>【强制】大括号的使用约定。如果大括号内为空，则简洁的写成{}即可，不需要换行；如果是非空代码块则：</p><ul><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>右大括号后还有else等代码则不换行；表示终止的大括号后必换行</li></ul></li><li><p>【强制】左小括号和字符之间不出现空格，同样，右小括号和字符之间也不出现空格</p></li><li><p>【强制】for&#x2F;if&#x2F;while&#x2F;switch&#x2F;do等保留字与括号之间都需要加一个空格。</p></li><li><p>【强制】任何二目，三目运算符两边都需要加一个空格</p><p>说明：运算符包括赋值运算符&#x3D;，逻辑运算符&amp;&amp;，加减乘除符号等</p></li><li><p>【强制】缩进采用4个空格，禁止使用tab字符</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">// 缩进 4 个空格</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">say</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">     <span class="comment">// 运算符的左右必须有一个空格</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="comment">// 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格</span></span><br><span class="line">     <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">         System.out.println(say);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 左大括号前加空格且不换行；左大括号后换行</span></span><br><span class="line">     <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">     <span class="comment">// 右大括号前换行，右大括号后有 else，不用换行</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">     <span class="comment">// 在右大括号后直接结束，则必须换行</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><ol start="6"><li><p>【强制】单行字符限制不能超过120个，超出需要换行，换行时遵循如下原则：</p><ul><li>第二行相对第一行缩进4个空格，从第三行开始，不再继续缩进，参考示例</li><li>运算符和上下文一起换行</li><li>方法调用的点符号和下文一起换行</li><li>在多个超长参数时，在逗号后换行</li><li>在逗号前不要换行</li></ul></li><li><p>【强制】方法参数在定义和传入时，多个参数逗号后必定加空格</p></li><li><p>【强制】IDE的text file encoding设置为UTF-8；IDE中文件的换行符使用Unix格式，不要使用windows格式。</p></li><li><p>【推荐】没有必要增加若干空格来是某一行的字符与上一行对应位置的字符对齐。</p><p>在变量比较多的情况下很累赘</p></li><li><p>【推荐】方法体内的执行语句组，变量的定义语句组，不同的业务逻辑或者不同的语义之间插入一个空行，相同业务逻辑和语义之间不需要插入空行</p><p>说明：没必要插入多个空行进行隔开</p></li></ol><h2 id="OOP约束-面向对象"><a href="#OOP约束-面向对象" class="headerlink" title="OOP约束(面向对象)"></a>OOP约束(面向对象)</h2><hr><ol><li><p>【强制】避免通过一个类的对象引用访问此类的静态变量或者静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</p></li><li><p>【强制】所有的覆写方法，必须加override进行注解</p><p>说明：getObject() 与 get0bject() 的问题。一个是字母的 O，一个是数字的 0，加 @Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</p></li><li><p>【强制】相同参数类型，相同的业务含义，才可以使用可变参数</p></li><li><p>【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方法产生影响，通过接口时必须添加deprecated(C++14)，并清晰的说明新接口或者服务是什么？</p></li><li><p>【强制】不能使用过时的类或者方法</p></li><li><p>【推荐】当一个类拥有多个构造方法，或者多个同名方法，应该按顺序放在一起</p></li><li><p>【强制】构造方法里禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中</p></li><li><p>【推荐】final可以声明类，成员变量，方法，以及本地变量，下列情况使用final关键字：</p><ul><li>不允许被继承的类</li><li>不允许修改引用的域对象</li><li>不允许被重写的方法</li><li>不允许在运行过程中重新赋值的局部变量</li><li>避免上下文重复使用同一个变量</li></ul></li><li><p>【推荐】类成员与方法的访问控制从严</p></li></ol><h2 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h2><hr><ol><li><p>【强制】关于hashCode和equals的处理，遵循如下规则：</p><ul><li><p>只要重写equals，就必须重写hashCode</p></li><li><p>因为Set存储的是不重复的对象，根据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法</p></li><li><p>如果自定义对象作为Map的键，那么必须重写hashCode和equals</p><p><strong>说明</strong>：String重写了hashCode和equals方法，所以可以用String对象作为key来使用</p></li></ul></li><li><p>【强制】 在 subList场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增 加、删除均产生 ConcurrentModificationException异常。</p></li><li><p>【推荐】集合初始化时，指定集合初始大小</p></li><li><p>【推荐】高度注意 Map 类集合 K&#x2F;V 能不能存储 null 值的情况，如下表格</p></li><li><p>【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。</p></li><li><p>【参考】利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains</code> 方法进行遍历、对比、去重操作。</p></li></ol><hr><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><hr><ol><li><p>【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全</p><p>说明：资源驱动类，工具类，单例工程类都需要注意。</p></li><li><p>【强制】创建线程或线程池是请指定有意义的线程名称，方便出错时回溯</p></li><li><p>【强制】线程资源必须通过线程池提供，不允许在应用中自行显示创建线程</p><p>说明：使用线程池的好处是减少在创建和销毁线程上所花费的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者过度切换的问题。</p></li><li><p>【强制】线程池不允许使用Executors去创造，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的童鞋更加清晰线程池的运行规则，避免资源耗尽的风险。</p></li><li><p>【强制】高并发时，同步调用应该去考虑锁的性能消耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</p><p><strong>说明</strong>：尽可能使加锁的代码块工作量尽可能小，避免在锁代码块中调用RPC方法。</p></li><li><p>【强制】对多个资源，数据库表，对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</p><p><strong>说明</strong>：线程需要一对表A，B，C依次全部加锁后才能进行更新操作，那么线程二的加锁顺序也必须是A，B，C，否则会出现死锁。</p></li><li><p>【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据。</p><p><strong>说明</strong>：如果每次访问冲突率小于20%，推荐使用乐观锁，否则使用悲观锁，乐观锁的重试次数不得小于三次</p></li><li><p>【强制】多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其他任务就会自动终止运行，使用ScheduledExecutorService则没有这个问题。</p></li><li><p>【推荐】使用CountDownLatch进行异步转同步操作。每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法可以执行，避免主线程无法执行至await方法，知道超过时才返回结果。</p><p><strong>说明</strong>：注意，子线程抛出异常堆栈，不能在主线程try-catch到</p></li><li><p>【推荐】避免Random实例被多线程使用，虽然共享该实例线程是安全的，但是会因竞争同一seed导师性能下降</p></li><li><p>【推荐】在并发场景下，通过双检查锁实现延迟初始化的优化问题隐患</p></li></ol><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><hr><ol><li><p>【强制】在一个switch块内，每个case要么通过break&#x2F;return来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch内，都必须包含一个default语句并放在最后，即使什么代码也没有。</p></li><li><p>【强制】在if&#x2F;else&#x2F;while&#x2F;do语句中必须使用大括号，即使只有一行代码，避免使用单行的形式</p></li><li><p>【推荐】表达异常的分支时，少用if-else方式，可以改写成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line"> ...</span><br><span class="line"> return obj;</span><br><span class="line">&#125;</span><br><span class="line">// 接着写 else 的业务逻辑代码;</span><br></pre></td></tr></table></figure><p>超过3层的if-else代码里可以使用卫语句，或者状态模式实现</p></li><li><p>【推荐】除常用方法外，不要再条件判断语句中执行复杂的语句，将复杂的逻辑判断结果赋给一个有意义的布尔变量名，提高可读性。</p></li><li><p>【推荐】循环体内的语句要靠考虑性能，以下操作尽量移至循环体外处理，如定义对象，变量，获取数据库连接，进行不必要的try-catch</p></li></ol><h2 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h2><ol><li><p>【强制】所有的抽象方法(包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。<br><strong>说明</strong> :  对子类的实现要求，或者调用注意事项，请一并说明。</p></li><li><p>【强制】所有的类都必须添加创建者和创建日期。</p></li><li><p>【强制】方法内部单行注释，在被注释语句上方另起一行，使用 &#x2F;&#x2F;注释。方法内部多行注释使用&#x2F;* *&#x2F;注释，注意与代码对齐。</p></li><li><p>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p></li><li><p>【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。<br><strong>反例</strong> :  “TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。</p></li><li><p>【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。<br><strong>说明</strong> :  代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后， 就失去了导航的意义。</p></li><li><p>【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。<br><strong>说明</strong> :  代码被注释掉有两种可能性: 1)后续会恢复此段代码逻辑。2)永久不用。前者如果没 有备注信息，难以知晓注释动机。后者建议直接删掉(代码仓库保存了历史代码)。</p></li><li><p>【参考】对于注释的要求: 第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。</p></li><li><p>【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端: 过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。<br><strong>反例</strong> :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// put elephant into fridge</span><br><span class="line">put(elephant, fridge);</span><br><span class="line">  </span><br><span class="line">        @pdai: 代码已经复制到剪贴板</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。</p></li><li><p>【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。</p><ol><li>待办事宜(TODO)😦 标记人，标记时间，[预计处理时间])表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法(因为它是一个 Javadoc 标签)。</li><li>错误，不能工作(FIXME):(标记人，标记时间，[预计处理时间])在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。</li></ol></li></ol><h3 id="¶-其他"><a href="#¶-其他" class="headerlink" title="¶ 其他"></a><a href="#%E5%85%B6%E4%BB%96">¶</a> 其他</h3><ol><li>【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。 说明: 不要在方法体内定义: <code>Pattern pattern = Pattern.compile(规则);</code></li><li>【强制】<code>velocity</code> 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量(boolean 命名不需要加 is前缀)，会自动调用 isXxx()方法。<br><strong>说明</strong> :  注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。</li><li>【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。<br><strong>说明</strong> :  如果 <code>var=null</code> 或者不存在，那么${var}会直接显示在页面上。</li><li>【强制】注意 <code>Math.random()</code> 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1(能够取到零值，注意除零异常)，如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</li><li>【强制】获取当前毫秒数 <code>System.currentTimeMillis()</code>; 而不是 <code>new Date().getTime()</code>;<br><strong>说明</strong> :  如果想获取更加精确的纳秒级时间值，使用 System.nanoTime()的方式。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。</li><li>【推荐】不要在视图模板中加入任何复杂的逻辑。 <strong>说明</strong> :  根据 MVC 理论，视图的职责是展示，不要抢模型和控制器的活。</li><li>【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</li><li>【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。</li></ol><h2 id="¶-异常日志"><a href="#¶-异常日志" class="headerlink" title="¶ 异常日志"></a><a href="#%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97">¶</a> 异常日志</h2><h3 id="¶-异常处理"><a href="#¶-异常处理" class="headerlink" title="¶ 异常处理"></a><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">¶</a> 异常处理</h3><ol><li>【强制】Java 类库中定义的一类 RuntimeException 可以通过预先检查进行规避，而不应该通过 catch 来处理，比如:  <code>IndexOutOfBoundsException</code> ， <code>NullPointerException</code> 等等。<br><strong>说明</strong> :  无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过 catch NumberFormatException 来实现。<br><strong>正例</strong> : <code>if (obj != null) &#123;...&#125;</code><br><strong>反例</strong> :  <code>try &#123; obj.method() &#125; catch (NullPointerException e) &#123;...&#125;</code></li><li>【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。</li><li>【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。</li><li>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</li><li>【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。</li><li>【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。<br><strong>说明</strong> :  如果 JDK7 及以上，可以使用 try-with-resources 方式。</li><li>【强制】不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。</li><li>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。<br><strong>说明</strong> :  如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</li><li>【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。<br><strong>说明</strong> :  本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。</li><li>【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景:<br> 1)返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。<br> <strong>反例</strong> :  <code>public int f() &#123; return Integer 对象&#125;</code>， 如果为 null，自动解箱抛 NPE。<br> \2) 数据库的查询结果可能为 null。<br> \3) 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。<br> \4) 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。<br> \5) 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。<br> \6) 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。<br> <strong>正例</strong> : 使用 JDK8 的 Optional 类来防止 NPE 问题。</li><li>【推荐】定义时区分 unchecked &#x2F; checked 异常，避免直接抛出 <code>new RuntimeException()</code>，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如: DAOException &#x2F; ServiceException 等。</li><li>【参考】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http&#x2F;api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息”。<br> <strong>说明</strong> :  关于 RPC 方法返回方式使用 Result 方式的理由:<br> 1)使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。<br> 2)如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</li><li>【参考】避免出现重复的代码(Don’t Repeat Yourself)，即 DRY 原则。<br> <strong>说明</strong> :  随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。<br> <strong>正例</strong> : 一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取: <code>private boolean checkParam(DTO dto) &#123;...&#125;</code></li></ol><h3 id="¶-日志规约"><a href="#¶-日志规约" class="headerlink" title="¶ 日志规约"></a><a href="#%E6%97%A5%E5%BF%97%E8%A7%84%E7%BA%A6">¶</a> 日志规约</h3><ol><li><p>【强制】应用中不可直接使用日志系统(Log4j、Logback)中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">private static final Logger logger = LoggerFactory.getLogger(Abc.class);</span><br><span class="line"> </span><br><span class="line">       @pdai: 代码已经复制到剪贴板</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。</p></li><li><p>【强制】应用中的扩展日志(如打点、临时监控、访问日志等)命名方式: appName_logType_logName.log。logType:日志类型，推荐分类有 stats&#x2F;desc&#x2F;monitor&#x2F;visit 等；logName:日志描述。这种命名的好处: 通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。<br><strong>正例</strong> : mppserver 应用中单独监控时区转换异常，如:  mppserver_monitor_timeZoneConvert.log<br><strong>说明</strong> :  推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于 通过日志对系统进行及时监控。</p></li><li><p>【强制】对 trace&#x2F;debug&#x2F;info 级别的日志输出，必须使用条件输出形式或者使用占位符的方 式。<br><strong>说明</strong> :  logger.debug(“Processing trade with id: “ + id + “ symbol: “ + symbol);如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString() 方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。<br><strong>正例</strong> : (条件)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(&quot;Processing trade with id: &quot; + id + &quot; symbol: &quot; + symbol);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">       @pdai: 代码已经复制到剪贴板</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p><strong>正例</strong> : (占位符)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(&quot;Processing trade with id: &#123;&#125; symbol : &#123;&#125; &quot;, id, symbol);</span><br><span class="line"> </span><br><span class="line">       @pdai: 代码已经复制到剪贴板</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity&#x3D;false。<br><strong>正例</strong> : <code>&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt;</code></p></li><li><p>【强制】异常信息应该包括两类信息: 案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。<br><strong>正例</strong> : logger.error(各类参数或者对象 toString + “_” + e.getMessage(), e);</p></li><li><p>【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘 撑爆，并记得及时删除这些观察日志。<br><strong>说明</strong> :  大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考: 这些日志真的有人看吗? 看到这条日志你能做什么? 能不能给问题排查带来好处?</p></li><li><p>【参考】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。</p></li></ol><h2 id="¶-MYSQL-数据库"><a href="#¶-MYSQL-数据库" class="headerlink" title="¶ MYSQL 数据库"></a><a href="#mysql-%E6%95%B0%E6%8D%AE%E5%BA%93">¶</a> MYSQL 数据库</h2><h3 id="¶-建表规约"><a href="#¶-建表规约" class="headerlink" title="¶ 建表规约"></a><a href="#%E5%BB%BA%E8%A1%A8%E8%A7%84%E7%BA%A6">¶</a> 建表规约</h3><ol><li>【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint( 1 表示是，0 表示否)。<br><strong>说明</strong> :  任何字段如果为非负数，必须是 unsigned。<br><strong>正例</strong> : 表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</li><li>【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。<br><strong>正例</strong> : getter_admin，task_config，level3_name<br><strong>反例</strong> :  GetterAdmin，taskConfig，level_3_name</li><li>【强制】表名不使用复数名词。<br><strong>说明</strong> :  表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。</li><li>【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</li><li>【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。<br><strong>说明</strong> :  pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</li><li>【强制】小数类型为 decimal，禁止使用 float 和 double。<br><strong>说明</strong> :  float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</li><li>【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</li><li>【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</li><li>【强制】表必备三字段: id, gmt_create, gmt_modified。 <strong>说明</strong> :  其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 date_time 类型。</li><li>【推荐】表的命名最好是加上“业务名称_表的作用”。<br> <strong>正例</strong> : tiger_task &#x2F; tiger_reader &#x2F; mpp_config</li><li>【推荐】库名与应用名称尽量一致。</li><li>【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</li><li>【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循:<br> 1)不是频繁修改的字段。<br> 2)不是 varchar 超长字段，更不能是 text 字段。<br> <strong>正例</strong> : 商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存 储类目名称，避免关联查询。</li><li>【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。<br> <strong>说明</strong> :  如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</li><li>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。<br> <strong>正例</strong> : 如下表，其中无符号值可以避免误存负数，且扩大了表示范围。</li></ol><table><thead><tr><th align="left">对象</th><th align="left">年龄区间</th><th align="left">类型</th><th align="left">表示范围</th></tr></thead><tbody><tr><td align="left">人</td><td align="left">150 岁之内</td><td align="left">unsigned tinyint</td><td align="left">无符号值: 0 到 255</td></tr><tr><td align="left">龟</td><td align="left">数百岁</td><td align="left">unsigned smallint</td><td align="left">无符号值: 0 到 65535</td></tr><tr><td align="left">恐龙化石</td><td align="left">数千万年</td><td align="left">unsigned int</td><td align="left">无符号值: 0 到约 42.9 亿</td></tr><tr><td align="left">太阳</td><td align="left">约 50 亿年</td><td align="left">unsigned bigint</td><td align="left">无符号值: 0 到约 10 的 19 次方</td></tr></tbody></table><h3 id="¶-索引规约"><a href="#¶-索引规约" class="headerlink" title="¶ 索引规约"></a><a href="#%E7%B4%A2%E5%BC%95%E8%A7%84%E7%BA%A6">¶</a> 索引规约</h3><ol><li>【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 说明: 不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</li><li>【强制】 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。<br><strong>说明</strong> :  即使双表 join 也要注意表索引、SQL 性能。</li><li>【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。<br><strong>说明</strong> :  索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))&#x2F;count(*)的区分度来确定。</li><li>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。<br><strong>说明</strong> :  索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</li><li>【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。<br><strong>正例</strong> : where a&#x3D;? and b&#x3D;? order by c; 索引: a_b_c<br><strong>反例</strong> :  索引中有范围查找，那么索引有序性无法利用，如: WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。</li><li>【推荐】利用覆盖索引来进行查询操作，避免回表。<br><strong>说明</strong> :  如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗? 目录浏览一下就好，这个目录就是起到覆盖索引的作用。<br><strong>正例</strong> : 能够建立索引的种类: 主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种 效果，用 explain 的结果，extra 列会出现: using index。</li><li>【推荐】利用延迟关联或者子查询优化超多分页场景。<br><strong>说明</strong> :  MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。<br><strong>正例</strong> : 先快速定位需要获取的 id 段，然后再关联: SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id&#x3D;b.id</li><li>【推荐】SQL 性能优化的目标: 至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。<br><strong>说明</strong> :<br>\1) consts 单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据。<br>\2) ref 指的是使用普通的索引(normal index)。<br>\3) range 对索引进行范围检索。<br><strong>反例</strong> :  explain 表的结果，type&#x3D;index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。</li><li>【推荐】建组合索引的时候，区分度最高的在最左边。<br><strong>正例</strong> : 如果 where a&#x3D;? and b&#x3D;? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。<br><strong>说明</strong> :  存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如: where a&gt;? and b&#x3D;? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。</li><li>【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。</li><li>【参考】创建索引时避免有如下极端误解:<br> 1)宁滥勿缺。误认为一个查询就需要建一个索引。<br> 2)宁缺勿滥。误认为索引会消耗空间、严重拖慢更新和新增速度。<br> 3)抵制惟一索引。误认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</li></ol><h3 id="¶-SQL-语句"><a href="#¶-SQL-语句" class="headerlink" title="¶ SQL 语句"></a><a href="#sql-%E8%AF%AD%E5%8F%A5">¶</a> SQL 语句</h3><ol><li>【强制】不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。<br><strong>说明</strong> :  count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</li><li>【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</li><li>【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。<br><strong>正例</strong> : 可以使用如下方式来避免 sum 的 NPE 问题: SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;</li><li>【强制】使用 ISNULL()来判断是否为 NULL 值。注意: NULL 与任何值的直接比较都为 NULL。<br><strong>说明</strong> :</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) NULL&lt;&gt;NULL 的返回结果是 NULL，而不是 <span class="literal">false</span>。  </span><br><span class="line"><span class="number">2</span>) NULL=NULL 的返回结果是 NULL，而不是 <span class="literal">true</span>。  </span><br><span class="line"><span class="number">3</span>) NULL&lt;&gt;<span class="number">1</span> 的返回结果是 NULL，而不是 <span class="literal">true</span>。  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@pdai</span>: 代码已经复制到剪贴板</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</li><li>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。<br><strong>说明</strong> :  (概念解释)学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</li><li>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</li><li>【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。</li><li>【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。</li><li>【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。<br><strong>说明</strong> :<br>SELECT LENGTH(“轻松工作”)； 返回为 12<br>SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为 4<br>如果要使用表情，那么使用 utfmb4 来进行存储，注意它与 utf-8 编码的区别。</li><li>【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。<br><strong>说明</strong> :  TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</li></ol><h3 id="¶-ORM-映射"><a href="#¶-ORM-映射" class="headerlink" title="¶ ORM 映射"></a><a href="#orm-%E6%98%A0%E5%B0%84">¶</a> ORM 映射</h3><ol><li><p>【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。<br><strong>说明</strong> :  1)增加查询分析器解析成本。2)增减字段容易与 resultMap 配置不一致。</p></li><li><p>【强制】POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。<br><strong>说明</strong> :  参见定义 POJO 类以及数据库字段定义规定，在<code>&lt;resultMap&gt;</code>中增加映射，是必须的。在 MyBatis Generator 生成的代码中，需要进行对应的修改。</p></li><li><p>【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。<br><strong>说明</strong> :  配置映射关系，使字段与 DO 类解耦，方便维护。</p></li><li><p>【强制】sql.xml 配置参数使用: #{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</p></li><li><p>【强制】iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。<br><strong>说明</strong> :  其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList 取 start,size 的子集合。<br><strong>正例</strong> :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">map.put(&quot;start&quot;, start);</span><br><span class="line">map.put(&quot;size&quot;, size);</span><br><span class="line"> </span><br><span class="line">       @pdai: 代码已经复制到剪贴板</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。<br><strong>说明</strong> :  resultClass&#x3D;”Hashtable”，会置入字段名和属性值，但是值的类型不可控。</p></li><li><p>【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。</p></li><li><p>【推荐】不要写一个大而全的数据更新接口，传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1&#x3D;value1,c2&#x3D;value2,c3&#x3D;value3; 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</p></li><li><p>【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p></li><li><p>【参考】<code>&lt;isEqual&gt;</code>中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；<code>&lt;isNotEmpty&gt;</code>表示不为空且不为 null 时执行；<code>&lt;isNotNull&gt;</code>表示不为 null 值时执行。</p></li></ol><h1 id="¶-工程结构"><a href="#¶-工程结构" class="headerlink" title="¶ 工程结构"></a><a href="#%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84">¶</a> 工程结构</h1><h3 id="¶-应用分层"><a href="#¶-应用分层" class="headerlink" title="¶ 应用分层"></a><a href="#%E5%BA%94%E7%94%A8%E5%88%86%E5%B1%82">¶</a> 应用分层</h3><ol><li><p>【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如: 开放接口层可以依赖于 Web 层，也可以直接依赖于 Service 层，依此类推:</p><p><img src="G:/_images/ali_rules_app_layout.png" alt="未加载图片"></p><ul><li><p><strong>开放接口层</strong> : 可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。</p></li><li><p><strong>终端显示层</strong> : 各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</p></li><li><p><strong>Web 层</strong> : 主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</p></li><li><p><strong>Service 层</strong> : 相对具体的业务逻辑服务层。</p></li><li><p>Manager 层</p><p>: 通用业务处理层，它有如下特征:</p><ol><li>对第三方平台封装的层，预处理返回结果及转化异常信息；</li><li>对 Service 层通用能力的下沉，如缓存方案、中间件通用处理；</li><li>与 DAO 层交互，对多个 DAO 的组合复用。</li></ol></li><li><p><strong>DAO 层</strong> : 数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。</p></li><li><p><strong>外部接口或第三方平台</strong> : 包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。</p></li></ul></li><li><p>【参考】 (分层异常处理规约)在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 catch(Exception e)方式，并 throw new DAOException(e)，不需要打印 日志，因为日志在 Manager&#x2F;Service 层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果 Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。Web 层绝不应该继续往上抛异常，因为已经处于顶层，无继续处理异常的方式，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。</p></li><li><p>【参考】分层领域模型规约:</p><ul><li><strong>DO(Data Object)</strong> : 与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li><li><strong>DTO(Data Transfer Object)</strong> : 数据传输对象，Service 和 Manager 向外传输的对象。</li><li><strong>BO(Business Object)</strong> : 业务对象。可以由 Service 层输出的封装业务逻辑的对象。</li><li><strong>Query</strong> : 数据查询对象，各层接收上层的查询请求。注: 超过 2 个参数的查询封装，禁止使用 Map 类来传输。</li><li><strong>VO(View Object)</strong> : 显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li></ul></li></ol><h3 id="¶-二方库依赖"><a href="#¶-二方库依赖" class="headerlink" title="¶ 二方库依赖"></a><a href="#%E4%BA%8C%E6%96%B9%E5%BA%93%E4%BE%9D%E8%B5%96">¶</a> 二方库依赖</h3><ol><li><p>【强制】定义 GAV 遵从以下规则:</p></li><li><p>GroupID 格式: com.{公司&#x2F;BU }.业务线.[子业务线]，最多 4 级。<br><strong>说明</strong> :  {公司&#x2F;BU} 例如: alibaba&#x2F;taobao&#x2F;tmall&#x2F;aliexpress 等 BU 一级；子业务线可选。<br><strong>正例</strong> : com.taobao.jstorm 或 com.alibaba.dubbo.register</p></li><li><p>ArtifactID 格式: 产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。<br><strong>正例</strong> : dubbo-client &#x2F; fastjson-api &#x2F; jstorm-tool</p></li><li><p>Version: 详细规定参考下方。</p></li><li><p>【强制】二方库版本号命名方式: 主版本号.次版本号.修订号</p></li><li><p>主版本号: 当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。</p></li><li><p>次版本号: 当做了向下兼容的功能性新增(新增类、接口等)。</p></li><li><p>修订号: 修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。<br><strong>说明</strong> :  注意: 起始版本号必须为: 1.0.0，而不是 0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本: 1.3.3，那么下一个合理的版本号: 1.3.4 或 1.4.0 或 2.0.0</p></li><li><p>【强制】线上应用不要依赖 SNAPSHOT 版本(安全包除外)。<br><strong>说明</strong> :  不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。</p></li><li><p>【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变， 必须明确评估和验证，建议进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一 致，那么通过 dependency:tree 命令，找出差异点，进行<code>&lt;excludes&gt;</code>排除 jar 包。</p></li><li><p>【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚 举类型或者包含枚举类型的 POJO 对象。</p></li><li><p>【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。 说明: 依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一 个变量来保存版本: ${spring.version}，定义依赖的时候，引用该版本。</p></li><li><p>【强制】禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的 Version。<br><strong>说明</strong> :  在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号 出现在最后的 lib 目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。</p></li><li><p>【推荐】所有 pom 文件中的依赖声明放在<code>&lt;dependencies&gt;</code>语句块中，所有版本仲裁放在 <code>&lt;dependencyManagement&gt;</code>语句块中。 说明: <code>&lt;dependencyManagement&gt;</code>里只是声明版本，并不实现引入，因此子项目需要显式的声 明依赖，version 和 scope 都读取自父 pom。而<code>&lt;dependencies&gt;</code>所有声明在主 pom 的 <code>&lt;dependencies&gt;</code>里的依赖都会自动引入，并默认被所有的子项目继承。</p></li><li><p>【推荐】二方库不要有配置项，最低限度不要再增加配置项。</p></li><li><p>【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则:<br>1)精简可控原则。移除一切不必要的 API 和依赖，只包含 Service API、必要的领域模型对 象、Utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用 者去依赖具体版本号；无 log 具体实现，只依赖日志框架。<br>2)稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能 方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。</p></li></ol><h3 id="¶-服务器"><a href="#¶-服务器" class="headerlink" title="¶ 服务器"></a><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8">¶</a> 服务器</h3><ol><li>【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。 说明: 操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服 务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上 调小此等待值。<br><strong>正例</strong> : 在 linux 服务器上请通过变更&#x2F;etc&#x2F;sysctl.conf 文件去修改该缺省值(秒): net.ipv4.tcp_fin_timeout &#x3D; 30</li><li>【推荐】调大服务器所支持的最大文件句柄数(File Descriptor，简写为 fd)。<br><strong>说明</strong> :  主流操作系统的设计是将 TCP&#x2F;UDP 连接采用与文件一样的方式去管理，即一个连接对 应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。 建议将 linux 服务器所支持的最大句柄数调高数倍(与服务器的内存数量相关)。</li><li>【推荐】给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。<br><strong>说明</strong> :  OOM 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错 非常有价值。</li><li>【参考】服务器内部重定向使用 forward；外部重定向地址使用 URL 拼装工具类来生成，否则 会带来 URL 维护不一致的问题和潜在的安全风险。</li></ol><h2 id="¶-安全规约"><a href="#¶-安全规约" class="headerlink" title="¶ 安全规约"></a><a href="#%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6">¶</a> 安全规约</h2><ol><li><p>【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。<br><strong>说明</strong> :  防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信 内容、修改他人的订单。</p></li><li><p>【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。<br><strong>说明</strong> :  查看个人手机号码会显示成:158****9119，隐藏中间 4 位，防止隐私泄露。</p></li><li><p>【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入， 禁止字符串拼接 SQL 访问数据库。</p></li><li><p>【强制】用户请求传入的任何参数必须做有效性验证。<br><strong>说明</strong> :  忽略参数校验可能导致:</p><ul><li>page size 过大导致内存溢出</li><li>恶意 order by 导致数据库慢查询</li><li>任意重定向</li><li>SQL 注入</li><li>反序列化注入</li><li>正则输入源串拒绝服务 ReDoS</li></ul><p><strong>说明</strong> :  Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题， 但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。</p></li><li><p>【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</p></li><li><p>【强制】表单、AJAX 提交必须执行 CSRF 安全过滤。<br><strong>说明</strong> :  CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在 CSRF 漏洞的应用&#x2F;网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户 不知情情况下对数据库中用户参数进行相应修改。</p></li><li><p>【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制， 如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。 说明: 如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其 它用户，并造成短信平台资源浪费。</p></li><li><p>【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过 滤等风控策略。</p></li></ol><h2 id="¶-附-1-版本历史"><a href="#¶-附-1-版本历史" class="headerlink" title="¶ 附 1: 版本历史"></a><a href="#%E9%99%84-1-%E7%89%88%E6%9C%AC%E5%8E%86%E5%8F%B2">¶</a> 附 1: 版本历史</h2><table><thead><tr><th align="left">版本号</th><th align="left">更新日期</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">1.0.0</td><td align="left">2017.2.9</td><td align="left">阿里巴巴集团正式对外发布</td></tr><tr><td align="left">1.0.1</td><td align="left">2017.2.13</td><td align="left">1)修正 String[]的前后矛盾。2)vm 修正成 velocity。3)修正 countdown 描述错误。</td></tr><tr><td align="left">1.0.2</td><td align="left">2017.2.20</td><td align="left">1)去除文底水印。2)数据类型中引用太阳系年龄问题。3)修正关于异常和方法签名的部分描述。4)修正 final 描述。5)去除 Comparator 部分描述。</td></tr><tr><td align="left">1.1.0</td><td align="left">2017.2.27</td><td align="left">1)增加前言。2)增加<code>&lt;? extends T&gt;</code>描述和说明。3)增加版本历史。4)增加专有名词解释。</td></tr><tr><td align="left">1.1.1</td><td align="left">2017.3.31</td><td align="left">修正页码总数和部分示例</td></tr><tr><td align="left">1.2.0</td><td align="left">2017.5.20</td><td align="left">1)根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正。2)增加 final的适用场景描述。3)增加关于锁的粒度的说明。4)增加“指定集合大小”的详细说明以及正反例。5)增加卫语句的示例代码。6)明确数据库表示删除概念的字段名为 is_deleted</td></tr></tbody></table><h2 id="¶-附-2-本手册专有名词"><a href="#¶-附-2-本手册专有名词" class="headerlink" title="¶ 附 2: 本手册专有名词"></a><a href="#%E9%99%84-2-%E6%9C%AC%E6%89%8B%E5%86%8C%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D">¶</a> 附 2: 本手册专有名词</h2><ol><li><strong>POJO</strong>(Plain Ordinary Java Object): 在本手册中，POJO 专指只有 setter &#x2F; getter &#x2F; toString 的简单类，包括 DO&#x2F;DTO&#x2F;BO&#x2F;VO 等。</li><li><strong>DO</strong>(Data Object): 本手册指数据库表一一对应的 POJO 类。</li><li><strong>GAV</strong>(GroupId、ArtifactctId、Version): Maven 坐标，是用来唯一标识 jar 包。</li><li><strong>OOP</strong>(Object Oriented Programming): 本手册泛指类、对象的编程处理方式。</li><li><strong>ORM</strong>(Object Relation Mapping): 对象关系映射，对象领域模型与底层数据之间的转换， 本文泛指 iBATIS, mybatis 等框架。</li><li><strong>NPE</strong>(java.lang.NullPointerException): 空指针异常。</li><li><strong>SOA</strong>(Service-Oriented Architecture): 面向服务架构，它可以根据需求通过网络对松散 耦合的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。</li><li><strong>一方库</strong>: 本工程内部子项目模块依赖的库(jar 包)。</li><li><strong>二方库</strong>: 公司内部发布到中央仓库，可供公司内部其它应用依赖的库(jar 包)。</li><li><strong>三方库</strong>: 公司之外的开源库(jar 包)。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程规范&quot;&gt;&lt;a href=&quot;#编程规范&quot; class=&quot;headerlink&quot; title=&quot;编程规范&quot;&gt;&lt;/a&gt;编程规范&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一些定义&quot;&gt;&lt;a href=&quot;#一些定义&quot; class=&quot;headerlink&quot; title=&quot;一些定义</summary>
      
    
    
    
    
    <category term="基础知识" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>9.5</title>
    <link href="http://example.com/posts/47629/"/>
    <id>http://example.com/posts/47629/</id>
    <published>2022-09-05T14:23:44.000Z</published>
    <updated>2023-08-24T12:48:53.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-基础知识回顾"><a href="#C-基础知识回顾" class="headerlink" title="C++基础知识回顾"></a>C++基础知识回顾</h1><hr><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><hr><blockquote><p>为了正确的遵循教程，需要最新的编译器。它应支持（即使只是部分）2011 标准引入的功能。</p></blockquote><h2 id="什么是编译器"><a href="#什么是编译器" class="headerlink" title="什么是编译器"></a>什么是编译器</h2><hr><p>计算机只能理解一种语言，而这种语言由 1 和 0 组成的指令组成。这种计算机语言被恰当地称为机器语言。</p><p>因为计算机只能理解机器语言，而人类希望用高级语言编写高级语言，所以必须在某些时候将高级语言重新编写（翻译）成机器语言。这是通过内置在各种编程应用程序中的称为编译器、解释器或汇编器的特殊程序来完成的。</p><p>C++被设计成一种编译型语言，也就是说它一般被翻译成系统可以直接理解的机器语言，使得生成的程序非常高效。为此，需要一组工具，称为开发工具链，其核心是编译器及其链接器。</p><h2 id="控制台程序"><a href="#控制台程序" class="headerlink" title="控制台程序"></a>控制台程序</h2><hr><p>控制台程序是使用文本与用户和环境进行通信的程序，例如将文本打印到屏幕或从键盘读取输入。</p><p>控制台程序易于交互，并且通常具有在所有平台上相同的可预测行为，它们也很容易实现。</p><p>IDE：<strong>Code::blocks</strong>，<strong>Visual Studio Express</strong>，<strong>Dev-C++</strong></p><p>Compiler：<strong>GCC</strong>，<strong>Clang</strong></p><h2 id="程序的结构"><a href="#程序的结构" class="headerlink" title="程序的结构"></a>程序的结构</h2><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure><p>以井号 () 开头的行<code>#</code>是由所谓的<em>预处理器</em>读取和解释的指令。它们是在程序本身开始编译之前解释的特殊行。在这种情况下，指令<code>#include &lt;iostream&gt;</code>指示预处理器包含一段标准 C++ 代码，称为<em>标头 iostream</em>，它允许执行标准输入和输出操作，例如编写此程序的输出 (你好世界) 到屏幕上。</p><h3 id="使用命名空间标准"><a href="#使用命名空间标准" class="headerlink" title="使用命名空间标准"></a>使用命名空间标准</h3><hr><p>如果您以前看过 C++ 代码，那么您可能已经看到<code>cout</code>被使用而不是<code>std::cout</code>. 两者命名同一个对象：第一个使用其<em>非限定名称</em>( <code>cout</code>)，而第二个直接在<em>命名空间</em> <code>std</code>内限定它(as <code>std::cout</code>)。</p><p><code>cout</code>是标准库的一部分，标准 C++ 库中的所有元素都在所谓的<em>命名空间</em>中声明：命名空间<code>std</code>。</p><p>为了引用<code>std</code>命名空间中的元素，程序应限定库元素的每次使用（正如我们通过<code>cout</code>前缀<code>std::</code>)，或引入其组件的可见性。引入这些组件可见性的最典型方法是<em>使用声明</em>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std；</span><br></pre></td></tr></table></figure><p><em>上面的声明允许以非限定</em>方式<code>std</code>访问命名空间中 的所有元素（不带前缀）。 考虑到这一点，可以重写最后一个示例以不限定地使用std::&#96;</p><p>访问命名空间元素的两种方式<code>std</code>（显式限定和<em>使用</em>声明）在 C++ 中都是有效的，并且产生完全相同的行为。为简单起见并提高可读性，这些教程中的示例将更多地使用后一种方法和<em>using</em>声明，但请注意，<em>显式限定</em>是保证名称冲突永远不会发生的<em><strong>唯一方法</strong></em>。</p><h2 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h2><hr><p>我们现在可以将变量定义为内存的一部分来存储值。每个变量都需要一个名称来标识它并将其与其他变量区分开来。我们可以将变量命名为我们能想到的任何名称，只要它们是有效的 C++ 标识符。</p><h3 id="Identifiers"><a href="#Identifiers" class="headerlink" title="Identifiers"></a>Identifiers</h3><hr><p>有效标识符是一个或多个字母、数字或下划线字符 ( )<code>_</code>的序列。空格、标点符号和符号不能成为标识符的一部分。</p><p><strong>非常重要：</strong> C++ 语言是一种“区分大小写”的语言。这意味着以大写字母书写的标识符不等同于另一个具有相同名称但以小写字母书写的标识符</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><hr><p>C++ 是一种强类型语言，并且要求每个变量在第一次使用之前都用它的类型声明。这会通知编译器在内存中为变量保留的大小以及如何解释其值。</p><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><hr><p>当上面示例中的变量被声明时，它们具有未确定的值，直到它们第一次被赋值。但是从声明的那一刻起，变量就有可能具有特定的值。这称为变量的<em>初始化</em>。</p><p>在 C++ 中，有三种初始化变量的方法。它们都是等价的，让人想起多年来语言的演变：</p><p>第一个，称为类<em>c 初始化</em>（因为它是从 C 语言继承的），包括附加一个等号，然后是值变量被初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type identifier = initial_value;</span><br><span class="line">例如：</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>第二种方法，称为<em>构造函数初始化</em>（由 C++ 语言引入），将初始值括在括号 ( <code>()</code>) 之间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">type <span class="title">identifier</span> <span class="params">(initial_value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">x</span> <span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>最后，第三种方法，称为<em>统一初始化</em>，与上述类似，但使用花括号 ( <code>&#123;&#125;</code>) 代替括号（这是在 2011 年 C++ 标准的修订中引入的）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type identifier &#123;initial_value&#125;;</span><br><span class="line"><span class="type">int</span> x &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="类型推导：auto和decltype"><a href="#类型推导：auto和decltype" class="headerlink" title="类型推导：auto和decltype"></a>类型推导：auto和decltype</h2><hr><p>当一个新变量被初始化时，编译器可以通过初始化器自动判断出该变量的类型。为此，将其<code>auto</code>用作变量的类型说明符就足够了：</p><p>未初始化的变量也可以使用带有说明符的类型推导<code>decltype</code>：</p><p><code>auto</code>并且<code>decltype</code>是最近添加到该语言中的强大功能。但是他们引入的类型推导功能意味着在无法通过其他方式获得类型或使用它提高代码可读性时使用。上面的两个示例可能都不是这些用例。事实上，它们可能降低了可读性.</p><h2 id="字符串简介"><a href="#字符串简介" class="headerlink" title="字符串简介"></a>字符串简介</h2><hr><p>基本类型代表可以运行代码的机器处理的最基本类型。但 C++ 语言的主要优势之一是其丰富的复合类型集，其中基本类型只是构建块。</p><p>复合类型的一个例子是<code>string</code>类。这种类型的变量能够存储字符序列，例如单词或句子。一个非常有用的功能！</p><p>与基本数据类型的第一个区别是，为了声明和使用这种类型的对象（变量），程序需要包含标准库中定义类型的标头（标头<code>&lt;string&gt;</code>）：</p><h2 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h2><hr><blockquote><p>常量是具有固定值的表达式。</p></blockquote><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><hr><p>字面量是最明显的常量。它们用于表示程序源代码中的特定值。</p><p>文字常量可以分为：整数、浮点、字符、字符串、布尔值、指针和用户定义的文字。</p><p>一些程序员还使用一种技巧来在多行中包含长字符串文字：在 C++ 中，<code>\</code>行尾的反斜杠 ( ) 被视为<em>行继续</em>字符，它将该行和下一行合并为一行。因此下面的代码：</p><h3 id="预处理器定义"><a href="#预处理器定义" class="headerlink" title="预处理器定义"></a>预处理器定义</h3><hr><p>命名常量值的另一种机制是使用预处理器定义。它们具有以下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define identifier replacement</span><br></pre></td></tr></table></figure><p>在此指令之后，代码中的任何出现都<code>identifier</code>被解释为<code>replacement</code>，其中替换是任何字符序列（直到行尾）。这种替换由预处理器执行，并且发生在程序编译之前，因此导致了一种盲目替换：不以任何方式检查所涉及的类型或语法的有效性。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><hr><p>从最高优先级到最低优先级，C++ 运算符按以下顺序计算：</p><table><thead><tr><th align="left">等级</th><th align="left">优先组</th><th align="left">操作员</th><th align="left">描述</th><th align="left">分组</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">范围</td><td align="left"><code>::</code></td><td align="left">范围限定符</td><td align="left">左到右</td></tr><tr><td align="left">2</td><td align="left">后缀（一元）</td><td align="left"><code>++ --</code></td><td align="left">后缀递增&#x2F;递减</td><td align="left">左到右</td></tr><tr><td align="left"><code>()</code></td><td align="left">功能形式</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>[]</code></td><td align="left">下标</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>. -&gt;</code></td><td align="left">会员访问</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">3</td><td align="left">前缀（一元）</td><td align="left"><code>++ --</code></td><td align="left">前缀递增&#x2F;递减</td><td align="left">右到左</td></tr><tr><td align="left"><code>~ !</code></td><td align="left">按位非&#x2F;逻辑非</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>+ -</code></td><td align="left">一元前缀</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>&amp; *</code></td><td align="left">参考&#x2F;取消参考</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>new delete</code></td><td align="left">分配&#x2F;解除分配</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>sizeof</code></td><td align="left">参数包</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left"><code>(*type*)</code></td><td align="left">C 风格的类型转换</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">4</td><td align="left">指向成员的指针</td><td align="left"><code>.* -&gt;*</code></td><td align="left">访问指针</td><td align="left">左到右</td></tr><tr><td align="left">5</td><td align="left">算术：缩放</td><td align="left"><code>* / %</code></td><td align="left">乘法、除法、取模</td><td align="left">左到右</td></tr><tr><td align="left">6</td><td align="left">算术：加法</td><td align="left"><code>+ -</code></td><td align="left">加法，减法</td><td align="left">左到右</td></tr><tr><td align="left">7</td><td align="left">按位移位</td><td align="left"><code>&lt;&lt; &gt;&gt;</code></td><td align="left">左移，右移</td><td align="left">左到右</td></tr><tr><td align="left">8</td><td align="left">关系型</td><td align="left"><code>&lt; &gt; &lt;= &gt;=</code></td><td align="left">比较运算符</td><td align="left">左到右</td></tr><tr><td align="left">9</td><td align="left">平等</td><td align="left"><code>== !=</code></td><td align="left">平等&#x2F;不平等</td><td align="left">左到右</td></tr><tr><td align="left">10</td><td align="left">和</td><td align="left"><code>&amp;</code></td><td align="left">按位与</td><td align="left">左到右</td></tr><tr><td align="left">11</td><td align="left">独家或</td><td align="left"><code>^</code></td><td align="left">按位异或</td><td align="left">左到右</td></tr><tr><td align="left">12</td><td align="left">包含或</td><td align="left">&#96;</td><td align="left">&#96;</td><td align="left">按位或</td></tr><tr><td align="left">13</td><td align="left">连词</td><td align="left"><code>&amp;&amp;</code></td><td align="left">逻辑与</td><td align="left">左到右</td></tr><tr><td align="left">14</td><td align="left">析取</td><td align="left">&#96;</td><td align="left"></td><td align="left">&#96;</td></tr><tr><td align="left">15</td><td align="left">赋值级表达式</td><td align="left">&#96;&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; +&#x3D; -&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D;</td><td align="left">&#x3D;&#96;</td><td align="left">赋值&#x2F;复合赋值</td></tr><tr><td align="left"><code>?:</code></td><td align="left">条件运算符</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">16</td><td align="left">测序</td><td align="left"><code>,</code></td><td align="left">逗号分隔符</td><td align="left">左到右</td></tr></tbody></table><h2 id="基本输入和输出"><a href="#基本输入和输出" class="headerlink" title="基本输入和输出"></a>基本输入和输出</h2><hr><table><thead><tr><th align="left">溪流</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>cin</code></td><td align="left">标准输入流</td></tr><tr><td align="left"><code>cout</code></td><td align="left">标准输出流</td></tr><tr><td align="left"><code>cerr</code></td><td align="left">标准错误（输出）流</td></tr><tr><td align="left"><code>clog</code></td><td align="left">标准日志记录（输出）流</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-基础知识回顾&quot;&gt;&lt;a href=&quot;#C-基础知识回顾&quot; class=&quot;headerlink&quot; title=&quot;C++基础知识回顾&quot;&gt;&lt;/a&gt;C++基础知识回顾&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;编译器&quot;&gt;&lt;a href=&quot;#编译器&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="琐碎知识" scheme="http://example.com/categories/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="基础知识" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>密码学1</title>
    <link href="http://example.com/posts/53898/"/>
    <id>http://example.com/posts/53898/</id>
    <published>2022-09-05T14:23:18.000Z</published>
    <updated>2023-08-24T12:31:49.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><hr><p>自古以来，人类就有两种内在需求——(a) 交流和共享信息；(b) 有选择地交流。这两种需求催生了以这样一种方式对消息进行编码的艺术，即只有预期的人才能访问信息。未经授权的人无法提取任何信息，即使乱码信息落到他们手中。</p><h2 id="密码学史"><a href="#密码学史" class="headerlink" title="密码学史"></a>密码学史</h2><hr><p>密码学的第一个已知证据可以追溯到“象形文字”的使用。大约 4000 年前，埃及人曾经通过用象形文字书写的信息进行交流。这个密码是只有过去代表国王传递信息的文士才知道的秘密。一种这样的象形文字如下所示。</p><p>后来，在公元前 500 到 600 年间，学者们开始使用简单的单字母替换密码。这涉及用一些秘密规则用其他字母替换消息字母。该<strong>规则</strong>成为从乱码消息中取回消息的<strong>关键。</strong></p><p>早期的罗马密码学方法，通常被称为<strong>凯撒移位密码，</strong>依赖于将消息的字母移动一个约定的数字（三个是常见的选择），然后该消息的接收者会将字母向后移动相同的数字并获取原始消息</p><h2 id="密码学演变"><a href="#密码学演变" class="headerlink" title="密码学演变"></a>密码学演变</h2><hr><p>正是在欧洲文艺复兴时期和之后，意大利和教皇的各个国家引领了密码技术的迅速普及。这个时代研究了各种分析和攻击技术来破解密码</p><ul><li>改进的编码技术（如<strong>Vigenere Coding</strong> ）出现在 15世纪，它为消息中的移动字母提供了多个可变位置，而不是将它们移动相同数量的位置。</li><li>直到 19 世纪之后，密码学才从专门的加密方法发展到更复杂的信息安全艺术和科学。</li><li>在 20世纪初，机械和机电机器（如<strong>Enigma 转子机）</strong>的发明提供了更先进和更有效的信息编码方式。</li><li>在第二次世界大战期间，<strong>密码学</strong>和<strong>密码分析</strong>都变得过于数学化。</li></ul><h1 id="现代密码学"><a href="#现代密码学" class="headerlink" title="现代密码学"></a>现代密码学</h1><hr><p>现代密码学是计算机和通信安全的基石。它的基础是基于各种数学概念，例如数论、计算复杂性理论和概率论。</p><table><thead><tr><th>经典密码学</th><th>现代密码学</th></tr></thead><tbody><tr><td>它直接操作繁体字符，即字母和数字。</td><td>它对二进制位序列进行操作。</td></tr><tr><td>它主要基于“通过默默无闻的安全”。用于编码的技术是保密的，只有参与通信的各方知道它们。</td><td>它依赖于众所周知的数学算法对信息进行编码。保密性是通过用作算法种子的密钥获得的。算法的计算难度、密钥的缺失等，使得攻击者即使知道用于编码的算法也无法获得原始信息。</td></tr><tr><td>它需要整个密码系统进行保密通信。</td><td>现代密码学要求对安全通信感兴趣的各方只拥有密钥。</td></tr></tbody></table><p>密码学，密码系统的研究，可以细分为两个分支 -</p><ul><li>密码学</li><li>密码分析</li></ul><h3 id="什么是密码学？"><a href="#什么是密码学？" class="headerlink" title="什么是密码学？"></a>什么是密码学？</h3><p><em>密码学是制造能够提供信息安全的密码系统的艺术和科学。</em></p><p>密码学处理数字数据的实际保护。它是指基于数学算法的机制设计，提供基本的信息安全服务。您可以将密码学视为在安全应用程序中建立一个包含不同技术的大型工具包。</p><h3 id="什么是密码分析？"><a href="#什么是密码分析？" class="headerlink" title="什么是密码分析？"></a>什么是密码分析？</h3><p><em>破解密文的艺术和科学被称为密码分析。</em></p><p>密码分析是密码学的姊妹分支，它们共存。加密过程产生用于传输或存储的密文。它涉及对密码机制的研究，旨在破解它们。密码分析也用于新密码技术的设计以测试其安全强度。</p><p><strong>注</strong>- 密码学关注密码系统的设计，而密码分析研究密码系统的破解。</p><h2 id="密码学安全服务"><a href="#密码学安全服务" class="headerlink" title="密码学安全服务"></a>密码学安全服务</h2><hr><p>使用密码学的主要目的是提供以下四种基本信息安全服务。现在让我们看看密码学可能实现的目标。</p><h3 id="保密"><a href="#保密" class="headerlink" title="保密"></a>保密</h3><p>机密性是密码学提供的基本安全服务。它是一项安全服务，可防止未经授权的人员获取信息。它有时被称为<strong>隐私</strong>或<strong>保密</strong>。</p><p>机密性可以通过多种方式实现，从物理保护到使用数学算法进行数据加密。</p><h3 id="数据的完整性"><a href="#数据的完整性" class="headerlink" title="数据的完整性"></a>数据的完整性</h3><p>它是一种安全服务，负责识别对数据的任何更改。未经授权的实体可能有意或无意地修改数据。完整性服务确认数据自上次由授权用户创建、传输或存储以来是否完好无损。</p><p>数据完整性不能防止数据的更改，但提供了一种检测数据是否以未经授权的方式被操纵的手段。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>身份验证提供发起者的标识。它向接收者确认接收到的数据仅由经过识别和验证的发送者发送。</p><p>身份验证服务有两种变体 -</p><ul><li><strong>消息认证</strong>识别消息的发起者，而不考虑发送消息的路由器或系统。</li><li><strong>实体身份验证</strong>是确保数据已从特定实体（例如特定网站）接收到的保证。</li></ul><p>除了发起者之外，身份验证还可以提供与数据相关的其他参数的保证，例如创建&#x2F;传输的日期和时间。</p><h3 id="不可否认性"><a href="#不可否认性" class="headerlink" title="不可否认性"></a>不可否认性</h3><p>它是一种安全服务，可确保实体不能拒绝对先前承诺或行动的所有权。保证数据的原始创建者不能否认将所述数据创建或传输给接收者或第三方。</p><p>不可否认性是在数据交换有可能发生争议的情况下最理想的属性。例如，一旦以电子方式下订单，如果在此交易中启用了不可否认服务，则购买者不能拒绝该采购订单。</p><h2 id="密码学原语"><a href="#密码学原语" class="headerlink" title="密码学原语"></a>密码学原语</h2><hr><p>密码学原语只不过是密码学中的工具和技术，可以有选择地用于提供一组所需的安全服务 -</p><ul><li>加密</li><li>哈希函数</li><li>消息验证码 (MAC)</li><li>数字签名</li></ul><h1 id="密码系统"><a href="#密码系统" class="headerlink" title="密码系统"></a>密码系统</h1><hr><p>密码系统是用于提供信息安全服务的密码技术及其配套基础设施的实现。</p><h2 id="密码系统的组成部分"><a href="#密码系统的组成部分" class="headerlink" title="密码系统的组成部分"></a>密码系统的组成部分</h2><p>基本密码系统的各个组成部分如下 -</p><ul><li><strong>纯文本。</strong>它是传输过程中要保护的数据。</li><li><strong>加密演算法。</strong>这是一个数学过程，可为任何给定的明文和加密密钥生成密文。它是一种以明文和加密密钥为输入并产生密文的密码算法。</li><li><strong>密文。</strong>它是加密算法使用特定加密密钥生成的明文的加扰版本。密文不受保护。它在公共渠道上流动。任何有权访问通信通道的人都可以拦截或破坏它。</li><li><strong>解密算法，</strong>这是一个数学过程，它为任何给定的密文和解密密钥生成唯一的明文。它是以密文和解密密钥为输入，输出明文的密码算法。解密算法本质上是与加密算法相反的，因此与之密切相关。</li><li><strong>加密密钥。</strong>这是发件人已知的值。发送方将加密密钥与明文一起输入加密算法，以计算密文。</li><li><strong>解密密钥。</strong>它是接收者已知的值。解密密钥与加密密钥相关，但并不总是相同。接收方将解密密钥与密文一起输入解密算法，以计算明文。</li></ul><p>对于给定的密码系统，所有可能的解密密钥的集合称为<strong>密钥空间</strong>。</p><p><strong>拦截器</strong>（攻击者）是试图确定明文的未经授权的实体。他可以看到密文，可能知道解密算法。然而，他绝不能知道解密密钥。</p><h2 id="密码系统的类型"><a href="#密码系统的类型" class="headerlink" title="密码系统的类型"></a>密码系统的类型</h2><hr><p>从根本上说，根据在系统中执行加密-解密的方式，有两种类型的密码系统 -</p><ul><li>对称密钥加密</li><li>非对称密钥加密</li></ul><p>这些密码系统之间的主要区别在于加密和解密密钥之间的关系。从逻辑上讲，在任何密码系统中，两个密钥都是密切相关的。用与加密密钥无关的密钥来解密密文实际上是不可能的。</p><h3 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h3><p><strong>使用相同密钥对信息进行加密和解密</strong>的加密过程称为对称密钥加密。</p><p>对称密码系统的研究被称为<strong>对称密码学</strong>。对称密码系统有时也称为<strong>密钥密码系统</strong>。</p><p>在 1970 年之前，所有密码系统都采用对称密钥加密。即使在今天，它的相关性也非常高，并且在许多密码系统中被广泛使用。这种加密不太可能消失，因为它比非对称密钥加密具有某些优势。</p><p>基于对称密钥加密的密码系统的显着特点是 -</p><ul><li>使用对称密钥加密的人必须在交换信息之前共享一个公共密钥。</li><li>建议定期更换密钥，以防止对系统的任何攻击。</li><li>需要存在一种健壮的机制来在通信方之间交换密钥。由于需要定期更改密钥，因此这种机制变得昂贵且繁琐。</li><li>在<strong>n</strong>人的群组中，要实现任意两人之间的两方通信，群组所需的密钥数为<strong>n × (n – 1)&#x2F;2</strong>。</li><li>此加密中的密钥长度（位数）较小，因此加密-解密过程比非对称密钥加密更快。</li><li>运行对称算法所需的计算机系统的处理能力较少。</li></ul><h3 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h3><hr><p><strong>使用不同密钥对信息进行加密和解密的</strong>加密过程称为非对称密钥加密。尽管密钥不同，但它们在数学上是相关的，因此通过解密密文来检索明文是可行的。</p><p>非对称密钥加密是在 20 世纪发明的，目的是克服通信人员之间预先共享密钥的必要性。该加密方案的显着特点如下 -</p><ul><li>这个系统中的每个用户都需要有一对不同的密钥，<strong>私钥</strong>和<strong>公钥</strong>。这些密钥在数学上是相关的——当一个密钥用于加密时，另一个可以将密文解密回原始明文。</li><li>它要求将公钥放在公共存储库中，并将私钥作为一个严密保护的秘密。因此，这种加密方案也称为<strong>公钥加密</strong>。</li><li>虽然用户的公钥和私钥是相关的，但是从另一个中找到一个在计算上是不可行的。这是该方案的优势。</li><li>当<em>Host1</em>需要向 Host2 发送数据时<em>，</em>他从存储库中获取<em>Host2</em>的公钥，对数据进行加密，然后传输。</li><li><em>Host2</em>使用他的私钥提取明文。</li><li>这种加密中的密钥长度（位数）很大，因此加密解密的过程比对称密钥加密要慢。</li><li>运行非对称算法所需的计算机系统的处理能力更高。</li></ul><p>对称密码系统是一个自然概念。相比之下，公钥密码系统很难理解。</p><p>您可能会想，<em>加密密钥和解密密钥怎么可能是“相关的”，但又无法从加密密钥中确定解密密钥呢？</em>答案在于数学概念。可以设计一个其密钥具有此属性的密码系统。公钥密码学的概念相对较新。已知的公钥算法比对称算法少。</p><h1 id="对于密码系统的攻击"><a href="#对于密码系统的攻击" class="headerlink" title="对于密码系统的攻击"></a>对于密码系统的攻击</h1><hr><p>在当今时代，不仅是商业，人类生活的几乎所有方面都是由信息驱动的。因此，保护有用信息免受攻击等恶意活动已成为当务之急。让我们考虑一下信息通常受到的攻击类型。</p><p>攻击通常根据攻击者执行的操作进行分类。因此，攻击可以是<strong>被动</strong>的或<strong>主动</strong>的。</p><h3 id="被动攻击"><a href="#被动攻击" class="headerlink" title="被动攻击"></a>被动攻击</h3><hr><p>被动攻击的主要目标是获得<strong>对信息的未经授权的访问</strong>。例如，对通信信道进行拦截、窃听等行为可以被视为被动攻击。</p><p>这些行为本质上是被动的，因为它们既不会影响信息，也不会破坏沟通渠道。被动攻击通常被视为<em>窃取</em>信息。窃取实物商品和窃取信息的唯一区别是，数据被盗后仍让所有者拥有该数据。因此，被动信息攻击比盗窃商品更危险，因为信息盗窃可能会被所有者忽视。</p><h3 id="主动攻击"><a href="#主动攻击" class="headerlink" title="主动攻击"></a>主动攻击</h3><hr><p>主动攻击涉及通过对信息执行某些过程以某种方式更改信息。例如，</p><ul><li>以未经授权的方式修改信息。</li><li>发起无意或未经授权的信息传输。</li><li>更改身份验证数据，例如与信息相关的发起者名称或时间戳</li><li>未经授权删除数据。</li><li>拒绝合法用户访问信息（拒绝服务）。</li></ul><p>密码学提供了许多工具和技术来实现能够防止上述大多数攻击的密码系统。</p><h1 id="传统密码"><a href="#传统密码" class="headerlink" title="传统密码"></a>传统密码</h1><hr><h2 id="早期的密码系统"><a href="#早期的密码系统" class="headerlink" title="早期的密码系统"></a>早期的密码系统</h2><hr><p>在继续之前，您需要了解一些有关历史密码系统的事实 -</p><ul><li>所有这些系统都<strong>基于对称密钥加密</strong>方案。</li><li>这些系统提供的唯一安全服务是信息的机密性。</li><li>与将数据视为二进制数字的现代系统不同，早期的系统将字母作为基本元素。</li></ul><p>这些较早的密码系统也称为密码。通常，密码只是用于执行加密和相应解密的一组步骤（一种算法）。</p><h2 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h2><hr><p>它是一种单字母密码，其中明文的每个字母都被另一个字母替换以形成密文。它是一种最简单的替换密码方案。</p><p>这种密码系统通常被称为<strong>移位密码</strong>。这个概念是将每个字母替换为另一个字母，该字母被“移动”了 0 到 25 之间的某个固定数字。</p><p>对于这种类型的方案，发送者和接收者都同意一个用于转换字母表的“秘密班次号”。这个介于 0 和 25 之间的数字成为加密密钥。</p><p>当使用“三的移位”时，有时会使用“凯撒密码”这个名称来描述移位密码。</p><h3 id="移位密码的过程"><a href="#移位密码的过程" class="headerlink" title="移位密码的过程"></a>移位密码的过程</h3><ul><li><p>为了加密明文字母，发送者将滑动尺放在第一组明文字母下方，并将其向左滑动秘密移位的位置数。</p></li><li><p>然后将明文字母加密为下方滑动尺上的密文字母。此过程的结果如下图所示，用于商定的三个职位的转变。在这种情况下，明文“教程”被加密为密文“WXWRULDO”。这是 Shift 为 3 的密文字母表 -</p></li><li><p>在收到密文时，同样知道秘密移位的接收者将他的滑动尺放在密文字母表的下方，并将其滑动到约定的移位编号，在这种情况下为 3。</p></li><li><p>然后，他将密文字母替换为下方滑动尺上的明文字母。因此密文“WXWRULDO”被解密为“教程”。要解密用 3 的 Shift 编码的消息，请使用“-3”的移位生成明文字母表，如下所示 -</p></li></ul><h3 id="安全价值"><a href="#安全价值" class="headerlink" title="安全价值"></a>安全价值</h3><p>Caesar Cipher<strong>不是一个安全的</strong>密码系统，因为只有 26 个可能的密钥可供尝试。攻击者可以利用可用的有限计算资源进行详尽的密钥搜索。</p><h2 id="简单替换密码"><a href="#简单替换密码" class="headerlink" title="简单替换密码"></a>简单替换密码</h2><hr><p>这是对凯撒密码的改进。该方案不是将字母表移动某个数字，而是使用字母表中字母的某种排列。</p><p>例如，AB……..YZ 和 ZY……BA 是字母表中所有字母的两个明显排列。排列只不过是一组混乱的字母表。</p><p>字母表中有 26 个字母，可能的排列是 26！（26 的因数）等于 4x10 26。发送者和接收者可以选择这些可能的排列中的任何一种作为密文字母表。该排列是该方案的密钥。</p><h3 id="简单替换密码的过程"><a href="#简单替换密码的过程" class="headerlink" title="简单替换密码的过程"></a>简单替换密码的过程</h3><ul><li><p>按自然顺序写出字母 A、B、C、…、Z。</p></li><li><p>发送者和接收者决定随机选择的字母排列。</p></li><li><p>在自然顺序字母下方，写出所选字母的排列。对于加密，发送者通过替换表中正下方的排列字母来替换每个明文字母。此过程如下图所示。在这个例子中，选择的排列是 K,D, G, …, O。明文“点”被加密为“MJBXZ”。</p></li><li><p>在接收到密文时，也知道随机选择的排列的接收者将底行的每个密文字母替换为顶行中相应的明文字母。密文“MJBXZ”被解密为“点”。</p></li></ul><h3 id="安全价值-1"><a href="#安全价值-1" class="headerlink" title="安全价值"></a>安全价值</h3><p>简单替换密码是对凯撒密码的相当大的改进。可能的密钥数量很大（26 个！），甚至现代计算系统还不够强大，无法轻松发起暴力攻击来破坏系统。然而，简单替换密码设计简单，容易出现设计缺陷，比如选择明显的排列，这种密码系统很容易被破解。</p><h2 id="单字母和多字母密码"><a href="#单字母和多字母密码" class="headerlink" title="单字母和多字母密码"></a>单字母和多字母密码</h2><hr><p>单字母密码是一种替代密码，其中对于给定的密钥，每个普通字母的密码字母在整个加密过程中都是固定的。例如，如果“A”被加密为“D”，那么对于该明文中出现的任意次数，“A”将始终被加密为“D”。</p><p>我们在本章前面讨论过的所有替换密码都是单字母的。这些密码很容易受到密码分析的影响。</p><p>多字母密码是一种替代密码，其中在加密过程中，普通字母的密码字母可能在不同的地方不同。接下来的两个示例<strong>playfair 和 Vigenere Cipher 是多字母密码</strong>。</p><h2 id="Playfair-密码"><a href="#Playfair-密码" class="headerlink" title="Playfair 密码"></a>Playfair 密码</h2><p>在这个方案中，字母对被加密，而不是像简单替换密码的情况下的单个字母。</p><p>在 playfair cipher 中，最初创建了一个密钥表。密钥表是一个 5×5 的字母网格，用作加密明文的密钥。25 个字母中的每一个都必须是唯一的，并且表中省略了一个字母（通常是 J），因为我们只需要 25 个字母而不是 26 个。如果明文包含 J，则将其替换为 I。</p><p>发送者和接收者决定一个特定的键，比如“教程”。在键表中，表中的第一个字符（从左到右）是短语，不包括重复的字母。表格的其余部分将按自然顺序填充字母表的其余字母。关键表是 -</p><p><img src="/../img/key_table.jpg" alt="键表"></p><h3 id="Playfair密码的过程"><a href="#Playfair密码的过程" class="headerlink" title="Playfair密码的过程"></a>Playfair密码的过程</h3><ul><li><p>首先，明文消息被分成两个字母对（有向图）。如果有奇数个字母，则将 Z 添加到最后一个字母。假设我们要加密“隐藏钱”的消息。它将被写为 -</p><p>HI DE MO NE YZ</p></li><li><p>加密规则是 -</p><ul><li>如果两个字母在同一列中，则取每个字母下方的字母（如果在底部，则返回顶部）</li></ul></li></ul><table><thead><tr><th>吨</th><th>ü</th><th>○</th><th>R</th><th>我</th><th>‘H’ 和 ‘I’ 在同一列，因此用它们下面的字母替换。你好 → 质量控制</th></tr></thead><tbody><tr><td>一个</td><td>大号</td><td>小号</td><td>乙</td><td>C</td><td></td></tr><tr><td>D</td><td>乙</td><td>F</td><td>G</td><td>H</td><td></td></tr><tr><td>ķ</td><td>米</td><td>ñ</td><td>磷</td><td>问</td><td></td></tr><tr><td>五</td><td>W</td><td>X</td><td>是</td><td>Z</td><td></td></tr></tbody></table><ul><li><p>如果两个字母在同一行，则取每个字母右侧的字母（如果在最右侧，则返回左侧）</p></li><li><table><thead><tr><th>吨</th><th>ü</th><th>○</th><th>R</th><th>我</th><th>‘D’ 和 ‘E’ 在同一行，因此用它们右边的字母替换。德 → 英</th></tr></thead><tbody><tr><td>一个</td><td>大号</td><td>小号</td><td>乙</td><td>C</td><td></td></tr><tr><td>D</td><td>乙</td><td>F</td><td>G</td><td>H</td><td></td></tr><tr><td>ķ</td><td>米</td><td>ñ</td><td>磷</td><td>问</td><td></td></tr><tr><td>五</td><td>W</td><td>X</td><td>是</td><td>Z</td><td></td></tr></tbody></table></li><li><p>如果上述两条规则都不成立，则用这两个字母组成一个矩形，并取矩形水平对角上的字母。</p></li></ul><p><img src="/../img/playfair_cipher.jpg" alt="Playfair 密码"></p><h3 id="安全价值-2"><a href="#安全价值-2" class="headerlink" title="安全价值"></a>安全价值</h3><p>它也是一种替换密码，与简单替换密码相比，很难破解。与替换密码的情况一样，Playfair 密码也可以进行密码分析，但是它将针对 625 个可能的字母对（25x25 字母）而不是 26 个不同的可能字母。</p><p>Playfair 密码主要用于保护重要但非关键的机密，因为它使用迅速且不需要特殊设备。</p><h2 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h2><hr><p>这种密码方案使用文本字符串（例如，一个单词）作为密钥，然后将其用于对明文进行多次转换。</p><p>例如，假设键是“点”。键的每个字母都转换为其各自的数值：在这种情况下，</p><p>p → 16，o → 15，i → 9，n → 14，t → 20。</p><p>因此，关键是：16 15 9 14 20。</p><h3 id="Vigenere密码的过程"><a href="#Vigenere密码的过程" class="headerlink" title="Vigenere密码的过程"></a>Vigenere密码的过程</h3><ul><li>发送者和接收者决定一个密钥。说“点”是关键。该键的数字表示为“16 15 9 14 20”。</li><li>发件人想要加密邮件，说“来自东南的攻击”。他将安排明文和数字键如下 -</li></ul><p><img src="/../img/vigenere_cipher.jpg" alt="维吉尼亚密码"></p><ul><li>他现在将每个明文字母按下面写的数字移动以创建密文，如下所示 -</li></ul><p><img src="/../img/create_ciphertext.jpg" alt="创建密文"></p><ul><li>在这里，每个明文字符都被移动了不同的数量——这个数量是由密钥决定的。密钥必须小于或等于消息的大小。</li><li>对于解密，接收方使用相同的密钥并将接收到的密文以相反的顺序移位以获得明文。</li></ul><p><img src="/../img/ciphertext_in_reverse_order.jpg" alt="逆序密文"></p><h3 id="安全价值-3"><a href="#安全价值-3" class="headerlink" title="安全价值"></a>安全价值</h3><p>Vigenere Cipher 是通过调整标准凯撒密码来设计的，以降低对密文进行密码分析的有效性，并使密码系统更加健壮。它<strong>比常规的 Caesar Cipher 安全得多</strong>。</p><p>在历史上，它经常被用于保护敏感的政治和军事信息。由于它给密码分析带来的困难，它被称为<strong>牢不可破的密码。</strong></p><h3 id="Vigenere-密码的变体"><a href="#Vigenere-密码的变体" class="headerlink" title="Vigenere 密码的变体"></a>Vigenere 密码的变体</h3><p>Vigenere 密码有两种特殊情况 -</p><ul><li>关键字长度与原告消息相同。这种情况称为<strong>Vernam Cipher</strong>。它比典型的 Vigenere 密码更安全。</li><li>Vigenere 密码成为一种完全保密的密码系统，称为<strong>One-time pad</strong>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;密码学&quot;&gt;&lt;a href=&quot;#密码学&quot; class=&quot;headerlink&quot; title=&quot;密码学&quot;&gt;&lt;/a&gt;密码学&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;自古以来，人类就有两种内在需求——(a) 交流和共享信息；(b) 有选择地交流。这两种需求催生了以这样一种方式对消息进行编</summary>
      
    
    
    
    
    <category term="密码学" scheme="http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>9.1</title>
    <link href="http://example.com/posts/30988/"/>
    <id>http://example.com/posts/30988/</id>
    <published>2022-09-04T13:01:23.000Z</published>
    <updated>2023-08-24T12:48:48.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Poco-Thread"><a href="#Poco-Thread" class="headerlink" title="Poco::Thread"></a>Poco::Thread</h1><hr><blockquote><p>此类实现了操作系统的线程独立于平台的包装器，每个线程对象都拥有唯一的数字线程ID，此外，为每个线程分配一个名称，线程的名称可以随时更改。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Poco::<span class="built_in">Thread</span>();</span><br></pre></td></tr></table></figure><p>创建一个线程，用Start()来启动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Poco::<span class="built_in">Thread</span>(<span class="type">const</span> std::string&amp; name);</span><br></pre></td></tr></table></figure><p>创建一个被命名的线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void start(Runnable&amp; target);</span><br></pre></td></tr></table></figure><p>使用给定目标启动线程，给出的Runnable对象必须在整个生命周期内保持有效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">(Callable target, <span class="type">void</span>* pData = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>使用给定目标和参数进行启动</p><h1 id="Poco-UUIDGenerator"><a href="#Poco-UUIDGenerator" class="headerlink" title="Poco::UUIDGenerator"></a>Poco::UUIDGenerator</h1><hr><blockquote><p>此类实现通用唯一标识符的生成器</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Poco::UUID <span class="title">create</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>使用以太网适配器之一的MAC地址，创建一个新的基于时间的UUID。如果没有MAC地址，则抛出系统异常。</p><h1 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h1><hr><p>fopen的函数原型为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure><p>其功能是使用给定的模式mode打开filename所指向的文件。文件顺利打开时，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，，并把错误代码存在error中，位于&lt;stdio.h&gt;中。</p><h1 id="Linux-基础知识"><a href="#Linux-基础知识" class="headerlink" title="Linux 基础知识"></a>Linux 基础知识</h1><hr><h2 id="常用操作以及概念"><a href="#常用操作以及概念" class="headerlink" title="常用操作以及概念"></a>常用操作以及概念</h2><hr><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><hr><ul><li>Tab：命令行和文件名补全</li><li>Ctrl+C：终断正在运行的程序</li><li>Ctrl+D：结束键盘输入（End Of File，EOF）</li></ul><h3 id="求助"><a href="#求助" class="headerlink" title="求助"></a>求助</h3><hr><ul><li><p>–help</p><p>指令的基本用法以及选项介绍</p></li><li><p>man</p><p>man是manual的缩写，将指令的具体信息显示出来。</p><p>当执行man date时，有DATE（1）出现，其中数字代表指令的类型，常用的数字及其类型如下</p><table><thead><tr><th>代号</th><th>类型</th></tr></thead><tbody><tr><td>1</td><td>用户在shell环境中可以操作的指令或者可执行文件</td></tr><tr><td>5</td><td>配置文件</td></tr><tr><td>8</td><td>系统管理员可以使用的管理命令</td></tr></tbody></table></li><li><p>info</p><p>info与man相似，但是info将文档分为一个个页面，每个页面都可以进行跳转。</p></li><li><p>doc</p><p>&#x2F;user&#x2F;share&#x2F;doc存放着软件的一套说明文件</p></li></ul><h3 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h3><hr><ul><li><p>管机前使用who命令查看有无其他用户在线</p></li><li><p>为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立马同步到磁盘上，因此关机之前需要先进行sync同步操作</p></li><li><p>shutdown</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># shutdown [-krhc] 时间 [信息]</span></span></span><br><span class="line">-k :  不会关机，只是发送警告信息，通知所有在线的用户</span><br><span class="line">-r :  将系统的服务停掉后就重新启动</span><br><span class="line">-h :  将系统的服务停掉后就立即关机</span><br><span class="line">-c :  取消已经在进行的 shutdown 指令内容</span><br></pre></td></tr></table></figure></li></ul><h3 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h3><hr><p><strong>可以在环境变量PATH中声明可执行文件的路径，路径之间用：分离</strong></p><pre><code>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin</span><br></pre></td></tr></table></figure></code></pre><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><hr><p>sudo允许一般用户使用root可执行的命令，不过只有在&#x2F;etc&#x2F;sudoers配置文件中添加的用户才能使用该指令。</p><h3 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h3><hr><p>RPM和DPKG为最常见的两类软件包管理工具：</p><ul><li>RPM全称为Redhat Packet Manager最早由Ret Hat公司定制实施，最后被GUN开源系统接受并成为很多Linux系统（RHEL）的既定软件标准</li><li>与RPM进行竞争的是基于Debian操作系统的Ubuntu的DEB软件包管理工具DPGK，全称为Debian Package，功能方面与RPM相似</li></ul><p>YUM基于RPM，具有依赖管理功能，并具有软件升级的功能。</p><h3 id="发行版"><a href="#发行版" class="headerlink" title="发行版"></a>发行版</h3><hr><p>Linux发行版本是Linux内核及各种应用软件的集成版本。</p><table><thead><tr><th><strong>基于的包管理工具</strong></th><th><strong>商业发行版</strong></th><th><strong>社区发行版</strong></th></tr></thead><tbody><tr><td>RPM</td><td>Red Hat</td><td>Fedora &#x2F; CentOS</td></tr><tr><td>DPKG</td><td>Ubuntu</td><td>Debian</td></tr></tbody></table><h3 id="VIM的三个模式"><a href="#VIM的三个模式" class="headerlink" title="VIM的三个模式"></a>VIM的三个模式</h3><hr><ol><li>一般指令模式(Command mode): VIM 的默认模式，可以用于移动游标查看内容；</li><li>编辑模式(Insert mode): 按下 “i” 等按键之后进入，可以对文本进行编辑；</li><li>指令列模式(Bottom-line mode): 按下 “:” 按键之后进入，用于保存退出等操作。</li></ol><p><img src="/../img/5942debd-fc00-477a-b390-7c5692cc8070.jpg"></p><p>在指令模式下，有以下命令用于离开或者保存文件</p><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">:w</td><td align="center">写入磁盘</td></tr><tr><td align="center">:w!</td><td align="center">当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td></tr><tr><td align="center">:q</td><td align="center">离开</td></tr><tr><td align="center">:q!</td><td align="center">强制离开不保存</td></tr><tr><td align="center">:wq</td><td align="center">写入磁盘后离开</td></tr><tr><td align="center">:wq!</td><td align="center">强制写入磁盘后离开</td></tr></tbody></table><h3 id="GUN"><a href="#GUN" class="headerlink" title="GUN"></a>GUN</h3><hr><p>GUN计划，译为革奴计划，它的目标是创建一套完全自由的操作系统，称为 GNU，其内容软件完全以 GPL 方式发布。其中 GPL 全称为 GNU 通用公共许可协议，包含了以下内容:</p><ul><li>以任何目的运行此程序的自由；</li><li>再复制的自由；</li><li>改进此程序，并公开发布改进的自由。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Poco-Thread&quot;&gt;&lt;a href=&quot;#Poco-Thread&quot; class=&quot;headerlink&quot; title=&quot;Poco::Thread&quot;&gt;&lt;/a&gt;Poco::Thread&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;此类实现了操作系统的线程独立</summary>
      
    
    
    
    <category term="琐碎知识" scheme="http://example.com/categories/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="基础知识" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://example.com/posts/25246/"/>
    <id>http://example.com/posts/25246/</id>
    <published>2022-08-29T13:09:47.000Z</published>
    <updated>2023-08-24T12:31:49.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h1><hr><blockquote><p>Git是先进的分布式版本控制系统，克隆文件的速度非常快</p></blockquote><p>每个开发都可以从master上克隆一个本地版本库，就算没有网络也可以提交代码到本地仓库，查看log，创建项目分支等</p><p>每个版本库都可以创建无限个分支，分支是一个完整的项目，并且拥有完整的实际文件</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><hr><p>右键出现git bash就证明Git安装成功</p><p>接着需要设置机器信息，这台机器上所有的Git仓库都使用这个配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;username&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><hr><ol><li>创建一个空目录(最好无中文)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> mymenu</span><br><span class="line">$ <span class="built_in">cd</span> mymenu</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/Users/hxk/mymennu</span><br><span class="line"><span class="comment">#pwd显示当前目录</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>初始化仓库</p><p>git init 命令将目录变为git可以管理的仓库</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /User/hxk/mymenu/.git</span><br></pre></td></tr></table></figure><p>​初始化一个空的仓库，目录下多了.git目录</p><p>​系统自动创建了唯一一个master分支，版本控制系统只能跟踪文本文件的改动，且编码格式是UTF-8</p><ol start="3"><li><p>文件的基本操作</p><p>创建一个text.txt文件，内容如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World </span><br></pre></td></tr></table></figure><p>添加文件到仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.txt</span><br></pre></td></tr></table></figure><p>提交文件到仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;a new file&quot;</span></span><br><span class="line"><span class="comment">#-m后添加的是注释，提交成功后会显示 </span></span><br><span class="line"><span class="comment">#提交成功后会显示</span></span><br><span class="line"><span class="comment">#1 file changed：1个文件被改动（我们新添加的readme.txt文件）</span></span><br><span class="line"><span class="comment">#2 insertions：插入了两行内容（readme.txt有两行内容）</span></span><br></pre></td></tr></table></figure></li></ol><p>​修改文件</p><p>​将test.txt文件修改如下:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello world ABC</span><br></pre></td></tr></table></figure><p>​提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line">$ git commit -m <span class="string">&quot;append ABC&quot;</span></span><br></pre></td></tr></table></figure><p>​查看历史记录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: hxk &lt;hxk@gmail.com&gt;</span><br><span class="line">Date:   Fri July 20 21:06:15 2018 +0800</span><br><span class="line"> </span><br><span class="line">    append ABC</span><br><span class="line"> </span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: hxk &lt;hxk@gmail.com&gt;</span><br><span class="line">Date:   Fri July 20 20:59:18 2018 +0800</span><br><span class="line"> </span><br><span class="line">    a new file</span><br></pre></td></tr></table></figure><p>​回退历史版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset</span><br></pre></td></tr></table></figure><p>​首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交      </p><p>​        1094adb…上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p><p>​回退上一个版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at eaadf4e a new file</span><br></pre></td></tr></table></figure><p>​再次查看历史版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: hxk &lt;hxk@gmail.com&gt;</span><br><span class="line">Date:   Fri July 20 20:59:18 2018 +0800</span><br><span class="line"> </span><br><span class="line">    a new file</span><br></pre></td></tr></table></figure><p>​         之前那个版本已经看不到了，这时如果想回到之前那个版本，需要知道版本号，git内部有个指向当前版本的head指针，将指针从当前版本指回去，所以git回退版本特别快</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 1094adb7</span><br></pre></td></tr></table></figure><p>​查看历史命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><p>​查看状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><h2 id="git工作流程"><a href="#git工作流程" class="headerlink" title="git工作流程"></a>git工作流程</h2><hr><p><img src="/../img/120087b58877445f8db4bbfdd213edf7.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">命令如下：</span><br><span class="line">1. clone（克隆）: 从远程仓库中克隆代码到本地仓库</span><br><span class="line">2. checkout （检出）:从本地仓库中检出一个仓库分支然后进行修订</span><br><span class="line">3. add（添加）: 在提交前先将代码提交到暂存区</span><br><span class="line">4. commit（提交）: 提交到本地仓库。本地仓库中保存修改的各个历史版本</span><br><span class="line">5. fetch (抓取) ： 从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。</span><br><span class="line">6. pull (拉取) ： 从远程库拉到本地库，自动进行合并(merge)，然后放到到工作区，相当于</span><br><span class="line">fetch+merge</span><br><span class="line">7. push（推送） : 修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库</span><br></pre></td></tr></table></figure><h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><hr><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p><strong>此操作先初始化本地仓库，在与远程仓库进行对接</strong></p><p>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:xxxxxx/git_test.git</span><br><span class="line"><span class="comment">#origin是给远程仓库取的名称</span></span><br><span class="line"><span class="comment">#git@gitee.com:xxxxxx/git_test.git   是远程仓库的URL</span></span><br></pre></td></tr></table></figure><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br></pre></td></tr></table></figure><h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push[-f][--set-upstream][远端名称[本地分支名][远端分支名]]</span><br></pre></td></tr></table></figure><p>如果是远端分支名和本地分支名称相同，则可以只写本地分支</p><h3 id="从远端仓库克隆"><a href="#从远端仓库克隆" class="headerlink" title="从远端仓库克隆"></a>从远端仓库克隆</h3><p>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span></span><br></pre></td></tr></table></figure><h2 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h2><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">查看、添加、提交、删除、找回，重置修改文件</span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line">git <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt; <span class="comment"># 显示command的help</span></span><br><span class="line"> </span><br><span class="line">git show <span class="comment"># 显示某次提交的内容 git show $id</span></span><br><span class="line"></span><br><span class="line">git co -- &lt;file&gt; <span class="comment"># 抛弃工作区修改</span></span><br><span class="line"></span><br><span class="line">git co . <span class="comment"># 抛弃工作区所有修改</span></span><br><span class="line"> </span><br><span class="line">git add &lt;file&gt; <span class="comment"># 将工作文件修改提交到本地暂存区</span></span><br><span class="line"></span><br><span class="line">git add . <span class="comment"># 将所有修改过的工作文件提交暂存区</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">rm</span> &lt;file&gt; <span class="comment"># 从版本库中删除文件</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">rm</span> &lt;file&gt; --cached <span class="comment"># 从版本库中删除文件，但不删除文件</span></span><br><span class="line"></span><br><span class="line">git reset &lt;file&gt; <span class="comment"># 从暂存区恢复到工作文件</span></span><br><span class="line"></span><br><span class="line">git reset -- . <span class="comment"># 从暂存区恢复到工作文件</span></span><br><span class="line"> </span><br><span class="line">git reset --hard <span class="comment"># 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</span></span><br><span class="line"></span><br><span class="line">git ci &lt;file&gt; git ci . git ci -a <span class="comment"># 将git add, git rm和git ci等操作都合并在一起做　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　git ci -am &quot;some comments&quot;</span></span><br><span class="line"></span><br><span class="line">git ci --amend <span class="comment"># 修改最后一次提交记录</span></span><br><span class="line"></span><br><span class="line">git revert &lt;<span class="variable">$id</span>&gt; <span class="comment"># 恢复某次提交的状态，恢复动作本身也创建次提交对象</span></span><br><span class="line"></span><br><span class="line">git revert HEAD <span class="comment"># 恢复最后一次提交的状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看提交记录</span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> git <span class="built_in">log</span> &lt;file&gt; <span class="comment"># 查看该文件每次提交记录</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> -p &lt;file&gt; <span class="comment"># 查看每次详细修改内容的diff</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> -p -2 <span class="comment"># 查看最近两次详细修改内容的diff</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span> <span class="comment">#查看提交统计信息</span></span><br><span class="line"> tig</span><br><span class="line"></span><br><span class="line">Mac上可以使用tig代替diff和<span class="built_in">log</span>，brew install tig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Git 本地分支管理</span><br><span class="line">查看、切换、创建和删除分支</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git br -r <span class="comment"># 查看远程分支</span></span><br><span class="line"></span><br><span class="line">git br &lt;new_branch&gt; <span class="comment"># 创建新的分支</span></span><br><span class="line"></span><br><span class="line"> git br -v <span class="comment"># 查看各个分支最后提交信息</span></span><br><span class="line"></span><br><span class="line">git br --merged <span class="comment"># 查看已经被合并到当前分支的分支</span></span><br><span class="line"></span><br><span class="line">git br --no-merged <span class="comment"># 查看尚未被合并到当前分支的分支</span></span><br><span class="line"></span><br><span class="line">git co &lt;branch&gt; <span class="comment"># 切换到某个分支</span></span><br><span class="line"></span><br><span class="line">git co -b &lt;new_branch&gt; <span class="comment"># 创建新的分支，并且切换过去</span></span><br><span class="line"></span><br><span class="line">git co -b &lt;new_branch&gt; &lt;branch&gt; <span class="comment"># 基于branch创建新的new_branch</span></span><br><span class="line"></span><br><span class="line">git co <span class="variable">$id</span> <span class="comment"># 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除</span></span><br><span class="line"></span><br><span class="line">git co <span class="variable">$id</span> -b &lt;new_branch&gt; <span class="comment"># 把某次历史提交记录checkout出来，创建成一个分支</span></span><br><span class="line"></span><br><span class="line">git br -d &lt;branch&gt; <span class="comment"># 删除某个分支</span></span><br><span class="line"></span><br><span class="line">git br -D &lt;branch&gt; <span class="comment"># 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</span></span><br><span class="line"> 分支合并和reba</span><br><span class="line">git merge &lt;branch&gt; <span class="comment"># 将branch分支合并到当前分支</span></span><br><span class="line"></span><br><span class="line">git merge origin/master --no-ff <span class="comment"># 不要Fast-Foward合并，这样可以生成merge提交</span></span><br><span class="line"></span><br><span class="line">git rebase master &lt;branch&gt; <span class="comment"># 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt;</span></span><br><span class="line">Git补丁管理(方便在多台机器上开发同步时用)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git merge &lt;branch&gt; <span class="comment"># 将branch分支合并到当前分支</span></span><br><span class="line"></span><br><span class="line">git merge origin/master --no-ff <span class="comment"># 不要Fast-Foward合并，这样可以生成merge提交</span></span><br><span class="line"></span><br><span class="line">git rebase master &lt;branch&gt; <span class="comment"># 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt;</span></span><br><span class="line"></span><br><span class="line">Git暂存管</span><br><span class="line">git stash <span class="comment"># 暂存</span></span><br><span class="line"></span><br><span class="line">git stash list <span class="comment"># 列所有stash</span></span><br><span class="line"></span><br><span class="line">git stash apply <span class="comment"># 恢复暂存的内容</span></span><br><span class="line"></span><br><span class="line">git stash drop <span class="comment"># 删除暂存区</span></span><br><span class="line"></span><br><span class="line">Git远程分支管理</span><br><span class="line"></span><br><span class="line">git pull <span class="comment"># 抓取远程仓库所有分支更新并合并到本地</span></span><br><span class="line"></span><br><span class="line">git pull --no-ff <span class="comment"># 抓取远程仓库所有分支更新并合并到本地，不要快进合并</span></span><br><span class="line"></span><br><span class="line">git fetch origin <span class="comment"># 抓取远程仓库更新</span></span><br><span class="line"> </span><br><span class="line">git merge origin/master <span class="comment"># 将远程主分支合并到本地当前分支</span></span><br><span class="line"></span><br><span class="line">git co --track origin/branch <span class="comment"># 跟踪某个远程分支创建相应的本地分支</span></span><br><span class="line"></span><br><span class="line">git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; <span class="comment"># 基于远程分支创建本地分支，功能同上</span></span><br><span class="line"></span><br><span class="line">git push <span class="comment"># push所有分支</span></span><br><span class="line"></span><br><span class="line">git push origin master <span class="comment"># 将本地主分支推到远程主分支</span></span><br><span class="line"> </span><br><span class="line">git push -u origin master <span class="comment"># 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)</span></span><br><span class="line"> </span><br><span class="line">git push origin &lt;local_branch&gt; <span class="comment"># 创建远程分支， origin是远程仓库名</span></span><br><span class="line"></span><br><span class="line">git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; <span class="comment"># 创建远程分支</span></span><br><span class="line"></span><br><span class="line">git push origin :&lt;remote_branch&gt; <span class="comment">#先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支</span></span><br><span class="line"></span><br><span class="line">Git远程仓库管</span><br><span class="line">git remote -v <span class="comment"># 查看远程服务器地址和仓库名称</span></span><br><span class="line"></span><br><span class="line">git remote show origin <span class="comment"># 查看远程服务器仓库状态</span></span><br><span class="line"></span><br><span class="line">git remote add origin git@ github:robbin/robbin_site.git <span class="comment"># 添加远程仓库地址</span></span><br><span class="line"></span><br><span class="line">git remote set-url origin git@ github.com:robbin/robbin_site.git <span class="comment"># 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库</span></span><br><span class="line"></span><br><span class="line">创建远程仓库</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> --bare robbin_site robbin_site.git <span class="comment"># 用带版本的项目创建纯版本仓库</span></span><br><span class="line"></span><br><span class="line">scp -r my_project.git git@ git.csdn.net:~ <span class="comment"># 将纯仓库上传到服务器上</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> robbin_site.git &amp;&amp; <span class="built_in">cd</span> robbin_site.git &amp;&amp; git --bare init <span class="comment"># 在服务器创建纯仓库</span></span><br><span class="line"></span><br><span class="line">git remote add origin git@ github.com:robbin/robbin_site.git <span class="comment"># 设置远程仓库地址</span></span><br><span class="line"></span><br><span class="line">git push -u origin master <span class="comment"># 客户端首次提交</span></span><br><span class="line"></span><br><span class="line">git push -u origin develop <span class="comment"># 首次将本地develop分支提交到远程develop分支，并且track</span></span><br><span class="line"></span><br><span class="line">git remote set-head origin master <span class="comment"># 设置远程仓库的HEAD指向master分支</span></span><br><span class="line"></span><br><span class="line">也可以命令设置跟踪远程库和本地库</span><br><span class="line"></span><br><span class="line">git branch --set-upstream master origin/master</span><br><span class="line"></span><br><span class="line">git branch --set-upstream develop origin/develop</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git的使用&quot;&gt;&lt;a href=&quot;#Git的使用&quot; class=&quot;headerlink&quot; title=&quot;Git的使用&quot;&gt;&lt;/a&gt;Git的使用&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;Git是先进的分布式版本控制系统，克隆文件的速度非常快&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    
    <category term="基础知识" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>远程调试</title>
    <link href="http://example.com/posts/19038/"/>
    <id>http://example.com/posts/19038/</id>
    <published>2022-08-22T13:07:17.000Z</published>
    <updated>2023-08-24T12:31:49.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h1><ol><li>将新编译出来的plug与pdb程序替换入目标程序</li><li>在vs文件夹中找到对应版本的远程调试(X86或X64)文件夹，将其复制到相应的服务器环境下</li><li>运行文件夹中的.exe文件，在tool中选择VS Remote Debugging Monitor</li><li>在options中选择接口，选择连接时间</li><li>在本地VS中，tools-&gt;attach Process-&gt;Remote-&gt;IP-&gt;refresh-&gt;选择对应线程</li></ol><h1 id="使用vs调试器调试C"><a href="#使用vs调试器调试C" class="headerlink" title="使用vs调试器调试C++"></a>使用vs调试器调试C++</h1><ol><li>创建新项目</li><li>设置断点</li><li>导航代码</li><li>检查数据提示中的变量</li><li>编辑代码并继续调试</li><li>后续步骤</li></ol><h2 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h2><h2 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h2><blockquote><p>断点是一个标记：指示文件在哪里挂起，方便查看变量的值或者内存，或确认代码的分支是否运行。</p><ol><li>若要设置断点，单击函数左侧的滚动条槽<br> 或者选择代码行，按F9</li><li>然后按F5<br> 或者选择调试&gt;开始调试<br> 调试器会在设置断点的位置暂停。<br> 调试器和应用程序在该处暂停的语句由黄色箭头指示。指示行的调用未执行</li></ol></blockquote><ol start="3"><li>如果循环或者递归中存在断点，或者有许多频繁单步执行的断点，使用条件断点确保代码在满足特定条件时挂起。</li></ol><h2 id="导航代码"><a href="#导航代码" class="headerlink" title="导航代码"></a>导航代码</h2><p>vs2017开始新增的有用的代码导航命令<br>可以悬停在语句上，直至绿色的运行到单击处，点击</p><h2 id="检查数据提示中的变量"><a href="#检查数据提示中的变量" class="headerlink" title="检查数据提示中的变量"></a>检查数据提示中的变量</h2><ol><li>在当前代码行中，将鼠标悬停在对象上以显示数据提示，若出现意外值，则会表示在前一代码行或调用的代码行上出现bug</li><li>展开数据提示以查看c1对象的当前属性值</li><li>如果要固定数据提示，以便在执行代码时继续查看，点击小图钉图标。</li></ol><h2 id="编辑代码并继续调试"><a href="#编辑代码并继续调试" class="headerlink" title="编辑代码并继续调试"></a>编辑代码并继续调试</h2><p>调试会话期间发现一个要在代码中测试的修改，也可执行此操作。<br>按F10进行单步跳过。</p><h2 id="调试的几种方法"><a href="#调试的几种方法" class="headerlink" title="调试的几种方法"></a>调试的几种方法</h2><ol><li>快捷键F5在开发过程中进行调试，一般用于自己开发时所用，代码相对独立而且体量小。</li><li>逐语句F11，逐过程F10，跳出shift+F11，控制代码运行位置，直至被测段结束。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;远程调试&quot;&gt;&lt;a href=&quot;#远程调试&quot; class=&quot;headerlink&quot; title=&quot;远程调试&quot;&gt;&lt;/a&gt;远程调试&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;将新编译出来的plug与pdb程序替换入目标程序&lt;/li&gt;
&lt;li&gt;在vs文件夹中找到对应版本的远程调试(X86</summary>
      
    
    
    
    
    <category term="基础知识" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式使用</title>
    <link href="http://example.com/posts/60186/"/>
    <id>http://example.com/posts/60186/</id>
    <published>2022-08-22T13:04:59.000Z</published>
    <updated>2023-08-24T12:31:49.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用正则表达式进行查找"><a href="#使用正则表达式进行查找" class="headerlink" title="使用正则表达式进行查找"></a>使用正则表达式进行查找</h1><h2 id="正则表达式的元字符"><a href="#正则表达式的元字符" class="headerlink" title="正则表达式的元字符"></a>正则表达式的元字符</h2><table><thead><tr><th align="center">符号</th><th>描述</th><th>示例</th><th>解释</th><th>匹配输入</th></tr></thead><tbody><tr><td align="center">[]</td><td>可接收的字符列表</td><td>[efgh]</td><td>efgh的任意一个字符</td><td></td></tr><tr><td align="center">^</td><td>不可接收的字符列表</td><td>[^abc]</td><td>除abc的任意一个字符，包括数字与特殊符号</td><td></td></tr><tr><td align="center">-</td><td>连字符</td><td>[A-Z]</td><td>任意个大写字母</td><td></td></tr><tr><td align="center">.</td><td>匹配除\n外的任意字符，如果匹配本身，则使用\\</td><td>a…b</td><td>以a开头,以b结尾的中间包含任意长度为3的字符串</td><td>aaaab</td></tr><tr><td align="center">\\d</td><td>匹配单个数字,相当于[0-9]</td><td>\\d{3}(\\d)?</td><td>以单个非数字字符开头，后接任意个数字字符串</td><td>a,a123,a789</td></tr><tr><td align="center">\\D</td><td>匹配单个非数字，相当于[ ^0-9]</td><td>\ \D(\\d)*</td><td>以单个非数字字符开头，后接任意个数字字符串</td><td>a,a123,a789</td></tr></tbody></table><h2 id="常用的正则表达式字符"><a href="#常用的正则表达式字符" class="headerlink" title="常用的正则表达式字符"></a>常用的正则表达式字符</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><p>[ ]表示或比如我们把几个元字符加入其中[A-Za-z0-9-_]就表示大写字母或者小写字母、或者0-9数字，或者</p></li><li><p>[^]表示匹配的位置是不是方括号里面的东西</p></li><li><p>( )这是一个圆括号将里面包含的满足匹配的数都放入group，我们再讲group中满足要求的数字取出来即可</p></li></ol><h3 id="量"><a href="#量" class="headerlink" title="量"></a>量</h3><ol><li>*表示前一个字符出现0次或多次</li><li>+表示前一个字符出现1次或多次</li><li>？表示前一个字符出现0次或一次。</li><li>{n}表示前一个字符恰出现n次</li><li>{n,}表示前一个字符出现次数大于n次</li><li>{n,m}表示前一个字符出现n-m次</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用正则表达式进行查找&quot;&gt;&lt;a href=&quot;#使用正则表达式进行查找&quot; class=&quot;headerlink&quot; title=&quot;使用正则表达式进行查找&quot;&gt;&lt;/a&gt;使用正则表达式进行查找&lt;/h1&gt;&lt;h2 id=&quot;正则表达式的元字符&quot;&gt;&lt;a href=&quot;#正则表达式的元字</summary>
      
    
    
    
    
    <category term="基础知识" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>TCP</title>
    <link href="http://example.com/posts/56432/"/>
    <id>http://example.com/posts/56432/</id>
    <published>2022-08-22T13:02:58.000Z</published>
    <updated>2023-08-24T12:31:49.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP数据格式"><a href="#TCP数据格式" class="headerlink" title="TCP数据格式"></a>TCP数据格式</h2><p><img src="/../img/format,f_auto"></p><p>首部至少20个字节</p><h3 id="TCP头部详解"><a href="#TCP头部详解" class="headerlink" title="TCP头部详解"></a>TCP头部详解</h3><p><font color="blue">详见RTP一文</font></p><p>TCP的保留位有的是3，有的是6，都有可能</p><p>UDP的首部中有16位的字段记录了整个UDP报文的长度:(首部+数据)[数据长度其实冗余，为了对齐]</p><p>而TCP仅有4位的字段记录了TCP报文的首部长度(网络层的总长度-网络头-TCP头)</p><p>检验和也是通过伪首部进行计算，伪首部不传递</p><h3 id="TCP的几个要点"><a href="#TCP的几个要点" class="headerlink" title="TCP的几个要点"></a>TCP的几个要点</h3><ul><li>可靠传输:出错重传</li><li>流量控制:不会大于接收窗口</li><li>拥塞控制</li></ul><h2 id="ARQ协议进行可靠传输"><a href="#ARQ协议进行可靠传输" class="headerlink" title="ARQ协议进行可靠传输"></a>ARQ协议进行可靠传输</h2><h3 id="ARQ简介"><a href="#ARQ简介" class="headerlink" title="ARQ简介"></a>ARQ简介</h3><blockquote><p>ARQ协议，即自动重传请求（Automatic Repeat-reQuest），是OSI模型中的错误纠正协议之一。</p></blockquote><ul><li><p>它通过使用确认和重传这两个机制，在不可靠服务的基础上实现可靠的信息传输。</p></li><li><p>如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。</p></li><li><p>重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组</p></li><li><p>ARQ包括停止等待ARQ协议和 连续ARQ协议</p></li></ul><h3 id="停止等待ARQ"><a href="#停止等待ARQ" class="headerlink" title="停止等待ARQ"></a>停止等待ARQ</h3><h4 id="正常传输"><a href="#正常传输" class="headerlink" title="正常传输"></a>正常传输</h4><ol><li><p>停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p></li><li><p>全双工通信的双方既是发送方也是接收方。</p></li><li><p>为了讨论问题的方便，我们仅考虑 A 发送数据，而 B 接收数据并发送确认。因此 A 叫做发送方，而 B 叫做接收方</p><p><img src="/../img/format,f1_auto"></p></li></ol><h4 id="传输出现差错"><a href="#传输出现差错" class="headerlink" title="传输出现差错"></a>传输出现差错</h4><p>在接收方 B 会出现两种情况：</p><ul><li>B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。</li><li>M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。</li></ul><p>在这两种情况下，B 都不会发送任何信息。A都必须重发分组，直到B正确接收为止，这样才能实现可靠通信。</p><h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><p>A确认B收到信息的方法</p><ol><li>A 为每一个已发送的分组都设置了一个超时计时器。</li><li>A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。</li></ol><h5 id="丢失确认"><a href="#丢失确认" class="headerlink" title="丢失确认"></a>丢失确认</h5><p>若A在超时计时器规定时间内没有收到B的确认ACK，就重发该分组。无论是自己发送的分组出错、丢失了，或者 是 B 发送的确认丢失了。<br>假定 B 又收到了重传的分组 M1。这时 B 应采取两个行动：</p><ul><li>丢弃这个重复的分组 M1，不向上层交付。</li><li>向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认</li></ul><p><img src="/../img/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5ZWKYemYv-iKsQ==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h5 id="编号"><a href="#编号" class="headerlink" title="编号"></a>编号</h5><p>若分组正确到达B，但B回送的确认ACK丢失或延迟了，A未收到B的确认，会超时重发。B 可能会收到重复的 M1 。B如何知道收到了重复的分组，需要丢弃呢？</p><ol><li>A为每一个发送的分组都进行编号。若B收到了编号相同的分组，则认为收到了重复分组，丢弃重复的分组，并回送确认（之所以会收到重复的分组就是因为发送端没有正常收到确认）。</li><li>B为发送的确认也进行编号，指示该确认是对哪一个分组的确认。</li></ol><p>A根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其丢弃。</p><h5 id="迟到确认"><a href="#迟到确认" class="headerlink" title="迟到确认"></a>迟到确认</h5><p>传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。</p><ol><li>A会超时重发M1， 则B 收到重复的 M1，同样要丢弃重复的 M1，并重传确认分组。</li><li>稍后B迟到的确认和重发的确认都会到达A，A收到重复的确认，对重复的确认的处理很简单：收下后就丢弃。</li></ol><p><img src="/../img/watermark,tyape_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5ZWKYemYv-iKsQ==,size_20,color_FFFFFF,t_70,g_se,x_16"></p><h3 id="连续ARQ"><a href="#连续ARQ" class="headerlink" title="连续ARQ"></a>连续ARQ</h3><h4 id="流水线传输"><a href="#流水线传输" class="headerlink" title="流水线传输"></a>流水线传输</h4><p>为了提高传输效率，发送方连续发送多个分组，不必在发完一帧后等待对方的确认，使信道上一直有数据不断传送。</p><p><img src="/../img/121.png"></p><p>流水线传输通常要求</p><ul><li>必须增加序号范围，因为每个输送中的分组（不计算重传的）必须有一个唯一的序号，因为可能存在有多个在输送中未确认的报文。</li><li>协议的发送方和接收方要能缓存多个分组。发送方至少要能缓存那些已发送但没有确认的分组，接收方可能要缓存那些已正确接收的分组。</li><li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。</li><li>解决流水线传输的差错有两种<strong>滑动窗口协议</strong>：<strong>回退N(Go-Back- N，GBN)</strong> 和<strong>选择重传(Selective Repeat，SR)</strong> 。</li></ul><h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><p>即接收方不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认。因此，接收方不必对中间某个确认包的丢失进行重传，因为累积确认的效果，一旦一个较大序号的ACK被接收到，则表示这个包之前的包都已经成功收到。</p><p>如果接受方收到了这个确认，则表示到这个分组为止之前的所有分组都已正确收到了。</p><p>但同时累积确认也有缺陷，例如发送方传送了5个包，但是第3个包丢失了，第4和第5个正常。这时根据累积确认，接收方只能传送前两个包的ACK（按序到达的最后一个）。在接收到第2个包ACK的发送方不知道后面3个包是否到达，就会将后3个包全部进行重传。即：Go-back-N。</p><p>优点：容易实现，即使部分确认丢失也不必重传。<br>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。</p><p><img src="/../img/131.png"></p><p>注：TCP并不是每一个报文段都会回复ACK的，可能会对一个报文段发送一个ACK（M0、M2），也可能会对多个报文段发送1个ACK（M3+M4+M5）</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>滑动窗口协议（Sliding Window Protocol）以基于分组的数据传输协议为特征。因此该协议适用于对按顺序传送分组的可靠性要求较高的环境</p><ol><li>提供TCP的可靠性（最基本的传输可靠性来源于“确认重传”机制），避免丢包</li><li>提供TCP的流控特性，用于网络数据传输时的流量控制，以避免拥塞的发生</li><li>滑动窗口协议在发送方和接收方之间各自维持一个滑动窗口，发送方是发送窗口，接收方是接收窗口（两个窗口大小不一定相同）</li><li>使用滑动窗口协议控制发送方和接收方所能发送和接收的分组的数量和编号</li><li>它允许发送方发送多个分组而不需等待确认，TCP的滑动窗口是以字节为单位的</li><li>每收到一个确认，发送方就把发送窗口向前滑动。</li></ol><h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><ol><li>已发送并收到确认的数据（不在发送窗口和发送缓冲区之内）</li><li>已发送但未收到确认的数据（位于发送窗口之内）</li><li>允许发送但尚未发送的数据（位于发送窗口之内）</li><li>发送窗口之外的缓冲区内暂时不允许发送的数据</li></ol><h4 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h4><ol><li>已发送确认并交付主机的数据（不在接收窗口和接收缓冲区之内）</li><li>未按序收到的数据（位于接收窗口之内）</li><li>允许的数据（位于接收窗口之内）</li><li>不允许接收的数据（位于发送窗口之内）</li></ol><p><img src="/../img/141.png"></p><p><img src="/../img/151.png"></p><h3 id="两种解决方案"><a href="#两种解决方案" class="headerlink" title="两种解决方案"></a>两种解决方案</h3><h4 id="1-回退Nzhen"><a href="#1-回退Nzhen" class="headerlink" title="1.回退Nzhen"></a>1.回退Nzhen</h4><p>如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。</p><p>发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。</p><p>这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。</p><p>可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。</p><h4 id="2-选择重传"><a href="#2-选择重传" class="headerlink" title="2. 选择重传"></a>2. 选择重传</h4><p>选择重传协议只重传真正出错或者丢失的帧，那怎么实现呢？</p><ol><li>发送方维持着一个窗口，包含可发送或已发送但未被确认的序号。</li><li>接收方维持着一个窗口，包含可接收的序号，每个序号还保留一个缓冲区。与每个缓冲区项相关联的还有一个标志位，用来指明缓冲区是满的还是空的。</li><li>每到达一个帧，接收方通过检查它的序号，看是否落在窗口内。如果确实落在窗口内且之前没有接收过，则接收该分组然后保存在缓冲区并返回一个确认。等前面这些帧都到达后一起交付给上层</li><li>发送端每个发送缓冲都设有一个超时一个超时计时器，一个超时事件发生后相应缓冲区的帧就会被重发</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP&quot;&gt;&lt;a href=&quot;#TCP&quot; class=&quot;headerlink&quot; title=&quot;TCP&quot;&gt;&lt;/a&gt;TCP&lt;/h1&gt;&lt;h2 id=&quot;TCP数据格式&quot;&gt;&lt;a href=&quot;#TCP数据格式&quot; class=&quot;headerlink&quot; title=&quot;TCP数据格式</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络层_UDP</title>
    <link href="http://example.com/posts/32319/"/>
    <id>http://example.com/posts/32319/</id>
    <published>2022-08-21T14:14:29.000Z</published>
    <updated>2023-08-24T12:31:49.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><ul><li>TCP:传输控制协议</li><li>UDP:用户数据报协议</li></ul><h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><p><img src="/../img/2580638-20211024203122288-1643698355.png"></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ol><li>udp无连接，减少了建立与释放连接的开销</li><li>udp尽最大努力传输，不保证可靠交付</li><li>不需维护复杂参数，首部只有8字节(TCP至少20字节)</li></ol><p><img src="/../img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE0Mjc5Nw==,size_16,color_FFFFFF,t_70"></p><p>UDP长度:首部长度+数据长度</p><p>检验和:伪首部+首部+数据(伪首部12字节，是固定的)</p><p>伪首部:仅在计算检验时起作用，不会传递给网络层</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>UDP端口两个字节，即为2^16&#x3D;65536.取值范围0-65535.</p><p>在客户端中的源端口是临时开启的随机端口</p><p>防火墙通过开启或者关闭端口提高安全性</p><h4 id="常用命令行"><a href="#常用命令行" class="headerlink" title="常用命令行"></a>常用命令行</h4><p>netstat-an:查看被占用的端口</p><p>netstat-anb:查看被占用的端口，占用端口的应用程序</p><p>telent 主机 端口:查看可否可以访问主机的某个端口</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;传输层协议&quot;&gt;&lt;a href=&quot;#传输层协议&quot; class=&quot;headerlink&quot; title=&quot;传输层协议&quot;&gt;&lt;/a&gt;传输层协议&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;TCP:传输控制协议&lt;/li&gt;
&lt;li&gt;UDP:用户数据报协议&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;T</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>ffmpag解码基础</title>
    <link href="http://example.com/posts/40917/"/>
    <id>http://example.com/posts/40917/</id>
    <published>2022-08-21T11:58:36.000Z</published>
    <updated>2023-08-24T12:51:53.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ffmpeg软硬解码基础"><a href="#ffmpeg软硬解码基础" class="headerlink" title="ffmpeg软硬解码基础"></a>ffmpeg软硬解码基础</h1><h2 id="解封装"><a href="#解封装" class="headerlink" title="解封装"></a>解封装</h2><ol><li>av_register_all():注册所有解封装与加封装格式，支持所有格式，调用一次即可   </li><li>avformat_network_init():支持RTSP(相机原格式)，HTTP，可以直接打开。</li><li>avforamt_open_input(…):打开并解析出里面的格式。</li><li>avformat_find_stream_info(…):探测格式，找出流信息</li><li>av_find_best_stream(…):找到音频流或视频流   </li><li>AVFormatContext AVStream AVPacket三个结构体（参数的上下文）  </li><li>av_read_frame(…)读取AVPacket并返回数据。</li></ol><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><hr><blockquote><p>介绍FFmpeg用法之前需要了解的基础知识</p></blockquote><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><hr><p>视频文件本身就是一个容器(container),里面包括了视频和音频,也有可能有字幕等内容</p><p>常见的容器格式有以下几种。一般来说，视频文件的后缀反映了容器格式。</p><ul><li>MP4</li><li>MKV</li><li>WebM</li><li>AVI</li></ul><p>下面的命令能查看FFmpeg支持的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffmpeg -formats</span></span><br></pre></td></tr></table></figure><h2 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h2><hr><p>视频和音频都需要经过编码，才能保存成文件。不同的编码格式（CODEC），有不同的压缩率，会导致文件大小和清晰度的差异。</p><p>常用的编码格式</p><ul><li>H.262</li><li>H.264</li><li>H.265</li></ul><p>常用的音频编码格式如下。</p><ul><li>MP3</li><li>AAC</li></ul><p>上面所有这些都是有损的编码格式，编码后会损失一些细节，以换取压缩后较小的文件体积。无损的编码格式压缩出来的文件体积较大，这里就不介绍了。</p><p>下面的命令可以查看 FFmpeg 支持的编码格式，视频编码和音频编码都在内。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ffmpeg -codecs</span><br></pre></td></tr></table></figure><h2 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h2><hr><p>编码器（encoders）是实现某种编码格式的库文件。只有安装了某种格式的编码器，才能实现该格式视频&#x2F;音频的编码和解码。</p><p>以下是一些 FFmpeg 内置的视频编码器。</p><ul><li>libx264：最流行的开源 H.264 编码器</li><li>NVENC：基于 NVIDIA GPU 的 H.264 编码器</li><li>libx265：开源的 HEVC 编码器</li><li>libvpx：谷歌的 VP8 和 VP9 编码器</li><li>libaom：AV1 编码器</li></ul><p>音频编码器</p><ul><li>libfdk-aac</li><li>aac</li></ul><p>下面的命令可以查看 FFmpeg 已安装的编码器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffmpeg -encoders</span></span><br></pre></td></tr></table></figure><h1 id="FFmpeg的使用格式"><a href="#FFmpeg的使用格式" class="headerlink" title="FFmpeg的使用格式"></a>FFmpeg的使用格式</h1><hr><p>FFmpeg 的命令行参数非常多，可以分成五个部分</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffmpeg &#123;1&#125; &#123;2&#125; -i &#123;3&#125; &#123;4&#125; &#123;5&#125;</span></span><br></pre></td></tr></table></figure><p>五个参数依次是</p><ol><li>全局参数</li><li>输入文件参数</li><li>输入文件</li><li>输出文件参数</li><li>输出文件</li></ol><p>如果不指明编码格式，FFmpeg 会自己判断输入文件的编码。因此，上面的命令可以简单写成下面的样子。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffmpeg -i input.avi output.mp4</span></span><br></pre></td></tr></table></figure><h2 id="常用命令行参数"><a href="#常用命令行参数" class="headerlink" title="常用命令行参数"></a>常用命令行参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-c：指定编码器</span><br><span class="line">-c copy：直接复制，不经过重新编码（这样比较快）</span><br><span class="line">-c:v：指定视频编码器</span><br><span class="line">-c:a：指定音频编码器</span><br><span class="line">-i：指定输入文件</span><br><span class="line">-an：去除音频流</span><br><span class="line">-vn： 去除视频流</span><br><span class="line">-preset：指定输出的视频质量，会影响文件的生成速度，有以下几个可用的值 ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow。</span><br><span class="line">-y：不经过确认，输出时直接覆盖同名文件。</span><br></pre></td></tr></table></figure><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><ol><li><p>查看视频文件的元信息，比如编码格式和比特率，可以只用-i参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffmpeg -i input.mp4</span></span><br><span class="line"> 上面命令会输出很多冗余信息，加上`-hide_banner`参数，可以只显示元信息。</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffmpeg -i input.mp4 -hide_banner</span></span><br></pre></td></tr></table></figure></li><li><p>转换编码格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffmpeg -i [input.file] -c:v libx264 output.mp4</span></span><br></pre></td></tr></table></figure><blockquote><p>   将视频文件从一种编码转成另一种编码，只需指定输出文件的视频编码器即可</p></blockquote></li><li><p>转容器格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffmpeg -i input.mp4 -c copy output.webm</span></span><br></pre></td></tr></table></figure></li><li><p>调整码率</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">调整码率（transrating）指的是，改变编码的比特率，一般用来将视频文件的体积变小。下面的例子指定码率最小为964K，最大为3856K，缓冲区大小为 2000K。</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffmpeg \</span></span><br><span class="line"><span class="language-bash">-i input.mp4 \</span></span><br><span class="line"><span class="language-bash">-minrate 964K -maxrate 3856K -bufsize 2000K \</span></span><br><span class="line"><span class="language-bash">output.mp</span></span><br></pre></td></tr></table></figure></li><li><p>改变分辨率</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffmpeg \</span></span><br><span class="line"><span class="language-bash">-i input.mp4 \</span></span><br><span class="line"><span class="language-bash">-vf scale=480:-1 \</span></span><br><span class="line"><span class="language-bash">output.mp4</span></span><br></pre></td></tr></table></figure></li><li><p>提取音频</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffmpeg \</span></span><br><span class="line"><span class="language-bash">-i input.mp4 \</span></span><br><span class="line"><span class="language-bash">-vn -c:a copy \</span></span><br><span class="line"><span class="language-bash">output.aac</span></span><br></pre></td></tr></table></figure></li><li><p>添加音轨</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffmpeg \</span></span><br><span class="line"><span class="language-bash">-i input.aac -i input.mp4 \</span></span><br><span class="line"><span class="language-bash">output.mp4</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ffmpeg软硬解码基础&quot;&gt;&lt;a href=&quot;#ffmpeg软硬解码基础&quot; class=&quot;headerlink&quot; title=&quot;ffmpeg软硬解码基础&quot;&gt;&lt;/a&gt;ffmpeg软硬解码基础&lt;/h1&gt;&lt;h2 id=&quot;解封装&quot;&gt;&lt;a href=&quot;#解封装&quot; class</summary>
      
    
    
    
    
    <category term="音视频" scheme="http://example.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>格式参数</title>
    <link href="http://example.com/posts/8232/"/>
    <id>http://example.com/posts/8232/</id>
    <published>2022-08-21T11:57:07.000Z</published>
    <updated>2023-08-24T12:31:49.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PCM音频参数"><a href="#PCM音频参数" class="headerlink" title="PCM音频参数"></a>PCM音频参数</h1><p>采样率：sample_rate 44100(CD)：一秒钟多少<br>通道：channels(左右声道)<br>样本大小(格式) sample size<br>-AV_SAMPLE_FMT_S16<br>_AV_SAMPLE_FMT_FLTP（32位，通过浮点运算，解码后重采样）<br>声道独立存储或集中存储  </p><h1 id="MP4格式分析"><a href="#MP4格式分析" class="headerlink" title="MP4格式分析"></a>MP4格式分析</h1><p><img src="https://img-blog.csdnimg.cn/15dcbaed167649b587d1ba0bc00b3e6b.png">  </p><h1 id="H264"><a href="#H264" class="headerlink" title="H264"></a>H264</h1><ol><li>视频编码层面（VCl）：视频数据的内容  </li><li>网络抽象层面（NAL）：格式化数据并提供头信息</li></ol><h2 id="NAL单元"><a href="#NAL单元" class="headerlink" title="NAL单元"></a>NAL单元</h2><p>往往帧前面带有00 00 00 01或00 00 01分隔符，一般来说编码器编出的首帧数据是PPS和SPS，接着为I帧。</p><h2 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h2><p>I帧：关键帧，存放一帧视频的完整数据，可以被单独解码。<br>P帧：针对前一帧的变化<br>B帧：针对前一帧和后一帧的变化<br>为了使视频播放帧次序相同，需要有缓冲帧。最后要提取缓冲帧，传空即可。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PCM音频参数&quot;&gt;&lt;a href=&quot;#PCM音频参数&quot; class=&quot;headerlink&quot; title=&quot;PCM音频参数&quot;&gt;&lt;/a&gt;PCM音频参数&lt;/h1&gt;&lt;p&gt;采样率：sample_rate 44100(CD)：一秒钟多少&lt;br&gt;通道：channels(左右声</summary>
      
    
    
    
    
    <category term="音视频" scheme="http://example.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频基础知识2</title>
    <link href="http://example.com/posts/53272/"/>
    <id>http://example.com/posts/53272/</id>
    <published>2022-08-21T11:52:06.000Z</published>
    <updated>2023-08-24T12:31:49.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="像素格式"><a href="#像素格式" class="headerlink" title="像素格式"></a>像素格式</h1><h2 id="像素格式的种类"><a href="#像素格式的种类" class="headerlink" title="像素格式的种类"></a>像素格式的种类</h2><p>BGRA，RGBA，ARGB32(A是不透明度)，RGB32，YUV420(y:亮度，存储更小，算法更强)<br>R&#x3D;Y+1.4075*(V-128)<br>G&#x3D;Y-0.3455*(U-128)-0.7169*(V-128)<br>B&#x3D;Y+1.779*(U-128)  </p><h2 id="RGB图像存储方式"><a href="#RGB图像存储方式" class="headerlink" title="RGB图像存储方式"></a>RGB图像存储方式</h2><p><img src="https://img-blog.csdnimg.cn/20210224172853971.png"><br>数据是连续存储的，每个像素都由3个字节组成，因此对于 w*h 像素的 rgb 图像，则需要 3*w*h 个字节来表示<br>像素拷贝保证其是四或者八的倍数再进行整体拷贝，否则按行拷贝，因为在进行解析是会在像素块末加东西来保证对其。  </p><h2 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h2><ul><li>Y表示亮度，也就是灰度值。</li><li>而U和V表示的则是色度。<br><img src="https://img-blog.csdnimg.cn/20210224174355844.png"><br>该存储方式是YUV420P:尾有P代表平面存储。<br>YUV分为不同的采样格式：</li></ul><ol><li>YUV4:4:4  </li><li>YUV4:2:2</li><li>YUV4:2:0</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;像素格式&quot;&gt;&lt;a href=&quot;#像素格式&quot; class=&quot;headerlink&quot; title=&quot;像素格式&quot;&gt;&lt;/a&gt;像素格式&lt;/h1&gt;&lt;h2 id=&quot;像素格式的种类&quot;&gt;&lt;a href=&quot;#像素格式的种类&quot; class=&quot;headerlink&quot; title=&quot;像素格</summary>
      
    
    
    
    
    <category term="音视频" scheme="http://example.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频基础知识</title>
    <link href="http://example.com/posts/39180/"/>
    <id>http://example.com/posts/39180/</id>
    <published>2022-08-18T14:40:13.000Z</published>
    <updated>2023-08-24T12:31:49.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="封装，解码，重采样，像素格式转换"><a href="#封装，解码，重采样，像素格式转换" class="headerlink" title="封装，解码，重采样，像素格式转换"></a>封装，解码，重采样，像素格式转换</h1><hr><h3 id="MPEG-4"><a href="#MPEG-4" class="headerlink" title="MPEG-4"></a>MPEG-4</h3><blockquote><p>MPEG-4是一套用于音频，视频信息的压缩编码标准  </p></blockquote><h2 id="常见的封装格式"><a href="#常见的封装格式" class="headerlink" title="常见的封装格式"></a>常见的封装格式</h2><ol><li>AVI 压缩标准可以任意选择</li><li>FLV ts 流媒体格式</li><li>ASF</li><li>MP4</li></ol><h2 id="常见的编码格式"><a href="#常见的编码格式" class="headerlink" title="常见的编码格式"></a>常见的编码格式</h2><ol><li>视频:H264(根据上下帧编码)，wmv，XviD，mjpeg(不依赖上下文)</li><li>音频格式:AAC(视频内的音频，有损压缩)，MP3(有损压缩)，ape(无损压缩)，flac</li></ol><h2 id="封装格式和编码格式"><a href="#封装格式和编码格式" class="headerlink" title="封装格式和编码格式"></a>封装格式和编码格式</h2><p><img src="https://upload-images.jianshu.io/upload_images/2173870-d55a64de24716910.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp"><br>封装格式(格式头)+视频编码帧+音频编码帧+视频编码帧+音频编码帧…  </p><ol><li>对于MP4格式头来说：<br>box音视频信息(编码和格式关键帧索引)<br>音频帧与视频帧不会相同  </li><li>视频编码帧<br>h264(NAL:网络提取层+VCL:视频编码层)(SPS:序列参数集PPS:图像的宽高)(I,B,P帧)<br>h264，h265根据封装格式解码为YUV格式-&gt;转为RGB显示<br>解码有软解和硬解  <ul><li>软解：即通过软件让CPU来对视频进行解码处理</li><li>硬解：指不借助于CPU，而通过专用的子卡设备来独立完成视频解码任务</li></ul></li><li>音频编码帧解码<br>AAC，(APE,FLAC无损压缩)，PCM原始音频  <ul><li>一般解码为FLT,PCM-&gt;转码为16位</li></ul></li></ol><h1 id="混音"><a href="#混音" class="headerlink" title="混音"></a>混音</h1><hr><blockquote><p> 将两路或者多路音频混合在一起，形成一路音频流，也叫合流</p></blockquote><p>混音的逻辑可以在终端设备中实现，也可以在服务器上实现，因此可以分为终端混音和云端混音。云端混音可以是云端混流的一部分，主要目的是利用云端的计算能力去做多路音视频流的音画对齐，还有降低下行带宽成本。</p><h3 id="混音前的处理"><a href="#混音前的处理" class="headerlink" title="混音前的处理"></a>混音前的处理</h3><hr><p>并非任何两路音频都可以直接混合，必须复合以下条件</p><ol><li>格式相同，要解压成PCM格式</li><li>采样率相同，要转换成相同的采样率。主采样率包括：16kHz，32kHz，44.1kHz，48kHz</li><li>帧长相同，帧长由编码格式决定，PCM没有帧长的概念，开发者自行决定帧长。为了和主流音频编码格式的帧长保持一致，推荐采用20ms为帧长</li><li>位深或者采样格式相同，承载着每个采样点数据的bit数目要相同</li><li>声道数相同，必须是单声道或者双声道</li></ol><p>在格式，采样率，帧长，位深和声道数对齐之后，两个音频才能合流</p><h3 id="基础混音算法"><a href="#基础混音算法" class="headerlink" title="基础混音算法"></a>基础混音算法</h3><hr><p>需要考虑混合权重和溢出处理</p><h1 id="使用mp4v2将h264和aac封装成mp4"><a href="#使用mp4v2将h264和aac封装成mp4" class="headerlink" title="使用mp4v2将h264和aac封装成mp4"></a>使用mp4v2将h264和aac封装成mp4</h1><hr><blockquote><p>使用mp4v2实现这样的封装，封装时需要注意一些细节，比如读取sps，pps，判断idr，音频固定时间戳</p></blockquote><h3 id="视频封装"><a href="#视频封装" class="headerlink" title="视频封装"></a>视频封装</h3><hr><ol><li><p><strong>获取nalu</strong></p><p>拿到h264的数据，先解析内部的nalu</p><p><em>h264-Annex-B</em>的结构</p><p><img src="/../img/h264.png"></p><p>由于机制确保了h264可以按流解析，解析方法也很简单。首先startcode作为起点，接着查找下一个startcode作为终点，然后完成一个nalu的解析，进行循环。</p><p>代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment">* @Project:  AC::NaluParse</span></span><br><span class="line"><span class="comment">* @Decription:  nalu解析工具</span></span><br><span class="line"><span class="comment">* @添加了GetNaluType方法 2022/3/5 13:03:48</span></span><br><span class="line"><span class="comment">* @添加了GetNalusFromFrame方法、查找startcode优化为kmp算法 2022/3/6 1:05:36</span></span><br><span class="line"><span class="comment">* @Verision:  v1.0.2.0</span></span><br><span class="line"><span class="comment">* @Author:  Xin Nie</span></span><br><span class="line"><span class="comment">* @Create:  2022/2/20 13:10:17</span></span><br><span class="line"><span class="comment">* @LastUpdate:  2022/3/6 1:05:36</span></span><br><span class="line"><span class="comment">************************************************************************</span></span><br><span class="line"><span class="comment">* Copyright @ 2022. All rights reserved.</span></span><br><span class="line"><span class="comment">************************************************************************/</span></span><br><span class="line"><span class="keyword">namespace</span> AC &#123;</span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// nalu实体</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Nalu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">NaluParse</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 获取nalu数据，不包含startcode</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;nalu数据&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span>* <span class="title">GetData</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 获取nalu数据长度</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;nalu数据长度&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetDataLength</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 获取nalutype，值为:GetData()&amp;0x1f</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;nalutype&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetNaluType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// nalu解析工具</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NaluParse</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 写入流</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;h264Stream&quot;&gt;h264流&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;len&quot;&gt;h264流长度&lt;/param&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendH264Stream</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* h264Stream, <span class="type">int</span> len)</span></span>;</span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 解析h264流</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;nalu&quot;&gt;获取的nalu,内部提供的缓存头部前面有4bytes预留空间，此时只需外部流的缓冲也预留4bytes空间，则可以方便mp4视频帧的头部4bytes写入。&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;是否获取nalu&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ReceiveNalu</span><span class="params">(Nalu&amp; nalu)</span></span>;</span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 通过帧的方式解析h264</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;h264Frame&quot;&gt;h264帧,需要确保是完整的帧&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;h264FrameLen&quot;&gt;h264帧长度&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;帧内的所有nalu&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::vector&lt;Nalu&gt; <span class="title">GetNalusFromFrame</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>* h264Frame, <span class="type">int</span> h264FrameLen)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>添加视频流</p><p>添加视频流，通常需要取得sps，时间基一般设为90000，相对时间戳则是timescale除以framerate即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* pNalu;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> naluType;</span><br><span class="line">naluType = pNalu[<span class="number">0</span>] &amp; <span class="number">0x1F</span>;</span><br><span class="line">MP4TrackId video = MP4_INVALID_TRACK_ID;</span><br><span class="line"><span class="type">int</span> timeScale=<span class="number">90000</span>;</span><br><span class="line"><span class="keyword">switch</span> (naluType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: <span class="comment">// SPS</span></span><br><span class="line"><span class="keyword">if</span> (video == MP4_INVALID_TRACK_ID)</span><br><span class="line">&#123;</span><br><span class="line">video = <span class="built_in">MP4AddH264VideoTrack</span>(pHandle, timeScale, timeScale/ framerate, width, height, pNalu[<span class="number">1</span>], pNalu[<span class="number">2</span>], pNalu[<span class="number">2</span>], <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>时间基：有了时间戳之后，最终进行展示时还需要将RST时间戳转为秒为单位的时间。</p><p>在执行ffmpag&#x2F;ffmplay指令时，可以通过控制台看到几个参数分别是</p><p>tbr：帧率</p><p>tbn：视频流的时间基</p><p>tbc：视频解码的时间基</p><p>在ffmpeg中，不同的时间戳对应不同的时间基。对于视频的渲染我们使用的是视频流的时间基，也就是 tbn。那我们如何理解时间基呢？其实非常简单，就是时间刻度。我们以帧率为例，如果每秒钟的帧率是 25帧，那么它的时间基（时间刻度）就是 1&#x2F;25。也就是说每隔1&#x2F;25 秒后，显示一帧</p></li></ul></li><li><p>写入sps，pps</p><p>获得nalu后判断其naluType，通常h264首帧是一个idr，idr的第一个nalu是sps，第二个nalu是pps第三个nalu才是idr帧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nalu数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* pNalu;</span><br><span class="line"><span class="comment">//nalu类型</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> naluType;</span><br><span class="line"><span class="comment">//nalu数据长度</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="comment">//获取nalu类型</span></span><br><span class="line">naluType = pNalu[<span class="number">0</span>] &amp; <span class="number">0x1F</span>;</span><br><span class="line"><span class="keyword">switch</span> (naluType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: <span class="comment">// SPS</span></span><br><span class="line"><span class="built_in">MP4AddH264SequenceParameterSet</span>(pHandle, videoId, pNalu, len);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>: <span class="comment">// PPS</span></span><br><span class="line"><span class="built_in">MP4AddH264PictureParameterSet</span>(pHandle, videoId, pNalu, len);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>写入视频帧</p><p>判断nalu的类型为视频帧时通过MP4WriteSample方法写入，需要注意的是判断是idr帧时MP4WriteSample最后一个参数设为true，否则为false。相对时间戳（duration）在实时流中通常是使用帧间时间差。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//nalu数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* pNalu;</span><br><span class="line"><span class="comment">//nalu类型</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> naluType;</span><br><span class="line"><span class="comment">//nalu数据长度</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="comment">//获取nalu类型</span></span><br><span class="line">naluType = pNalu[<span class="number">0</span>] &amp; <span class="number">0x1F</span>;</span><br><span class="line"><span class="type">bool</span> isIdr = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//上一帧时间戳</span></span><br><span class="line"><span class="type">int64_t</span> timestamp=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//naluType ：1-5都是视频帧，其中5是idr。</span></span><br><span class="line"><span class="keyword">switch</span> (naluType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">01</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">02</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">03</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">04</span>:</span><br><span class="line">isIdr = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">05</span>:<span class="comment">//idr</span></span><br><span class="line">    <span class="comment">//mp4 sample的nalu前面需要加上四位需要记录长度</span></span><br><span class="line">pNalu -= <span class="number">4</span>;</span><br><span class="line">pNalu[<span class="number">0</span>] = (len &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">pNalu[<span class="number">1</span>] = (len &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">pNalu[<span class="number">2</span>] = (len &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">pNalu[<span class="number">3</span>] = (len &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">auto</span> _duration = frame.timestamp - timestamp;</span><br><span class="line">timestamp = frame.timestamp;</span><br><span class="line"><span class="built_in">MP4WriteSample</span>(pHandle, videoId, pNalu, len + <span class="number">4</span>, duration * timeScale / <span class="number">1000</span>, <span class="number">0</span>, isIdr);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="音频封装"><a href="#音频封装" class="headerlink" title="音频封装"></a>音频封装</h3><hr><ol><li><p>添加音频流</p><p>添加音频轨道时需要注意时间基(timescale)和相对时间戳(duration)的设置，最方便的方法是timescale&#x3D;samplerate,duration&#x3D;1024。因为一个aac帧就包含1024个采样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> audio=<span class="built_in">MP4AddAudioTrack</span>(pHandle, <span class="number">44100</span>, <span class="number">1024</span>, MP4_MPEG4_AUDIO_TYPE);</span><br></pre></td></tr></table></figure></li><li><p>设置DecoderSpecificInfo</p></li><li><p>写入音频帧’</p></li></ol><h3 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h3><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mp4v2/mp4v2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;AacADTSHeader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;NaluParse.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MP4FileHandle mp4 = <span class="literal">NULL</span>;</span><br><span class="line">FILE* h264= <span class="literal">NULL</span>;</span><br><span class="line">FILE* aac= <span class="literal">NULL</span>;</span><br><span class="line">MP4TrackId videoTrack = MP4_INVALID_TRACK_ID;</span><br><span class="line">MP4TrackId audioTrack = MP4_INVALID_TRACK_ID;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">AC::NaluParse naluParse;</span><br><span class="line">AC::Nalu nalu;</span><br><span class="line">AC::AacADTSHeader adtsHeader;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bufferFull[<span class="number">1028</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* buf = bufferFull + <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> naluType;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* aacData;</span><br><span class="line"><span class="type">int</span> aacDataLength;</span><br><span class="line"><span class="type">int</span> width = <span class="number">1920</span>;</span><br><span class="line"><span class="type">int</span> height = <span class="number">1080</span>;</span><br><span class="line"><span class="type">int</span> frameRate = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> timeScale = <span class="number">90000</span>;</span><br><span class="line"><span class="type">int</span> sampling_frequency_set[] = &#123; <span class="number">6000</span>   ,<span class="number">88200</span>  ,<span class="number">64000</span>  ,<span class="number">48000</span>  ,<span class="number">44100</span>  ,<span class="number">32000</span>  ,<span class="number">24000</span>  ,<span class="number">22050</span>  ,<span class="number">16000</span>  ,<span class="number">12000</span>  , <span class="number">11025</span> , <span class="number">8000</span>  , <span class="number">7350</span> &#125;;</span><br><span class="line">mp4 = <span class="built_in">MP4Create</span>(<span class="string">&quot;test.mp4&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (mp4 == MP4_INVALID_FILE_HANDLE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">exception</span>(<span class="string">&quot;Create mp4 handle fialed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">h264 = <span class="built_in">fopen</span>(<span class="string">&quot;test.h264&quot;</span>, <span class="string">&quot;rb+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!h264)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">exception</span>(<span class="string">&quot;Opene h264 handle fialed.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">aac = <span class="built_in">fopen</span>(<span class="string">&quot;test.aac&quot;</span>, <span class="string">&quot;rb+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!aac)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">exception</span>(<span class="string">&quot;Opene aac handle fialed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//视频</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">size = <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">1024</span>, h264);</span><br><span class="line"><span class="keyword">if</span> (size &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">naluParse.<span class="built_in">SendH264Stream</span>(buf, size);</span><br><span class="line"><span class="keyword">while</span> (naluParse.<span class="built_in">ReceiveNalu</span>(nalu))</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> isIdr = <span class="literal">true</span>;</span><br><span class="line">naluType = nalu.<span class="built_in">GetData</span>()[<span class="number">0</span>] &amp; <span class="number">0x1F</span>;</span><br><span class="line"><span class="keyword">switch</span> (naluType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">01</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">02</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">03</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">04</span>:</span><br><span class="line">isIdr = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">05</span>:<span class="comment">//idr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> pNalu = nalu.<span class="built_in">GetData</span>();</span><br><span class="line">pNalu -= <span class="number">4</span>;</span><br><span class="line">pNalu[<span class="number">0</span>] = (nalu.<span class="built_in">GetDataLength</span>() &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">pNalu[<span class="number">1</span>] = (nalu.<span class="built_in">GetDataLength</span>() &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">pNalu[<span class="number">2</span>] = (nalu.<span class="built_in">GetDataLength</span>() &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">pNalu[<span class="number">3</span>] = (nalu.<span class="built_in">GetDataLength</span>() &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">MP4WriteSample</span>(mp4, videoTrack, pNalu, nalu.<span class="built_in">GetDataLength</span>() + <span class="number">4</span>, MP4_INVALID_DURATION, <span class="number">0</span>, isIdr))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error:Can&#x27;t write sample.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: <span class="comment">// SPS</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (videoTrack == MP4_INVALID_TRACK_ID)</span><br><span class="line">&#123;</span><br><span class="line">videoTrack = <span class="built_in">MP4AddH264VideoTrack</span></span><br><span class="line">(mp4,</span><br><span class="line">timeScale,</span><br><span class="line">timeScale / frameRate,</span><br><span class="line">width,</span><br><span class="line">height,</span><br><span class="line">nalu.<span class="built_in">GetData</span>()[<span class="number">1</span>],</span><br><span class="line">nalu.<span class="built_in">GetData</span>()[<span class="number">2</span>],</span><br><span class="line">nalu.<span class="built_in">GetData</span>()[<span class="number">3</span>],</span><br><span class="line"><span class="number">3</span>);                     <span class="comment">// 4 bytes length before each NAL unit</span></span><br><span class="line"><span class="keyword">if</span> (videoTrack == MP4_INVALID_TRACK_ID)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error:Can&#x27;t add track.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MP4SetVideoProfileLevel</span>(mp4, <span class="number">0x7F</span>);</span><br><span class="line"><span class="built_in">MP4AddH264SequenceParameterSet</span>(mp4, videoTrack, nalu.<span class="built_in">GetData</span>(), nalu.<span class="built_in">GetDataLength</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>: <span class="comment">// PPS</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MP4AddH264PictureParameterSet</span>(mp4, videoTrack, nalu.<span class="built_in">GetData</span>(), nalu.<span class="built_in">GetDataLength</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//音频</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">size = <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">7</span>, aac);</span><br><span class="line"><span class="keyword">if</span> (size &lt; <span class="number">7</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">AC::AacADTSParse::<span class="built_in">BinaryToHeader</span>(buf, adtsHeader);</span><br><span class="line">size = <span class="built_in">fread</span>(buf, <span class="number">1</span>, adtsHeader.aac_frame_length - <span class="number">7</span>, aac);</span><br><span class="line"><span class="keyword">if</span> (size != adtsHeader.aac_frame_length - <span class="number">7</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">exception</span>(<span class="string">&quot;incorrect length!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (adtsHeader.protection_absent == <span class="number">0</span>)</span><br><span class="line"><span class="comment">//有校验位</span></span><br><span class="line">&#123;</span><br><span class="line">aacData = buf + <span class="number">2</span>;</span><br><span class="line">aacDataLength = size - <span class="number">2</span>;</span><br><span class="line"><span class="comment">//TODO：处理校验位buffer[0]、buffer[1]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">aacData = buf;</span><br><span class="line">aacDataLength = size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//TODO：到此取得aac数据aacData、aacDataLength</span></span><br><span class="line"><span class="keyword">if</span> (audioTrack == MP4_INVALID_TRACK_ID)</span><br><span class="line">&#123;</span><br><span class="line">audioTrack = <span class="built_in">MP4AddAudioTrack</span>(mp4, sampling_frequency_set[adtsHeader.sampling_frequency_index], <span class="number">1024</span>, MP4_MPEG4_AUDIO_TYPE);</span><br><span class="line"><span class="keyword">if</span> (audioTrack == MP4_INVALID_TRACK_ID)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">exception</span>(<span class="string">&quot;Add audio track failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MP4SetAudioProfileLevel</span>(mp4, <span class="number">0x02</span>);</span><br><span class="line"><span class="keyword">auto</span> config = <span class="built_in">GetDecoderSpecificInfo</span>(adtsHeader.profile + <span class="number">1</span>, adtsHeader.sampling_frequency_index, adtsHeader.channel_configuration);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">MP4SetTrackESConfiguration</span>(mp4, audioTrack, (<span class="type">uint8_t</span>*)&amp;config, <span class="number">2</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">exception</span>(<span class="string">&quot;set config failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MP4WriteSample</span>(mp4, audioTrack, aacData, aacDataLength, MP4_INVALID_DURATION, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s,\n&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (aac)</span><br><span class="line"><span class="built_in">fclose</span>(aac);</span><br><span class="line"><span class="keyword">if</span> (h264)</span><br><span class="line"><span class="built_in">fclose</span>(h264);</span><br><span class="line"><span class="keyword">if</span> (mp4)</span><br><span class="line"><span class="built_in">MP4Close</span>(mp4);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;封装，解码，重采样，像素格式转换&quot;&gt;&lt;a href=&quot;#封装，解码，重采样，像素格式转换&quot; class=&quot;headerlink&quot; title=&quot;封装，解码，重采样，像素格式转换&quot;&gt;&lt;/a&gt;封装，解码，重采样，像素格式转换&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;MPEG</summary>
      
    
    
    
    
    <category term="音视频" scheme="http://example.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>物理层，数据链路层</title>
    <link href="http://example.com/posts/36116/"/>
    <id>http://example.com/posts/36116/</id>
    <published>2022-08-18T14:39:53.000Z</published>
    <updated>2023-08-24T12:31:49.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h1><h2 id="网络互连模型"><a href="#网络互连模型" class="headerlink" title="网络互连模型"></a>网络互连模型</h2><p>国际ISO组织，制定OSI参考模型，</p><ol><li>运输层：可靠传输</li><li>网络层：IP</li><li>数据链路层：MAC</li><li>物理层：转化成光电信号<br><img src="https://img-blog.csdnimg.cn/20210120134223130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01hc3Rlcl9DdWk=,size_16,color_FFFFFF,t_70"></li></ol><h2 id="数字信号与模拟信号"><a href="#数字信号与模拟信号" class="headerlink" title="数字信号与模拟信号"></a>数字信号与模拟信号</h2><p>模拟信号适合长距离传输，信号连续，抗干扰弱</p><p>数字信号是离散的，是不连续的</p><h2 id="数据通信模型"><a href="#数据通信模型" class="headerlink" title="数据通信模型"></a>数据通信模型</h2><ul><li><p>局域网通信模型</p></li><li><p>广域网通信模型<br>调制解调器</p></li></ul><h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>信息传输的通道，一条传输介质上，可以有多条信道<br>单工，半双工，全双工  </p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><blockquote><p>链路：从一个节点到相邻节点的一段物理线路，中间没有其他交换节点。  </p></blockquote><p>数据链路:在一条链路上传输数据时，需要有相应的通信协议控制数据传输。<br>不同类型的链路，通信协议是不同的。<br>广播信道(CSMA&#x2F;CD)<br>点对点信道(PPP协议)  </p><ol><li>数据链路层-封装成帧<br><img src="https://img-blog.csdnimg.cn/img_convert/cfdb3ab00ce9d3250fe7868ea622d632.png"><br>MTU是最大传输单元:规定了所能传送的帧的数据上限。(不同协议有所不同)<br>帧的数据部分就是网络层传下来的数据包(IP数据包)  </li><li>数据链路层-透明传输<br>透明传输：是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。  </li><li>数据链路层-差错检验<br>FCS-通过计算数字与FCS进行比较</li></ol><h3 id="CSMA-x2F-CD协议"><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h3><p>多路监听访问&#x2F;冲突<br>以太网技术(以太网帧) </p><p>以太网的帧至少64字节 ：为了检测是否产生冲突。   </p><h3 id="Ethernet-V2帧的格式"><a href="#Ethernet-V2帧的格式" class="headerlink" title="Ethernet V2帧的格式"></a>Ethernet V2帧的格式</h3><p><img src="https://img-blog.csdnimg.cn/ce1c3125a4cf4b57a23da3cc09603f24.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5a-M5aOr5bq36LSo5qOA5ZGY5byg5YWo6JuL,size_20,color_FFFFFF,t_70,g_se,x_16"><br>在物理层，会插入帧开始符  </p><ol><li>首部:源MAC+目的MAC+网络类型  </li><li>以太网帧:首部+数据(46字节)+FCS<br>字节不足会填充。</li></ol><h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><p><img src="https://img-blog.csdnimg.cn/0ccbee5fccde4616824e347cec11018c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5a-M5aOr5bq36LSo5qOA5ZGY5byg5YWo6JuL,size_20,color_FFFFFF,t_70,g_se,x_16">  </p><h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>进行差错校验，拆封。工作在数据链路层与物理层。差错校验失败，丢弃。成功，拆封。进行完差错校验扔掉fcs  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络分层&quot;&gt;&lt;a href=&quot;#网络分层&quot; class=&quot;headerlink&quot; title=&quot;网络分层&quot;&gt;&lt;/a&gt;网络分层&lt;/h1&gt;&lt;h2 id=&quot;网络互连模型&quot;&gt;&lt;a href=&quot;#网络互连模型&quot; class=&quot;headerlink&quot; title=&quot;网络互连模</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络层</title>
    <link href="http://example.com/posts/35485/"/>
    <id>http://example.com/posts/35485/</id>
    <published>2022-08-18T14:27:39.000Z</published>
    <updated>2023-08-24T12:31:49.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层数据包-IP数据包"><a href="#网络层数据包-IP数据包" class="headerlink" title="网络层数据包(IP数据包)"></a>网络层数据包(IP数据包)</h2><p>首部+数据&#x3D;网络层数据包<br>数据:一般由传输层传下来的数据段。<br><img src="data:image/png;base64,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"><br>一般头是20个字节作为头部。 </p><h2 id="网络层首部-版本，首部长度，区分服务"><a href="#网络层首部-版本，首部长度，区分服务" class="headerlink" title="网络层首部-版本，首部长度，区分服务"></a>网络层首部-版本，首部长度，区分服务</h2><ol><li>版本:占四位(区别IPv4还是IPv6)</li><li>首部长度:最小20，最大60(可变部分最多40字节，一般是20个字节,首部长度二进制乘4)  </li><li>区分服务:在各种数据的传输过程中，有些数据可能是对带宽要求比较严格的，如我们在ip通话、视频聊天的时候，这个时候给区分服务加个标志，代表这个数据可以优先享受通信。提高服务质量(TOS)</li></ol><h2 id="网络层首部-总长度"><a href="#网络层首部-总长度" class="headerlink" title="网络层首部-总长度"></a>网络层首部-总长度</h2><p>就是整个数据包的长度。可以看到总共占16个bytes，即2的16次方65535。也就是说总长度可以传输65535个bytes的数据。但是，我们知道在数据链路层中最多只能传输1500，于是这个时候就会产生分片，也就是说从网络层下来的数据要分片才能被数据链路层接收。分片后，每一片都有自己的网络层首部。</p><h2 id="网络层首部-标识，标志"><a href="#网络层首部-标识，标志" class="headerlink" title="网络层首部-标识，标志"></a>网络层首部-标识，标志</h2><ol><li>标识<br>数据包被分片后，要怎么知道他们是同一个数据包呢？方法就是通过标识来识别，比如我们可以给分片的数据包的标识都设置为100。<br>不同数据包标识不同，同一数据包标识一致。</li><li>标志<br>标志是用来识别这个数据包是分片的还是没有分片的。占3位，最后1位是1的话代表后面还有分片数据包，0的话代表是最后一个数据包了。中间一位是0的话，代表允许分片，是1的话代表不允许分片（Dont Fragment）。第一位是保留位，还没有具体设置。</li></ol><h2 id="网络层首部-片偏移"><a href="#网络层首部-片偏移" class="headerlink" title="网络层首部-片偏移"></a>网络层首部-片偏移</h2><p><img src="https://img-blog.csdnimg.cn/20191110000155136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk1OTM3Nw==,size_16,color_FFFFFF,t_70"><br>看一下上图，可以看到每个数据包的段偏移量都是首个数据的起点的字节大小除以8，即得到段偏移量。<br>片偏移乘八得到字节偏移。<br>每一片的长度一定是8的整数倍。  </p><h2 id="网络层首部-生存时间-TLL"><a href="#网络层首部-生存时间-TLL" class="headerlink" title="网络层首部-生存时间(TLL)"></a>网络层首部-生存时间(TLL)</h2><p>数据包每经过一个路由的时候TTL都会减一，当TTL为0的时候，则数据包丢失，一般这种情况发生在路由器环路</p><h2 id="网络层首部-协议代码，首部校验和"><a href="#网络层首部-协议代码，首部校验和" class="headerlink" title="网络层首部-协议代码，首部校验和"></a>网络层首部-协议代码，首部校验和</h2><ol><li>协议代码:ICMP：1，IGMP：2，TCP：6，UDP：17，IPv6：41，OSPF：89。有些协议，可能是工作在几层，不用全部执行。</li><li>首部检验和：是为了检测首部数据在传输过程中是否出错的，对头部进行计算。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络层&quot;&gt;&lt;a href=&quot;#网络层&quot; class=&quot;headerlink&quot; title=&quot;网络层&quot;&gt;&lt;/a&gt;网络层&lt;/h1&gt;&lt;h2 id=&quot;网络层数据包-IP数据包&quot;&gt;&lt;a href=&quot;#网络层数据包-IP数据包&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>RTP</title>
    <link href="http://example.com/posts/11679/"/>
    <id>http://example.com/posts/11679/</id>
    <published>2022-08-17T14:46:40.000Z</published>
    <updated>2023-08-24T12:31:49.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RTP协议"><a href="#RTP协议" class="headerlink" title="RTP协议"></a>RTP协议</h1><blockquote><p>基于RTP协议的H264&#x2F;H265的码流解析</p></blockquote><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>浏览器支持webrtc，基于流媒体协议的RTP&#x2F;RTCP协议做了一些扩展(RTCP)</p><ul><li>RTP核心字段的意义以及运用</li><li>H264&#x2F;H265的NAL单元结构</li><li>H264&#x2F;H265组帧的方法</li><li>分析码流，定位媒体问题</li></ul><h2 id="RTP"><a href="#RTP" class="headerlink" title="RTP"></a>RTP</h2><blockquote><p>RFC3550协议中没有明确指定RTP所依赖的传输层协议，但是绝大部分实体流媒体系统使用UDP<br>UDP的特点是数据包处理快(不可靠，简单直接)，适用于实时媒体系统<br>WEBRTC的RTP协议也是基于UDP的，尽量在运行时匀速解析</p></blockquote><h3 id="RTP包的结构"><a href="#RTP包的结构" class="headerlink" title="RTP包的结构"></a>RTP包的结构</h3><p><img src="https://img-blog.csdnimg.cn/20190411090259358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tnZFlzZw==,size_16,color_FFFFFF,t_70" alt="RTP包头结构"></p><ol start="7"><li>V:RTP版本号</li><li>P:是否填充，如果允许填充的话，在包的尾端填充一个或多个字节，不属于有效载荷。</li><li>X:扩充位，如果设置为允许的话，在固定头的后面，紧跟一个拓展头结构，该结构是定义自己的一种格式</li><li>CSRS Count(CC):数据源的个数，如果只有一个源值为0</li><li>M:Mark，在流媒体中标识重要的事物,标识序列包是否结束。</li><li>PT(Payload type):有效负载，由具体的程序确定负载的格式和意义。编码格式。</li><li>sequence number:发送的数据包序号，接收端用来检查丢失的数据包和确定存储数据包次序。该字段加一递增，用来判断是否丢包。</li><li>timestamp:时间戳，记录了第一个字节的采样时间，源自一个增量并且允许同步与运算</li><li>SSRC:同步标识，是一个随机数，在同一个RTP会话中只有一个同步标识。RTP流的唯一标识，主流和辅流。</li><li>CSRC:贡献源标识字符表，标识此数据中包含的有效负载的贡献源</li><li>payload:媒体数据，负载数据(视频，音频)</li></ol><p>RTP包的结构&#x3D;RTP包头+媒体数据<br>视频数据的特征</p><ul><li>数据量大</li><li>严格时序</li><li>视频编码的格式有很多种(H264,H263,)</li></ul><h3 id="使用Wireshark分析RTP包"><a href="#使用Wireshark分析RTP包" class="headerlink" title="使用Wireshark分析RTP包"></a>使用Wireshark分析RTP包</h3><ol><li>丢包:Seq,开始:也可以在电话-&gt;RTp-&gt;RTP流进行丢包的分析</li><li>是否有Mark位：同一序列内，时间戳相等。Mark是用来进行解码的标识。</li><li>SSRC是否一致</li><li>乱序:Seq的顺序不同</li></ol><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><blockquote><p>全名Transmission Control Protocol，传输控制协议。TCP则面向的是端口到端口，保证数据传输的完整和可靠，包括数据包的确认、失败重发、流量控制，数据量大的情况TCP会将数据拆分为有序的多个数据包传输，TCP需要能将数据包重组为完整的数据</p></blockquote><h4 id="TCP保证数据的可靠性与完整性"><a href="#TCP保证数据的可靠性与完整性" class="headerlink" title="TCP保证数据的可靠性与完整性"></a>TCP保证数据的可靠性与完整性</h4><ol><li>确认应答和序列号</li><li>超时重传</li><li>流量控制</li><li>滑动窗口<br><img src="https://img-blog.csdnimg.cn/20210829145335850.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qyj5a6HSQ==,size_20,color_FFFFFF,t_70,g_se,x_16"></li></ol><p>两个端口：代表了两台主机的两个进程：<br>两个序号，第一个代表发送端本次数据包的序号，确认序号表示发送端希望下次收到接收端的报文序号；<br>4位首部长度，表示tcp头多少个字节<br>6位标志位，常见的就是ACK,SYN,FIN,RST  </p><ul><li>URG: 本报文段中发送的数据是否包含紧急数据  </li><li>ACK: 标识确认序号是否有效，1确认序号有效，0无效忽略确认号  </li><li>PSH: 为1时用来提示接收端应用程序立刻将数据从tcp缓冲区读走  </li><li>RST: 要求重新建立连接，通常发生在某一端出现错误的情况，强制关闭连接  </li><li>SYN: 请求建立连接  </li><li>FIN: 通知接收方, 发送方没有数据了，即将关闭连接<br>三次握手，四次挥手</li></ul><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p>SSL是应用层下，TCP传输层之上的一个协议加密层。<br>TLS核心思想是非对称加密，通讯双方都使用对方公钥加密消息，私钥签名，接受到消息后使用私钥解密，公钥验证签名，并辅以CA签发证书来验证双方身份，这样即解决了上述安全问题。</p><ol><li>单向认证<br>客户端验证服务端身份，一次通讯过程是</li></ol><ul><li>TCP三次挥手建立连接</li><li>客户端向服务端发起SSL请求，表明自己支持的所有加密方式，并请求服务端证书</li><li>服务端接收请求，选择一种加密方式以及附带证书响应给客户</li><li>客户端验证服务端证书可信，生成对称密钥，使用服务端公钥加密后发送给服务端</li><li>服务端接收到加密的对称密钥，使用客户端证书解签认证，使用私钥解密后得到对称密钥</li><li>开始使用对称密钥加密通信</li></ul><ol start="2"><li>双向认证<br>双向认证即服务端也需要验证客户端身份，加粗为与单向区别</li></ol><ul><li>TCP三次握手建立连接</li><li>客户端向服务端发送建立SSL请求，表明自己支持的所有加密方式，并请求获取服务端证书</li><li>服务端接收请求，选择一种加密方式以及附带证书响应给客户端，<strong>并请求获取客户端证书</strong></li><li>客户端验证服务端证书可信，生成对称密钥，使用服务端公钥加密后附<strong>带客户端证书</strong>发送给服务端</li><li>服务端接收到加密的对称密钥和<strong>客户端证书，验证证书可信</strong>，使用客户端证书解签认证，使用私钥解密后得到对称密钥</li></ul><h2 id="ALPN"><a href="#ALPN" class="headerlink" title="ALPN"></a>ALPN</h2><blockquote><p>Application Layer Protocol Negotiation，应用层协议协商，双方协商在安全连接之上的应用层协议，TLS的扩展，类似TCP对滑动窗口大小的扩展，在TLS握手中，客户端会会发送给服务端客户端所支持的协议列表，服务端从中选择自己支持的协议类型响应给客户端</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RTP协议&quot;&gt;&lt;a href=&quot;#RTP协议&quot; class=&quot;headerlink&quot; title=&quot;RTP协议&quot;&gt;&lt;/a&gt;RTP协议&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;基于RTP协议的H264&amp;#x2F;H265的码流解析&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    
    <category term="音视频" scheme="http://example.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
</feed>
